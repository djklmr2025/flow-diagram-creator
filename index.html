<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Diagramas de Flujo Interactivos v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #eee;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            z-index: 1000;
            border-bottom: 2px solid #0f3460;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .btn {
            padding: 8px 15px;
            background: #0f3460;
            border: none;
            border-radius: 5px;
            color: #eee;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            background: #e94560;
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: #e94560;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        .separator {
            width: 2px;
            background: #0f3460;
            margin: 0 5px;
        }

        #canvas-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: #1a1a2e;
            cursor: grab;
        }

        #canvas-container.grabbing {
            cursor: grabbing;
        }

        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #properties-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
        }

        #properties-panel.show {
            display: block;
        }

        .property-group {
            margin-bottom: 15px;
        }

        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }

        .property-group input,
        .property-group select {
            width: 100%;
            padding: 8px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 5px;
            color: #eee;
            font-size: 14px;
        }

        .color-picker {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #zoom-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #16213e;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 8px 15px;
            font-size: 12px;
            border-top: 2px solid #0f3460;
            display: flex;
            justify-content: space-between;
        }

        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 5px;
        }

        .indicator-connected {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .indicator-error {
            background: #f44336;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .indicator-disconnected {
            background: rgba(255, 255, 255, 0.3);
        }

        input[type="file"] {
            display: none;
        }

        #publish-result {
            margin-top: 12px;
            padding: 10px;
            background: #0f3460;
            border-radius: 8px;
            font-size: 12px;
            word-break: break-all;
            display: none;
        }

        #publish-file-status {
            margin-top: 8px;
            font-size: 12px;
            color: #aaa;
        }

        #library-status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }

        #library-upload-status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
        }

        #library-list {
            margin-top: 10px;
            background: #0f3460;
            border-radius: 8px;
            max-height: 55vh;
            overflow-y: auto;
        }

        .library-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .library-row:last-child {
            border-bottom: none;
        }

        .library-name {
            flex: 1;
            margin-right: 10px;
            font-size: 13px;
        }

        .library-actions {
            display: flex;
            gap: 8px;
        }

        .btn.small {
            padding: 6px 10px;
            font-size: 12px;
        }

        /* ==================== DECK MODE (L√ÅMINA) ==================== */
        #deck-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 420px;
            background: rgba(22, 33, 62, 0.98);
            border-left: 2px solid #0f3460;
            z-index: 1500;
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 14px 14px 16px 14px;
            overflow: hidden;
        }

        #deck-panel.show {
            display: flex;
        }

        body.deck-mode #canvas-container {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .deck-title {
            font-size: 14px;
            font-weight: 700;
            color: #eee;
            letter-spacing: 0.4px;
        }

        .deck-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .deck-section {
            background: #0f3460;
            border-radius: 10px;
            padding: 12px;
            overflow: auto;
        }

        .deck-section h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.85);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        #deck-control-points {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .deck-cp {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #eee;
            cursor: pointer;
            text-align: left;
        }

        .deck-cp:hover {
            border-color: rgba(233, 69, 96, 0.6);
        }

        .deck-cp.active {
            border-color: #e94560;
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.18) inset;
        }

        .deck-cp-name {
            flex: 1;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .deck-cp-id {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.55);
        }

        #deck-slide-title {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        #deck-slide-image {
            width: 100%;
            max-height: 220px;
            object-fit: contain;
            border-radius: 10px;
            background: rgba(0,0,0,0.2);
            display: none;
        }

        #deck-slide-text {
            margin-top: 10px;
            font-size: 13px;
            line-height: 1.35;
            color: rgba(255, 255, 255, 0.9);
            white-space: pre-wrap;
        }

        .deck-share-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        #deck-share-status {
            margin-top: 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-word;
        }

        #deck-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1;
            touch-action: none;
        }

        body.deck-horizontal #deck-resize-handle {
            left: -6px;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
        }

        body.deck-vertical #deck-resize-handle {
            top: -6px;
            left: 0;
            right: 0;
            height: 12px;
            cursor: ns-resize;
        }

        #deck-resize-handle::before {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.14);
            border-radius: 2px;
        }

        body.deck-horizontal #deck-resize-handle::before {
            left: 5px;
            top: 20px;
            bottom: 20px;
            width: 2px;
        }

        body.deck-vertical #deck-resize-handle::before {
            top: 5px;
            left: 20px;
            right: 20px;
            height: 2px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #e94560;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 5px;
            color: #eee;
        }

        .modal-hint {
            font-size: 12px;
            opacity: 0.85;
            margin-top: -8px;
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #0f3460;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e94560;
        }

        /* Handles de redimensionamiento */
        .resize-handle {
            fill: #e94560;
            stroke: #fff;
            stroke-width: 2;
            cursor: pointer;
        }

        .resize-handle:hover {
            fill: #ff6b81;
        }

        /* Cursor para pan */
        #canvas-container.pan-mode {
            cursor: move;
        }

        /* Men√∫ contextual */
        #context-menu {
            position: fixed;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 3000;
            display: none;
        }

        #context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            color: #eee;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: #0f3460;
        }

        .context-menu-separator {
            height: 1px;
            background: #0f3460;
            margin: 5px 0;
        }

        /* Overlay para cerrar l√≠neas */
        .close-path-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 2500;
            display: none;
            animation: pulse 2s infinite;
        }

        .close-path-hint.show {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); }
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <!-- Herramientas de dibujo -->
        <button class="btn" id="btn-select" title="Seleccionar (V)">
            <span>‚úã</span> Seleccionar
        </button>
        <button class="btn" id="btn-rectangle" title="Rect√°ngulo (R)">
            <span>‚ñ≠</span> Rect√°ngulo
        </button>
        <button class="btn" id="btn-circle" title="C√≠rculo (C)">
            <span>‚óè</span> C√≠rculo
        </button>
        <button class="btn" id="btn-line" title="L√≠nea Animada (L)">
            <span>‚Üí</span> L√≠nea
        </button>
        <button class="btn" id="btn-pencil" title="Dibujo Libre (P)">
            <span>‚úèÔ∏è</span> L√°piz
        </button>
        
        <button class="btn" id="btn-image" title="Insertar Imagen (I)">
            <span>üñºÔ∏è</span> Imagen
        </button>
        
        <div class="separator"></div>
        
        <!-- Acciones -->
        <button class="btn" id="btn-group" title="Agrupar (Ctrl+G)">
            <span>‚äû</span> Agrupar
        </button>
        <button class="btn" id="btn-ungroup" title="Desagrupar">
            <span>‚äü</span> Desagrupar
        </button>
        <button class="btn" id="btn-lock" title="Fijar/Desfijar (Ctrl+L)">
            <span>üîí</span> Fijar
        </button>
        <button class="btn" id="btn-bring-front" title="Traer al Frente">
            <span>‚¨ÜÔ∏è</span> Al Frente
        </button>
        <button class="btn" id="btn-send-back" title="Enviar Atr√°s">
            <span>‚¨áÔ∏è</span> Atr√°s
        </button>
        
        <div class="separator"></div>
        
        <!-- Edici√≥n -->
        <button class="btn" id="btn-copy" title="Copiar (Ctrl+C)">
            <span>üìã</span> Copiar
        </button>
        <button class="btn" id="btn-paste" title="Pegar (Ctrl+V)">
            <span>üìÑ</span> Pegar
        </button>
        <button class="btn" id="btn-delete" title="Eliminar (Del)">
            <span>üóëÔ∏è</span> Eliminar
        </button>
        <button class="btn" id="btn-undo" title="Deshacer (Ctrl+Z)">
            <span>‚Ü∂</span> Deshacer
        </button>
        
        <div class="separator"></div>
        
        <!-- Zoom -->
        <button class="btn" id="btn-zoom-in" title="Acercar (+)">
            <span>üîç+</span>
        </button>
        <button class="btn" id="btn-zoom-out" title="Alejar (-)">
            <span>üîç-</span>
        </button>
        <button class="btn" id="btn-zoom-reset" title="Restablecer Zoom (0)">
            <span>‚äô</span> 100%
        </button>
        
        <div class="separator"></div>
        
        <!-- Archivo -->
        <button class="btn" id="btn-new" title="Nuevo Proyecto">
            <span>üìÑ</span> Nuevo
        </button>
        <button class="btn" id="btn-save" title="Guardar (Ctrl+S)">
            <span>üíæ</span> Guardar
        </button>
        <button class="btn" id="btn-load" title="Cargar">
            <span>üìÇ</span> Cargar
        </button>
        <button class="btn" id="btn-export" title="Exportar JSON">
            <span>‚¨áÔ∏è</span> Exportar
        </button>
        <button class="btn" id="btn-publish" title="Publicar Sticker (Link IA)">
            <span>üîó</span> Publicar
        </button>
        <button class="btn" id="btn-library" title="Biblioteca de Stickers">
            <span>üìö</span> Biblioteca
        </button>
        
        <input type="file" id="file-input" accept=".json">
        <input type="file" id="publish-file-input" accept=".json">
        <input type="file" id="library-upload-input" accept=".json">
        <input type="file" id="image-input" accept="image/png,image/jpeg,image/jpg,image/gif,image/webp">
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
    </div>

    <!-- Deck Panel (Modo L√°mina / Informativo) -->
    <div id="deck-panel">
        <div id="deck-resize-handle" title="Redimensionar panel"></div>
        <div class="deck-header">
            <div class="deck-title">L√°mina</div>
            <div class="deck-actions">
                <button class="btn small" id="btn-deck-copy-link" title="Copiar enlace de la l√°mina">Copiar Link</button>
            </div>
        </div>

        <div class="deck-section">
            <h3>Puntos de Control</h3>
            <div id="deck-control-points"></div>
        </div>

        <div class="deck-section">
            <h3>Diapositiva</h3>
            <div id="deck-slide">
                <div id="deck-slide-title"></div>
                <img id="deck-slide-image" alt="Diapositiva">
                <div id="deck-slide-text"></div>
            </div>
        </div>

        <div class="deck-section">
            <h3>Compartir</h3>
            <div class="deck-share-row">
                <button class="btn" id="btn-deck-whatsapp" title="Enviar link a WhatsApp">WhatsApp</button>
                <button class="btn" id="btn-deck-share" title="Compartir (si est√° disponible)">Compartir</button>
            </div>
            <div id="deck-share-status"></div>
        </div>
    </div>

    <!-- Panel de Propiedades -->
    <div id="properties-panel">
        <h3>Propiedades</h3>
        <div class="property-group">
            <label>Nombre:</label>
            <input type="text" id="prop-name" placeholder="Nombre del elemento">
        </div>
        <div class="property-group">
            <label>Color de Relleno:</label>
            <input type="color" id="prop-fill-color" class="color-picker" value="#0f3460">
        </div>
        <div class="property-group">
            <label>Color de Borde:</label>
            <input type="color" id="prop-stroke-color" class="color-picker" value="#e94560">
        </div>
        <div class="property-group">
            <label>Color de Animaci√≥n:</label>
            <input type="color" id="prop-anim-color" class="color-picker" value="#4caf50">
        </div>
        <div class="property-group">
            <label>Direcci√≥n de Flujo:</label>
            <select id="prop-flow-direction">
                <option value="right">Izquierda ‚Üí Derecha</option>
                <option value="left">Derecha ‚Üí Izquierda</option>
            </select>
        </div>
        <div class="property-group">
            <label>Estado de Conexi√≥n:</label>
            <select id="prop-connection-status">
                <option value="none">Sin Conectar</option>
                <option value="connected">Conectado ‚úì</option>
                <option value="error">Error ‚úó</option>
            </select>
        </div>
        <div class="property-group">
            <label>Activo:</label>
            <select id="prop-active">
                <option value="true">S√≠ - Animando</option>
                <option value="false">No - Pausado</option>
            </select>
        </div>
    </div>

    <!-- Indicador de Zoom -->
    <div id="zoom-indicator">Zoom: 100%</div>

    <!-- Barra de Estado -->
    <div id="status-bar">
        <span id="status-text">Listo | Elementos: 0 | Seleccionados: 0</span>
        <span id="cursor-pos">X: 0, Y: 0</span>
    </div>

    <!-- Men√∫ Contextual -->
    <div id="context-menu">
        <div class="context-menu-item" id="ctx-bring-to-front">
            <span>‚¨ÜÔ∏è</span> Traer al Frente de Todo
        </div>
        <div class="context-menu-item" id="ctx-bring-forward">
            <span>‚Üë</span> Traer Adelante
        </div>
        <div class="context-menu-item" id="ctx-send-backward">
            <span>‚Üì</span> Enviar Atr√°s
        </div>
        <div class="context-menu-item" id="ctx-send-to-back">
            <span>‚¨áÔ∏è</span> Enviar al Fondo
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="ctx-duplicate">
            <span>üìã</span> Duplicar
        </div>
        <div class="context-menu-item" id="ctx-delete">
            <span>üóëÔ∏è</span> Eliminar
        </div>
    </div>

    <!-- Hint para cerrar paths -->
    <div class="close-path-hint" id="close-path-hint">
        Haz clic cerca del inicio para cerrar la figura ‚ú®
    </div>

    <!-- Modal para Guardar -->
    <div id="save-modal" class="modal">
        <div class="modal-content">
            <h2>Guardar Proyecto</h2>
            <input type="text" id="project-name" placeholder="Nombre del proyecto">
            <div class="modal-buttons">
                <button class="btn" id="btn-cancel-save">Cancelar</button>
                <button class="btn" id="btn-confirm-save">Guardar</button>
            </div>
        </div>
    </div>

    <!-- Modal para Publicar -->
    <div id="publish-modal" class="modal">
        <div class="modal-content">
            <h2>Publicar Sticker</h2>
            <input type="text" id="publish-name" placeholder="Nombre (opcional)">
            <input type="text" id="publish-folder" placeholder="Carpeta (ej: metro/linea-1) (opcional)">
            <input type="password" id="publish-key" placeholder="Llave de publicaci√≥n (PUBLISH_KEY) (opcional)">
            <div class="modal-hint">Solo si configuraste <code>PUBLISH_KEY</code> en Vercel. Se guarda en este navegador.</div>
            <div class="modal-buttons" style="justify-content: flex-start;">
                <button class="btn small" id="btn-pick-publish-file" title="Publicar desde un archivo JSON">Subir JSON‚Ä¶</button>
                <button class="btn small" id="btn-clear-publish-file" title="Volver a publicar el canvas actual" style="display:none;">Usar Canvas</button>
            </div>
            <div id="publish-file-status"></div>
            <div class="modal-buttons">
                <button class="btn" id="btn-cancel-publish">Cancelar</button>
                <button class="btn" id="btn-confirm-publish">Publicar</button>
            </div>
            <div id="publish-result"></div>
        </div>
    </div>

    <!-- Modal Biblioteca -->
    <div id="library-modal" class="modal">
        <div class="modal-content">
            <h2>Biblioteca</h2>
            <input type="text" id="library-prefix" placeholder="Carpeta (ej: metro/linea-1) (vac√≠o = ra√≠z)">
            <div class="modal-buttons">
                <button class="btn" id="btn-library-up">Arriba</button>
                <button class="btn" id="btn-library-refresh">Actualizar</button>
                <button class="btn" id="btn-library-upload" title="Subir un JSON a esta carpeta">Subir nuevo archivo</button>
                <button class="btn" id="btn-library-close">Cerrar</button>
            </div>
            <div id="library-status"></div>
            <div id="library-upload-status"></div>
            <div id="library-list"></div>
        </div>
    </div>

    <script>
        // ==================== SISTEMA MODULAR ====================
        // Arquitectura base que permite agregar m√≥dulos sin romper el n√∫cleo

        class FlowDiagramSystem {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.elements = [];
                this.selectedElements = [];
                this.clipboard = null;
                this.history = [];
                this.historyIndex = -1;
                
                // Estado del canvas
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1,
                    targetZoom: 1
                };
                
                // Estado de interacci√≥n
                this.tool = 'select';
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = { x: 0, y: 0 };
                this.tempElement = null;
                this.hoveredElement = null;
                this.resizingElement = null;
                this.resizeHandle = null;
                this.drawingPath = null;
                this.spacePressed = false;
                this.contextMenuElement = null;
                this.loadedImages = {}; // Cache de im√°genes cargadas
                this.autoClosePathDistance = 15; // Distancia para auto-cerrar paths

                // Modo visor (IA/preview): sin edici√≥n, sin grid y con fondo transparente.
                this.readOnly = false;
                this.showGrid = true;
                this.backgroundColor = '#1a1a2e'; // null => transparente
                this.viewerMode = null; // null | 'sticker' | 'deck'

                // Estado del "deck" (l√°mina informativa)
                this.deckLayout = 'horizontal'; // 'horizontal' | 'vertical'
                this.activeControlPointId = null;
                this._deckResizing = false;

                // Publicaci√≥n desde archivo
                this.publishFileProject = null;
                this.publishFileName = '';

                // Navegaci√≥n de biblioteca
                this.libraryPrefix = '';
                
                // M√≥dulos (permite expandir funcionalidad)
                this.modules = {};
                
                this.init();
            }
            
            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.setupContextMenu();
                this.loadFromLocalStorage();
                this.startAnimationLoop();
                
                // Seleccionar herramienta por defecto
                document.getElementById('btn-select').classList.add('active');
                
                // NUEVO: Cargar JSON desde par√°metros de URL (si existen)
                this.loadFromURLParameter();
            }
            
            resizeCanvas() {
                const toolbar = document.getElementById('toolbar');
                const statusBar = document.getElementById('status-bar');
                const toolbarHeight = toolbar ? toolbar.offsetHeight : 0;
                const statusHeight = statusBar ? statusBar.offsetHeight : 0;

                // Mantener el contenedor del canvas alineado con el layout real (toolbar/status-bar)
                // Nota: en modo deck, el tama√±o/posici√≥n del contenedor se controla externamente.
                const container = document.getElementById('canvas-container');
                if (container && this.viewerMode !== 'deck') {
                    container.style.top = `${toolbarHeight}px`;
                    container.style.bottom = `${statusHeight}px`;
                }

                if (container) {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = Math.max(0, Math.floor(rect.width));
                    this.canvas.height = Math.max(0, Math.floor(rect.height));
                    return;
                }

                // Fallback
                this.canvas.width = window.innerWidth;
                this.canvas.height = Math.max(0, window.innerHeight - toolbarHeight - statusHeight);
            }
            
            setupEventListeners() {
                // Resize
                window.addEventListener('resize', () => {
                    if (this.viewerMode === 'deck') {
                        this.applyDeckSizing();
                    }
                    this.resizeCanvas();
                });
                
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('click', (e) => this.onClick(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevenir men√∫ contextual
                
                // Cerrar men√∫ contextual al hacer clic fuera
                document.addEventListener('click', () => this.hideContextMenu());
                
                // Prevenir scroll en el canvas
                this.canvas.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
                
                // Keyboard events
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                window.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // Toolbar buttons
                this.setupToolbar();
                
                // Properties panel
                this.setupPropertiesPanel();
            }
            
            setupToolbar() {
                // Herramientas de dibujo
                document.getElementById('btn-select').addEventListener('click', () => this.setTool('select'));
                document.getElementById('btn-rectangle').addEventListener('click', () => this.setTool('rectangle'));
                document.getElementById('btn-circle').addEventListener('click', () => this.setTool('circle'));
                document.getElementById('btn-line').addEventListener('click', () => this.setTool('line'));
                document.getElementById('btn-pencil').addEventListener('click', () => this.setTool('pencil'));
                document.getElementById('btn-image').addEventListener('click', () => this.insertImage());
                
                // Acciones
                document.getElementById('btn-group').addEventListener('click', () => this.groupElements());
                document.getElementById('btn-ungroup').addEventListener('click', () => this.ungroupElements());
                document.getElementById('btn-lock').addEventListener('click', () => this.toggleLock());
                document.getElementById('btn-bring-front').addEventListener('click', () => this.bringToFront());
                document.getElementById('btn-send-back').addEventListener('click', () => this.sendToBack());
                
                // Edici√≥n
                document.getElementById('btn-copy').addEventListener('click', () => this.copyElements());
                document.getElementById('btn-paste').addEventListener('click', () => this.pasteElements());
                document.getElementById('btn-delete').addEventListener('click', () => this.deleteElements());
                document.getElementById('btn-undo').addEventListener('click', () => this.undo());
                
                // Zoom
                document.getElementById('btn-zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('btn-zoom-out').addEventListener('click', () => this.zoomOut());
                document.getElementById('btn-zoom-reset').addEventListener('click', () => this.resetZoom());
                
                // Archivo
                document.getElementById('btn-new').addEventListener('click', () => this.newProject());
                document.getElementById('btn-save').addEventListener('click', () => this.showSaveModal());
                document.getElementById('btn-load').addEventListener('click', () => this.loadProject());
                document.getElementById('btn-export').addEventListener('click', () => this.exportProject());
                document.getElementById('btn-publish').addEventListener('click', () => this.showPublishModal());
                document.getElementById('btn-library').addEventListener('click', () => this.showLibraryModal());
                
                // Modal de guardado
                document.getElementById('btn-cancel-save').addEventListener('click', () => this.hideSaveModal());
                document.getElementById('btn-confirm-save').addEventListener('click', () => this.saveProject());

                // Modal de publicaci√≥n
                document.getElementById('btn-cancel-publish').addEventListener('click', () => this.hidePublishModal());
                document.getElementById('btn-confirm-publish').addEventListener('click', () => this.publishSticker());
                document.getElementById('btn-pick-publish-file').addEventListener('click', () => this.pickPublishFile());
                document.getElementById('btn-clear-publish-file').addEventListener('click', () => this.clearPublishFile());
                this.setupPublishKey();

                // Modal biblioteca
                document.getElementById('btn-library-close').addEventListener('click', () => this.hideLibraryModal());
                document.getElementById('btn-library-refresh').addEventListener('click', () => this.refreshLibrary());
                document.getElementById('btn-library-up').addEventListener('click', () => this.libraryNavigateUp());
                document.getElementById('btn-library-upload').addEventListener('click', () => this.pickLibraryUploadFile());
                document.getElementById('library-prefix').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') this.refreshLibrary();
                });
                document.getElementById('library-list').addEventListener('click', (e) => this.onLibraryClick(e));
                
                // File input
                document.getElementById('file-input').addEventListener('change', (e) => this.importProject(e));
                document.getElementById('publish-file-input').addEventListener('change', (e) => this.onPublishFileSelected(e));
                document.getElementById('library-upload-input').addEventListener('change', (e) => this.onLibraryUploadSelected(e));
                document.getElementById('image-input').addEventListener('change', (e) => this.loadImageFile(e));

                // Deck (l√°mina informativa)
                const deckList = document.getElementById('deck-control-points');
                if (deckList) {
                    deckList.addEventListener('click', (e) => this.onDeckControlPointClick(e));
                }
                const deckWhatsapp = document.getElementById('btn-deck-whatsapp');
                if (deckWhatsapp) {
                    deckWhatsapp.addEventListener('click', () => this.shareDeckToWhatsApp());
                }
                const deckShare = document.getElementById('btn-deck-share');
                if (deckShare) {
                    deckShare.addEventListener('click', () => this.shareDeckNative());
                }
                const deckCopyLink = document.getElementById('btn-deck-copy-link');
                if (deckCopyLink) {
                    deckCopyLink.addEventListener('click', () => this.copyDeckLink());
                }
                this.setupDeckResizer();
            }
            
            setupContextMenu() {
                document.getElementById('ctx-bring-to-front').addEventListener('click', () => {
                    this.bringToFrontComplete();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-bring-forward').addEventListener('click', () => {
                    this.bringToFront();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-send-backward').addEventListener('click', () => {
                    this.sendToBack();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-send-to-back').addEventListener('click', () => {
                    this.sendToBackComplete();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-duplicate').addEventListener('click', () => {
                    this.duplicateSelected();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-delete').addEventListener('click', () => {
                    this.deleteElements();
                    this.hideContextMenu();
                });
            }
            
            setupPropertiesPanel() {
                const inputs = ['prop-name', 'prop-fill-color', 'prop-stroke-color', 'prop-anim-color', 
                               'prop-flow-direction', 'prop-connection-status', 'prop-active'];
                
                inputs.forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.updateSelectedProperties());
                });
            }
            
            setTool(tool) {
                if (this.readOnly) {
                    // En modo visor no permitimos cambiar herramientas.
                    this.tool = 'select';
                    return;
                }

                this.tool = tool;
                
                // Actualizar UI
                document.querySelectorAll('.btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                const btnMap = {
                    'select': 'btn-select',
                    'rectangle': 'btn-rectangle',
                    'circle': 'btn-circle',
                    'line': 'btn-line',
                    'pencil': 'btn-pencil'
                };
                
                if (btnMap[tool]) {
                    document.getElementById(btnMap[tool]).classList.add('active');
                }
            }
            
            // ==================== TRANSFORMACIONES ====================
            
            screenToWorld(x, y) {
                return {
                    x: (x - this.camera.x) / this.camera.zoom,
                    y: (y - this.camera.y) / this.camera.zoom
                };
            }
            
            worldToScreen(x, y) {
                return {
                    x: x * this.camera.zoom + this.camera.x,
                    y: y * this.camera.zoom + this.camera.y
                };
            }
            
            // ==================== EVENTOS DEL MOUSE ====================
            
            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);

                // Modo visor: solo pan/zoom (sin selecci√≥n, sin edici√≥n, sin men√∫ contextual)
                if (this.readOnly) {
                    // En deck: permitir seleccionar "puntos de control" (sin editar).
                    if (this.viewerMode === 'deck' && e.button === 0 && !this.spacePressed) {
                        const clicked = this.getElementAt(worldPos.x, worldPos.y);
                        if (clicked && this.isControlPoint(clicked)) {
                            this.setActiveControlPoint(clicked, { focus: true, updateUrl: true });
                            return;
                        }
                    }

                    // Pan con click izquierdo o rueda (o espacio si se mantiene compatibilidad)
                    if (e.button === 0 || e.button === 1 || this.spacePressed) {
                        e.preventDefault();
                        this.isPanning = true;
                        this.dragStart = { x: mouseX, y: mouseY };
                        document.getElementById('canvas-container').classList.add('grabbing');
                        this.canvas.style.cursor = 'grabbing';
                    }
                    return;
                }
                
                // Men√∫ contextual con bot√≥n derecho
                if (e.button === 2) {
                    const clickedElement = this.getElementAt(worldPos.x, worldPos.y);
                    if (clickedElement) {
                        if (!this.selectedElements.includes(clickedElement)) {
                            this.selectedElements = [clickedElement];
                        }
                        this.showContextMenu(e.clientX, e.clientY);
                        this.updatePropertiesPanel();
                        return;
                    }
                }
                
                // Pan con rueda del mouse o espacio
                if (e.button === 1 || this.spacePressed) {
                    e.preventDefault();
                    this.isPanning = true;
                    this.dragStart = { x: mouseX, y: mouseY };
                    document.getElementById('canvas-container').classList.add('grabbing');
                    return;
                }
                
                if (this.tool === 'select') {
                    // Verificar si estamos sobre un handle de redimensionamiento
                    const handleInfo = this.getResizeHandleAt(worldPos.x, worldPos.y);
                    if (handleInfo) {
                        this.resizingElement = handleInfo.element;
                        this.resizeHandle = handleInfo.handle;
                        this.dragStart = { x: worldPos.x, y: worldPos.y };
                        return;
                    }
                    
                    const clicked = this.getElementAt(worldPos.x, worldPos.y);
                    
                    if (clicked) {
                        if (!e.ctrlKey && !this.selectedElements.includes(clicked)) {
                            this.selectedElements = [clicked];
                        } else if (e.ctrlKey) {
                            const idx = this.selectedElements.indexOf(clicked);
                            if (idx >= 0) {
                                this.selectedElements.splice(idx, 1);
                            } else {
                                this.selectedElements.push(clicked);
                            }
                        }
                        
                        this.isDragging = true;
                        this.dragStart = { x: worldPos.x, y: worldPos.y };
                        this.updatePropertiesPanel();
                    } else {
                        if (!e.ctrlKey) {
                            this.selectedElements = [];
                            this.hidePropertiesPanel();
                        }
                    }
                } else if (this.tool === 'pencil') {
                    // Iniciar dibujo libre
                    this.drawingPath = {
                        type: 'path',
                        id: Date.now() + Math.random(),
                        points: [{ x: worldPos.x, y: worldPos.y }],
                        strokeColor: '#e94560',
                        lineWidth: 3,
                        locked: false,
                        active: true,
                        connectionStatus: 'none',
                        fillColor: 'transparent',
                        name: '',
                        closed: false
                    };
                    
                    // Mostrar hint de cerrar path
                    document.getElementById('close-path-hint').classList.add('show');
                } else {
                    // Crear nuevo elemento
                    this.dragStart = { x: worldPos.x, y: worldPos.y };
                    this.tempElement = this.createElementAt(worldPos.x, worldPos.y);
                }
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                // Actualizar posici√≥n del cursor
                document.getElementById('cursor-pos').textContent = 
                    `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)}`;
                
                // Pan
                if (this.isPanning) {
                    this.camera.x += mouseX - this.dragStart.x;
                    this.camera.y += mouseY - this.dragStart.y;
                    this.dragStart = { x: mouseX, y: mouseY };
                    return;
                }

                // Modo visor: no hay hover/handles; cursor depende del tipo (deck permite "puntos de control").
                if (this.readOnly) {
                    if (this.viewerMode === 'deck') {
                        this.hoveredElement = this.getElementAt(worldPos.x, worldPos.y);
                        const isCp = this.hoveredElement && this.isControlPoint(this.hoveredElement);
                        this.canvas.style.cursor = isCp ? 'pointer' : 'grab';
                    } else {
                        this.canvas.style.cursor = 'grab';
                    }
                    return;
                }
                
                // Redimensionar elemento
                if (this.resizingElement) {
                    this.resizeElement(this.resizingElement, this.resizeHandle, worldPos);
                    return;
                }
                
                // Dibujo libre
                if (this.drawingPath) {
                    const firstPoint = this.drawingPath.points[0];
                    const distance = Math.sqrt(
                        Math.pow(worldPos.x - firstPoint.x, 2) + 
                        Math.pow(worldPos.y - firstPoint.y, 2)
                    );
                    
                    // Detectar si estamos cerca del punto inicial para cerrar
                    if (this.drawingPath.points.length > 3 && distance < this.autoClosePathDistance) {
                        this.drawingPath.nearStart = true;
                    } else {
                        this.drawingPath.nearStart = false;
                        this.drawingPath.points.push({ x: worldPos.x, y: worldPos.y });
                    }
                    return;
                }
                
                // Drag elementos
                if (this.isDragging && this.tool === 'select') {
                    const dx = worldPos.x - this.dragStart.x;
                    const dy = worldPos.y - this.dragStart.y;
                    
                    this.selectedElements.forEach(elem => {
                        if (!elem.locked) {
                            this.offsetElement(elem, dx, dy);
                        }
                    });
                    
                    this.dragStart = { x: worldPos.x, y: worldPos.y };
                }
                
                // Dibujar elemento temporal
                if (this.tempElement) {
                    if (this.tool === 'rectangle' || this.tool === 'circle') {
                        this.tempElement.width = worldPos.x - this.tempElement.x;
                        this.tempElement.height = worldPos.y - this.tempElement.y;
                    } else if (this.tool === 'line') {
                        this.tempElement.endX = worldPos.x;
                        this.tempElement.endY = worldPos.y;
                    }
                }
                
                // Hover
                this.hoveredElement = this.getElementAt(worldPos.x, worldPos.y);
                
                // Actualizar cursor si est√° sobre un handle
                const handleInfo = this.getResizeHandleAt(worldPos.x, worldPos.y);
                if (handleInfo) {
                    this.canvas.style.cursor = this.getResizeCursor(handleInfo.handle);
                } else if (this.tool === 'select' && !this.isDragging) {
                    this.canvas.style.cursor = this.hoveredElement ? 'move' : 'default';
                } else if (this.tool === 'pencil') {
                    this.canvas.style.cursor = 'crosshair';
                }
            }
            
            onMouseUp(e) {
                if (this.isPanning) {
                    this.isPanning = false;
                    document.getElementById('canvas-container').classList.remove('grabbing');
                }
                
                if (this.resizingElement) {
                    this.resizingElement = null;
                    this.resizeHandle = null;
                    this.saveHistory();
                }
                
                if (this.drawingPath) {
                    // Ocultar hint
                    document.getElementById('close-path-hint').classList.remove('show');
                    
                    // Solo agregar el path si tiene m√°s de 2 puntos
                    if (this.drawingPath.points.length > 2) {
                        // Si est√° cerca del inicio, cerrar la figura
                        if (this.drawingPath.nearStart) {
                            this.drawingPath.closed = true;
                            this.drawingPath.fillColor = '#0f3460'; // Darle color de relleno
                            // Convertir a tipo 'polygon' para que tenga propiedades editables
                            this.drawingPath.type = 'polygon';
                        }
                        
                        this.elements.push(this.drawingPath);
                        this.saveHistory();
                    }
                    this.drawingPath = null;
                }
                
                if (this.tempElement) {
                    this.elements.push(this.tempElement);
                    this.saveHistory();
                    this.tempElement = null;
                    this.setTool('select');
                }
                
                this.isDragging = false;
                this.canvas.style.cursor = this.readOnly ? 'grab' : 'default';
                this.updateStatusBar();
            }
            
            onClick(e) {
                if (this.readOnly) return;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                const element = this.getElementAt(worldPos.x, worldPos.y);
                
                // Toggle activaci√≥n con doble click
                if (element && e.detail === 2) {
                    element.active = !element.active;
                }
            }
            
            onWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                const newZoom = Math.max(0.1, Math.min(5, this.camera.zoom * zoomFactor));
                
                // Zoom hacia el cursor
                const worldBefore = this.screenToWorld(mouseX, mouseY);
                this.camera.zoom = newZoom;
                const worldAfter = this.screenToWorld(mouseX, mouseY);
                
                this.camera.x += (worldAfter.x - worldBefore.x) * this.camera.zoom;
                this.camera.y += (worldAfter.y - worldBefore.y) * this.camera.zoom;
                
                this.updateZoomIndicator();
            }
            
            onKeyDown(e) {
                if (this.readOnly) {
                    // En modo visor solo permitimos zoom (y evitamos crear/modificar elementos).
                    switch (e.key) {
                        case '+':
                        case '=':
                            e.preventDefault();
                            this.zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            this.zoomOut();
                            break;
                        case '0':
                            e.preventDefault();
                            this.resetZoom();
                            break;
                    }
                    return;
                }

                // No capturar atajos cuando el usuario est√° escribiendo en inputs/textarea/select
                // o cuando hay un modal abierto (para permitir pegar llaves/paths sin abrir herramientas).
                const target = e.target;
                const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
                const isFormField =
                    tag === 'input' ||
                    tag === 'textarea' ||
                    tag === 'select' ||
                    (target && target.isContentEditable);

                const anyModalOpen = Boolean(document.querySelector('.modal.show'));
                if (isFormField || anyModalOpen) {
                    // Permitir cerrar modales con Escape.
                    if (anyModalOpen && e.key === 'Escape') {
                        const publishModal = document.getElementById('publish-modal');
                        if (publishModal && publishModal.classList.contains('show')) this.hidePublishModal();

                        const libraryModal = document.getElementById('library-modal');
                        if (libraryModal && libraryModal.classList.contains('show')) this.hideLibraryModal();

                        const saveModal = document.getElementById('save-modal');
                        if (saveModal && saveModal.classList.contains('show')) this.hideSaveModal();

                        e.preventDefault();
                    }
                    return;
                }

                // Detectar espacio para pan
                if (e.code === 'Space' && !this.spacePressed) {
                    this.spacePressed = true;
                    document.getElementById('canvas-container').classList.add('pan-mode');
                    e.preventDefault();
                    return;
                }
                
                // Atajos de teclado
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key.toLowerCase()) {
                        case 'c':
                            e.preventDefault();
                            this.copyElements();
                            break;
                        case 'v':
                            e.preventDefault();
                            this.pasteElements();
                            break;
                        case 's':
                            e.preventDefault();
                            this.showSaveModal();
                            break;
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'g':
                            e.preventDefault();
                            this.groupElements();
                            break;
                        case 'l':
                            e.preventDefault();
                            this.toggleLock();
                            break;
                    }
                } else {
                    switch(e.key) {
                        case 'Delete':
                            this.deleteElements();
                            break;
                        case 'v':
                            this.setTool('select');
                            break;
                        case 'r':
                            this.setTool('rectangle');
                            break;
                        case 'c':
                            this.setTool('circle');
                            break;
                        case 'l':
                            this.setTool('line');
                            break;
                        case 'p':
                            this.setTool('pencil');
                            break;
                        case 'i':
                            this.insertImage();
                            break;
                        case '+':
                        case '=':
                            this.zoomIn();
                            break;
                        case '-':
                            this.zoomOut();
                            break;
                        case '0':
                            this.resetZoom();
                            break;
                    }
                }
            }
            
            onKeyUp(e) {
                if (this.readOnly) return;

                if (e.code === 'Space') {
                    this.spacePressed = false;
                    document.getElementById('canvas-container').classList.remove('pan-mode');
                }
            }
            
            // ==================== INSERCI√ìN DE IM√ÅGENES ====================
            
            insertImage() {
                document.getElementById('image-input').click();
            }
            
            loadImageFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Crear elemento de imagen en el canvas
                        const imageElement = {
                            type: 'image',
                            id: Date.now() + Math.random(),
                            x: -this.camera.x / this.camera.zoom,
                            y: -this.camera.y / this.camera.zoom,
                            width: img.width,
                            height: img.height,
                            originalWidth: img.width,
                            originalHeight: img.height,
                            imageSrc: event.target.result,
                            imageData: img,
                            locked: false,
                            active: true,
                            connectionStatus: 'none',
                            fillColor: 'transparent',
                            strokeColor: 'transparent',
                            name: file.name,
                            opacity: 1,
                            zIndex: this.elements.length // Al fondo inicialmente
                        };
                        
                        // Guardar en cache
                        this.loadedImages[imageElement.id] = img;
                        
                        this.elements.push(imageElement);
                        this.selectedElements = [imageElement];
                        this.saveHistory();
                        this.updatePropertiesPanel();
                        
                        // Ordenar elementos por zIndex
                        this.sortElementsByZIndex();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            }
            
            sortElementsByZIndex() {
                this.elements.sort((a, b) => {
                    const zA = a.zIndex !== undefined ? a.zIndex : this.elements.indexOf(a);
                    const zB = b.zIndex !== undefined ? b.zIndex : this.elements.indexOf(b);
                    return zA - zB;
                });
            }
            
            // ==================== GESTI√ìN DE CAPAS (Z-INDEX) ====================
            
            bringToFront() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const currentIndex = this.elements.indexOf(elem);
                    if (currentIndex < this.elements.length - 1) {
                        // Intercambiar con el siguiente
                        const nextElem = this.elements[currentIndex + 1];
                        this.elements[currentIndex] = nextElem;
                        this.elements[currentIndex + 1] = elem;
                    }
                });
                
                this.saveHistory();
            }
            
            sendToBack() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const currentIndex = this.elements.indexOf(elem);
                    if (currentIndex > 0) {
                        // Intercambiar con el anterior
                        const prevElem = this.elements[currentIndex - 1];
                        this.elements[currentIndex] = prevElem;
                        this.elements[currentIndex - 1] = elem;
                    }
                });
                
                this.saveHistory();
            }
            
            bringToFrontComplete() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const index = this.elements.indexOf(elem);
                    if (index >= 0) {
                        this.elements.splice(index, 1);
                        this.elements.push(elem);
                    }
                });
                
                this.saveHistory();
            }
            
            sendToBackComplete() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const index = this.elements.indexOf(elem);
                    if (index >= 0) {
                        this.elements.splice(index, 1);
                        this.elements.unshift(elem);
                    }
                });
                
                this.saveHistory();
            }
            
            duplicateSelected() {
                if (this.selectedElements.length === 0) return;
                
                const duplicates = [];
                this.selectedElements.forEach(elem => {
                    const duplicate = JSON.parse(JSON.stringify(elem));
                    const idMap = this.assignNewIdsRecursive(duplicate);
                    
                    // Copiar referencias de im√°genes (si aplica)
                    idMap.forEach((newId, oldId) => {
                        if (this.loadedImages[oldId]) {
                            this.loadedImages[newId] = this.loadedImages[oldId];
                        }
                    });
                    
                    // Mover ligeramente para evitar overlap
                    this.offsetElement(duplicate, 20, 20);
                    
                    duplicates.push(duplicate);
                });
                
                this.elements.push(...duplicates);
                this.selectedElements = duplicates;
                this.saveHistory();
                this.updatePropertiesPanel();
            }
            
            showContextMenu(x, y) {
                const menu = document.getElementById('context-menu');
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                menu.classList.add('show');
            }
            
            hideContextMenu() {
                document.getElementById('context-menu').classList.remove('show');
            }
            
            // ==================== REDIMENSIONAMIENTO ====================
            
            getResizeHandles(elem) {
                if (elem.type === 'group' || elem.locked) return [];
                
                const handles = [];
                const handleSize = 8 / this.camera.zoom;
                
                if (elem.type === 'rectangle' || elem.type === 'circle' || elem.type === 'image') {
                    // 8 handles: esquinas y puntos medios
                    handles.push(
                        { x: elem.x, y: elem.y, position: 'nw' },
                        { x: elem.x + elem.width / 2, y: elem.y, position: 'n' },
                        { x: elem.x + elem.width, y: elem.y, position: 'ne' },
                        { x: elem.x + elem.width, y: elem.y + elem.height / 2, position: 'e' },
                        { x: elem.x + elem.width, y: elem.y + elem.height, position: 'se' },
                        { x: elem.x + elem.width / 2, y: elem.y + elem.height, position: 's' },
                        { x: elem.x, y: elem.y + elem.height, position: 'sw' },
                        { x: elem.x, y: elem.y + elem.height / 2, position: 'w' }
                    );
                } else if (elem.type === 'line') {
                    // 2 handles: inicio y fin
                    handles.push(
                        { x: elem.x, y: elem.y, position: 'start' },
                        { x: elem.endX, y: elem.endY, position: 'end' }
                    );
                }
                
                return handles;
            }
            
            getResizeHandleAt(x, y) {
                for (const elem of this.selectedElements) {
                    const handles = this.getResizeHandles(elem);
                    const handleSize = 8 / this.camera.zoom;
                    
                    for (const handle of handles) {
                        const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                        if (dist < handleSize) {
                            return { element: elem, handle: handle.position };
                        }
                    }
                }
                return null;
            }
            
            resizeElement(elem, handle, worldPos) {
                if (elem.type === 'rectangle' || elem.type === 'circle') {
                    const originalRight = elem.x + elem.width;
                    const originalBottom = elem.y + elem.height;
                    
                    switch(handle) {
                        case 'nw':
                            elem.width = originalRight - worldPos.x;
                            elem.height = originalBottom - worldPos.y;
                            elem.x = worldPos.x;
                            elem.y = worldPos.y;
                            break;
                        case 'n':
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                        case 'ne':
                            elem.width = worldPos.x - elem.x;
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                        case 'e':
                            elem.width = worldPos.x - elem.x;
                            break;
                        case 'se':
                            elem.width = worldPos.x - elem.x;
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 's':
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 'sw':
                            elem.width = originalRight - worldPos.x;
                            elem.height = worldPos.y - elem.y;
                            elem.x = worldPos.x;
                            break;
                        case 'w':
                            elem.width = originalRight - worldPos.x;
                            elem.x = worldPos.x;
                            break;
                    }
                } else if (elem.type === 'image') {
                    // Redimensionar imagen manteniendo proporci√≥n
                    const originalRight = elem.x + elem.width;
                    const originalBottom = elem.y + elem.height;
                    const aspectRatio = elem.originalHeight / elem.originalWidth;
                    
                    switch(handle) {
                        case 'se':
                            const newWidth = worldPos.x - elem.x;
                            elem.width = newWidth;
                            elem.height = newWidth * aspectRatio;
                            break;
                        case 'nw':
                            const nwWidth = originalRight - worldPos.x;
                            elem.width = nwWidth;
                            elem.height = nwWidth * aspectRatio;
                            elem.x = worldPos.x;
                            elem.y = originalBottom - elem.height;
                            break;
                        case 'ne':
                            const neWidth = worldPos.x - elem.x;
                            elem.width = neWidth;
                            elem.height = neWidth * aspectRatio;
                            elem.y = originalBottom - elem.height;
                            break;
                        case 'sw':
                            const swWidth = originalRight - worldPos.x;
                            elem.width = swWidth;
                            elem.height = swWidth * aspectRatio;
                            elem.x = worldPos.x;
                            break;
                        // Para puntos medios, redimensionar libre
                        case 'e':
                            elem.width = worldPos.x - elem.x;
                            break;
                        case 'w':
                            elem.width = originalRight - worldPos.x;
                            elem.x = worldPos.x;
                            break;
                        case 's':
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 'n':
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                    }
                } else if (elem.type === 'line') {
                    if (handle === 'start') {
                        elem.x = worldPos.x;
                        elem.y = worldPos.y;
                    } else if (handle === 'end') {
                        elem.endX = worldPos.x;
                        elem.endY = worldPos.y;
                    }
                }
            }
            
            getResizeCursor(handle) {
                const cursors = {
                    'nw': 'nw-resize',
                    'n': 'n-resize',
                    'ne': 'ne-resize',
                    'e': 'e-resize',
                    'se': 'se-resize',
                    's': 's-resize',
                    'sw': 'sw-resize',
                    'w': 'w-resize',
                    'start': 'move',
                    'end': 'move'
                };
                return cursors[handle] || 'default';
            }
            
            // ==================== CREACI√ìN DE ELEMENTOS ====================
            
            createElementAt(x, y) {
                const baseElement = {
                    id: Date.now() + Math.random(),
                    x: x,
                    y: y,
                    name: '',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    locked: false,
                    active: true,
                    connectionStatus: 'none'
                };
                
                if (this.tool === 'rectangle') {
                    return {
                        ...baseElement,
                        type: 'rectangle',
                        width: 0,
                        height: 0
                    };
                } else if (this.tool === 'circle') {
                    return {
                        ...baseElement,
                        type: 'circle',
                        width: 0,
                        height: 0
                    };
                } else if (this.tool === 'line') {
                    return {
                        ...baseElement,
                        type: 'line',
                        endX: x,
                        endY: y,
                        animColor: '#4caf50',
                        flowDirection: 'right',
                        animOffset: 0,
                        controlPoints: [] // Para curvas editables
                    };
                }
            }
            
            getElementAt(x, y) {
                // Buscar de atr√°s hacia adelante (√∫ltimo dibujado primero)
                for (let i = this.elements.length - 1; i >= 0; i--) {
                    const elem = this.elements[i];
                    
                    if (elem.type === 'group' && typeof elem.x === 'number' && typeof elem.y === 'number' &&
                        typeof elem.width === 'number' && typeof elem.height === 'number') {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
                            return elem;
                        }
                    }

                    if (elem.type === 'image' || elem.type === 'rectangle') {
                        if (x >= elem.x && x <= elem.x + elem.width &&
                            y >= elem.y && y <= elem.y + elem.height) {
                            return elem;
                        }
                    } else if (elem.type === 'circle') {
                        const centerX = elem.x + elem.width / 2;
                        const centerY = elem.y + elem.height / 2;
                        const radiusX = Math.abs(elem.width / 2);
                        const radiusY = Math.abs(elem.height / 2);
                        
                        const normalized = Math.pow((x - centerX) / radiusX, 2) + 
                                         Math.pow((y - centerY) / radiusY, 2);
                        
                        if (normalized <= 1) {
                            return elem;
                        }
                    } else if (elem.type === 'line') {
                        // Detecci√≥n simple de l√≠nea (con margen)
                        const dist = this.distanceToLineSegment(x, y, elem.x, elem.y, elem.endX, elem.endY);
                        if (dist < 10 / this.camera.zoom) {
                            return elem;
                        }
                    } else if ((elem.type === 'path' || elem.type === 'polygon') && elem.points) {
                        // Para pol√≠gonos cerrados, verificar si el punto est√° dentro
                        if (elem.type === 'polygon' && elem.closed) {
                            if (this.pointInPolygon(x, y, elem.points)) {
                                return elem;
                            }
                        }
                        
                        // Detecci√≥n de path (verificar distancia a cada segmento)
                        for (let j = 0; j < elem.points.length - 1; j++) {
                            const p1 = elem.points[j];
                            const p2 = elem.points[j + 1];
                            const dist = this.distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (dist < 10 / this.camera.zoom) {
                                return elem;
                            }
                        }
                    }
                }
                return null;
            }
            
            pointInPolygon(x, y, points) {
                // Ray casting algorithm
                let inside = false;
                for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                    const xi = points[i].x, yi = points[i].y;
                    const xj = points[j].x, yj = points[j].y;
                    
                    const intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            
            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // ==================== RENDERIZADO ====================
            
            render() {
                // Limpiar canvas
                if (this.backgroundColor) {
                    this.ctx.fillStyle = this.backgroundColor;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo transparente (tipo sticker)
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Aplicar transformaci√≥n de c√°mara
                this.ctx.save();
                this.ctx.translate(this.camera.x, this.camera.y);
                this.ctx.scale(this.camera.zoom, this.camera.zoom);
                
                // Dibujar grid (opcional)
                if (this.showGrid) {
                    this.drawGrid();
                }
                
                // Dibujar elementos
                this.elements.forEach(elem => this.drawElement(elem));
                
                // Dibujar path temporal
                if (this.drawingPath) {
                    this.ctx.strokeStyle = this.drawingPath.strokeColor;
                    this.ctx.lineWidth = this.drawingPath.lineWidth / this.camera.zoom;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.drawingPath.points[0].x, this.drawingPath.points[0].y);
                    
                    for (let i = 1; i < this.drawingPath.points.length; i++) {
                        this.ctx.lineTo(this.drawingPath.points[i].x, this.drawingPath.points[i].y);
                    }
                    
                    this.ctx.stroke();
                    
                    // Dibujar punto inicial grande si estamos cerca para cerrar
                    if (this.drawingPath.nearStart) {
                        this.ctx.fillStyle = '#4caf50';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            this.drawingPath.points[0].x, 
                            this.drawingPath.points[0].y, 
                            10 / this.camera.zoom, 
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.fill();
                        
                        // Preview del pol√≠gono cerrado
                        this.ctx.globalAlpha = 0.3;
                        this.ctx.fillStyle = '#0f3460';
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.drawingPath.points[0].x, this.drawingPath.points[0].y);
                        for (let i = 1; i < this.drawingPath.points.length; i++) {
                            this.ctx.lineTo(this.drawingPath.points[i].x, this.drawingPath.points[i].y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;
                    } else {
                        // Punto inicial normal
                        this.ctx.fillStyle = '#e94560';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            this.drawingPath.points[0].x, 
                            this.drawingPath.points[0].y, 
                            6 / this.camera.zoom, 
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                }
                
                // Dibujar elemento temporal
                if (this.tempElement) {
                    this.ctx.globalAlpha = 0.5;
                    this.drawElement(this.tempElement);
                    this.ctx.globalAlpha = 1;
                }
                
                const showSelection = !this.readOnly || this.viewerMode === 'deck';
                if (showSelection) {
                    // Dibujar selecciones (en deck tambi√©n, para resaltar puntos de control)
                    this.selectedElements.forEach(elem => this.drawSelection(elem));
                }

                if (!this.readOnly) {
                    // Dibujar handles de redimensionamiento
                    this.selectedElements.forEach(elem => this.drawResizeHandles(elem));
                    
                    // Dibujar hover
                    if (this.hoveredElement && !this.selectedElements.includes(this.hoveredElement)) {
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2 / this.camera.zoom;
                        this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                        this.drawElementOutline(this.hoveredElement);
                        this.ctx.setLineDash([]);
                    }
                } else if (this.viewerMode === 'deck') {
                    // Hover suave solo para puntos de control (modo informativo)
                    if (this.hoveredElement &&
                        !this.selectedElements.includes(this.hoveredElement) &&
                        this.isControlPoint(this.hoveredElement)) {
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2 / this.camera.zoom;
                        this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                        this.drawElementOutline(this.hoveredElement);
                        this.ctx.setLineDash([]);
                    }
                }
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const gridSize = 50;
                const startX = Math.floor(-this.camera.x / this.camera.zoom / gridSize) * gridSize;
                const startY = Math.floor(-this.camera.y / this.camera.zoom / gridSize) * gridSize;
                const endX = startX + (this.canvas.width / this.camera.zoom) + gridSize;
                const endY = startY + (this.canvas.height / this.camera.zoom) + gridSize;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1 / this.camera.zoom;
                
                for (let x = startX; x < endX; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, startY);
                    this.ctx.lineTo(x, endY);
                    this.ctx.stroke();
                }
                
                for (let y = startY; y < endY; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, y);
                    this.ctx.lineTo(endX, y);
                    this.ctx.stroke();
                }
            }
            
            drawElement(elem) {
                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    // Dibujar elementos dentro del grupo
                    elem.elements.forEach(child => this.drawElement(child));

                    // Dibujar nombre si existe
                    if (elem.name) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = `${12 / this.camera.zoom}px Arial`;
                        const textX = elem.x || 0;
                        const textY = elem.y || 0;
                        this.ctx.fillText(elem.name, textX, textY - 10 / this.camera.zoom);
                    }

                    // Indicador de bloqueado
                    if (elem.locked) {
                        this.ctx.fillStyle = '#ff9800';
                        this.ctx.font = `${14 / this.camera.zoom}px Arial`;
                        const lockX = elem.x || 0;
                        const lockY = elem.y || 0;
                        this.ctx.fillText('üîí', lockX, lockY);
                    }
                    return;

                } else if (elem.type === 'image') {
                    // Dibujar imagen
                    let img = elem.imageData;
                    
                    // Si no tenemos la imagen en memoria, intentar cargarla
                    if (!img && this.loadedImages[elem.id]) {
                        img = this.loadedImages[elem.id];
                        elem.imageData = img;
                    } else if (!img && elem.imageSrc) {
                        // Cargar imagen desde base64
                        img = new Image();
                        img.onload = () => {
                            this.loadedImages[elem.id] = img;
                            elem.imageData = img;
                        };
                        img.src = elem.imageSrc;
                        return; // Esperar a que cargue
                    }
                    
                    if (img && img.complete) {
                        this.ctx.globalAlpha = elem.opacity || 1;
                        this.ctx.drawImage(img, elem.x, elem.y, elem.width, elem.height);
                        this.ctx.globalAlpha = 1;
                        
                        // Borde de selecci√≥n si est√° seleccionado
                        if (this.selectedElements.includes(elem)) {
                            this.ctx.strokeStyle = '#e94560';
                            this.ctx.lineWidth = 2 / this.camera.zoom;
                            this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
                        }
                    }
                    
                } else if (elem.type === 'rectangle') {
                    this.ctx.fillStyle = elem.fillColor;
                    this.ctx.strokeStyle = elem.strokeColor;
                    this.ctx.lineWidth = 2 / this.camera.zoom;
                    
                    this.ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
                    this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
                    
                    // Indicador de conexi√≥n
                    this.drawConnectionIndicator(elem, elem.x + elem.width, elem.y);
                    
                } else if (elem.type === 'circle') {
                    const centerX = elem.x + elem.width / 2;
                    const centerY = elem.y + elem.height / 2;
                    const radiusX = Math.abs(elem.width / 2);
                    const radiusY = Math.abs(elem.height / 2);
                    
                    this.ctx.fillStyle = elem.fillColor;
                    this.ctx.strokeStyle = elem.strokeColor;
                    this.ctx.lineWidth = 2 / this.camera.zoom;
                    
                    this.ctx.beginPath();
                    this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Indicador de conexi√≥n
                    this.drawConnectionIndicator(elem, centerX + radiusX, centerY);
                    
                } else if (elem.type === 'line') {
                    // Dibujar l√≠nea
                    this.ctx.strokeStyle = elem.strokeColor;
                    this.ctx.lineWidth = 3 / this.camera.zoom;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(elem.x, elem.y);
                    this.ctx.lineTo(elem.endX, elem.endY);
                    this.ctx.stroke();
                    
                    // Animaci√≥n de flujo
                    if (elem.active) {
                        this.drawFlowAnimation(elem);
                    }
                    
                    // Indicador de conexi√≥n
                    this.drawConnectionIndicator(elem, elem.endX, elem.endY);
                    
                } else if (elem.type === 'path' || elem.type === 'polygon') {
                    // Dibujar trazado libre o pol√≠gono cerrado
                    if (elem.points && elem.points.length > 1) {
                        this.ctx.strokeStyle = elem.strokeColor;
                        this.ctx.lineWidth = (elem.lineWidth || 3) / this.camera.zoom;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(elem.points[0].x, elem.points[0].y);
                        
                        for (let i = 1; i < elem.points.length; i++) {
                            this.ctx.lineTo(elem.points[i].x, elem.points[i].y);
                        }
                        
                        // Si es pol√≠gono cerrado, cerrar y rellenar
                        if (elem.type === 'polygon' || elem.closed) {
                            this.ctx.closePath();
                            
                            if (elem.fillColor && elem.fillColor !== 'transparent') {
                                this.ctx.fillStyle = elem.fillColor;
                                this.ctx.fill();
                            }
                        }
                        
                        this.ctx.stroke();
                    }
                }
                
                // Dibujar nombre si existe
                if (elem.name && elem.type !== 'image') {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = `${12 / this.camera.zoom}px Arial`;
                    const textX = elem.x || (elem.points ? elem.points[0].x : 0);
                    const textY = elem.y || (elem.points ? elem.points[0].y : 0);
                    this.ctx.fillText(elem.name, textX, textY - 10 / this.camera.zoom);
                }
                
                // Indicador de bloqueado
                if (elem.locked) {
                    this.ctx.fillStyle = '#ff9800';
                    this.ctx.font = `${14 / this.camera.zoom}px Arial`;
                    const lockX = elem.x || (elem.points ? elem.points[0].x : 0);
                    const lockY = elem.y || (elem.points ? elem.points[0].y : 0);
                    this.ctx.fillText('üîí', lockX, lockY);
                }
            }
            
            drawFlowAnimation(elem) {
                const dashLength = 20;
                const gapLength = 10;
                const particleSize = 4;
                
                // Actualizar offset de animaci√≥n
                if (elem.flowDirection === 'right') {
                    elem.animOffset = (elem.animOffset + 2) % (dashLength + gapLength);
                } else {
                    elem.animOffset = (elem.animOffset - 2) % (dashLength + gapLength);
                    if (elem.animOffset < 0) elem.animOffset += (dashLength + gapLength);
                }
                
                const dx = elem.endX - elem.x;
                const dy = elem.endY - elem.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return;
                
                const dirX = dx / length;
                const dirY = dy / length;
                
                // Dibujar part√≠culas animadas
                this.ctx.fillStyle = elem.animColor || '#4caf50';
                
                for (let i = elem.animOffset; i < length; i += dashLength + gapLength) {
                    const x = elem.x + dirX * i;
                    const y = elem.y + dirY * i;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, particleSize / this.camera.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            drawConnectionIndicator(elem, x, y) {
                const size = 12 / this.camera.zoom;
                
                let color;
                switch(elem.connectionStatus) {
                    case 'connected':
                        color = '#4caf50';
                        break;
                    case 'error':
                        color = '#f44336';
                        break;
                    default:
                        color = 'rgba(255, 255, 255, 0.3)';
                }
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                if (elem.connectionStatus === 'connected') {
                    this.ctx.shadowBlur = 10 / this.camera.zoom;
                    this.ctx.shadowColor = color;
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
            
            drawResizeHandles(elem) {
                if (elem.locked || elem.type === 'group') return;
                
                const handles = this.getResizeHandles(elem);
                const handleSize = 8 / this.camera.zoom;
                
                handles.forEach(handle => {
                    // Dibujar cuadrado blanco con borde rojo
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.strokeStyle = '#e94560';
                    this.ctx.lineWidth = 2 / this.camera.zoom;
                    
                    this.ctx.fillRect(
                        handle.x - handleSize / 2,
                        handle.y - handleSize / 2,
                        handleSize,
                        handleSize
                    );
                    
                    this.ctx.strokeRect(
                        handle.x - handleSize / 2,
                        handle.y - handleSize / 2,
                        handleSize,
                        handleSize
                    );
                });
            }
            
            drawSelection(elem) {
                this.ctx.strokeStyle = '#e94560';
                this.ctx.lineWidth = 2 / this.camera.zoom;
                this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                
                this.drawElementOutline(elem);
                
                this.ctx.setLineDash([]);
            }
            
            drawElementOutline(elem) {
                if (elem.type === 'rectangle' || elem.type === 'group') {
                    this.ctx.strokeRect(elem.x - 5 / this.camera.zoom, 
                                       elem.y - 5 / this.camera.zoom, 
                                       elem.width + 10 / this.camera.zoom, 
                                       elem.height + 10 / this.camera.zoom);
                } else if (elem.type === 'circle') {
                    const centerX = elem.x + elem.width / 2;
                    const centerY = elem.y + elem.height / 2;
                    const radiusX = Math.abs(elem.width / 2) + 5 / this.camera.zoom;
                    const radiusY = Math.abs(elem.height / 2) + 5 / this.camera.zoom;
                    
                    this.ctx.beginPath();
                    this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else if (elem.type === 'line') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(elem.x, elem.y);
                    this.ctx.lineTo(elem.endX, elem.endY);
                    this.ctx.stroke();
                } else if ((elem.type === 'path' || elem.type === 'polygon') && elem.points && elem.points.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(elem.points[0].x, elem.points[0].y);
                    for (let i = 1; i < elem.points.length; i++) {
                        this.ctx.lineTo(elem.points[i].x, elem.points[i].y);
                    }
                    this.ctx.stroke();
                }
            }
            
            // ==================== ANIMACI√ìN ====================
            
            startAnimationLoop() {
                const animate = () => {
                    this.render();
                    requestAnimationFrame(animate);
                };
                animate();
            }
            
            // ==================== ACCIONES ====================
            
            groupElements() {
                if (this.selectedElements.length < 2) {
                    alert('Selecciona al menos 2 elementos para agrupar');
                    return;
                }
                
                const group = {
                    id: Date.now() + Math.random(),
                    type: 'group',
                    elements: [...this.selectedElements],
                    locked: false,
                    active: true,
                    connectionStatus: 'none',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    name: 'Grupo'
                };
                
                // Calcular bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                group.elements.forEach(elem => {
                    if (!elem || typeof elem !== 'object') return;

                    if (elem.type === 'line') {
                        minX = Math.min(minX, elem.x, elem.endX);
                        minY = Math.min(minY, elem.y, elem.endY);
                        maxX = Math.max(maxX, elem.x, elem.endX);
                        maxY = Math.max(maxY, elem.y, elem.endY);
                        return;
                    }

                    if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                        elem.points.forEach(p => {
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                            maxX = Math.max(maxX, p.x);
                            maxY = Math.max(maxY, p.y);
                        });
                        return;
                    }

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        const bounds = this.getElementsBounds(elem.elements);
                        if (bounds) {
                            minX = Math.min(minX, bounds.minX);
                            minY = Math.min(minY, bounds.minY);
                            maxX = Math.max(maxX, bounds.maxX);
                            maxY = Math.max(maxY, bounds.maxY);
                        }
                        return;
                    }

                    if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
                        typeof elem.width === 'number' && typeof elem.height === 'number') {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        minX = Math.min(minX, x1);
                        minY = Math.min(minY, y1);
                        maxX = Math.max(maxX, x2);
                        maxY = Math.max(maxY, y2);
                    }
                });
                
                if (!Number.isFinite(minX)) {
                    minX = 0;
                    minY = 0;
                    maxX = 0;
                    maxY = 0;
                }

                group.x = minX;
                group.y = minY;
                group.width = maxX - minX;
                group.height = maxY - minY;
                
                // Remover elementos individuales
                this.selectedElements.forEach(elem => {
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) this.elements.splice(idx, 1);
                });
                
                this.elements.push(group);
                this.selectedElements = [group];
                this.saveHistory();
                this.updatePropertiesPanel();
            }
            
            ungroupElements() {
                const groups = this.selectedElements.filter(e => e.type === 'group');
                
                if (groups.length === 0) {
                    alert('Selecciona un grupo para desagrupar');
                    return;
                }
                
                groups.forEach(group => {
                    const idx = this.elements.indexOf(group);
                    if (idx >= 0) {
                        this.elements.splice(idx, 1);
                        this.elements.push(...group.elements);
                    }
                });
                
                this.selectedElements = [];
                this.saveHistory();
            }
            
            toggleLock() {
                this.selectedElements.forEach(elem => {
                    elem.locked = !elem.locked;
                });
            }
            
            copyElements() {
                if (this.selectedElements.length > 0) {
                    this.clipboard = JSON.parse(JSON.stringify(this.selectedElements));
                }
            }
            
            pasteElements() {
                if (!this.clipboard) return;
                
                const pasted = JSON.parse(JSON.stringify(this.clipboard));
                
                pasted.forEach(elem => {
                    const idMap = this.assignNewIdsRecursive(elem);
                    
                    // Copiar referencias de im√°genes (si aplica)
                    idMap.forEach((newId, oldId) => {
                        if (this.loadedImages[oldId]) {
                            this.loadedImages[newId] = this.loadedImages[oldId];
                        }
                    });
                    
                    this.offsetElement(elem, 20, 20);
                });
                
                this.elements.push(...pasted);
                this.selectedElements = pasted;
                this.saveHistory();
                this.updatePropertiesPanel();
            }
            
            deleteElements() {
                this.selectedElements.forEach(elem => {
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) this.elements.splice(idx, 1);
                });
                
                this.selectedElements = [];
                this.saveHistory();
                this.hidePropertiesPanel();
                this.updateStatusBar();
            }
            
            zoomIn() {
                this.camera.zoom = Math.min(5, this.camera.zoom * 1.2);
                this.updateZoomIndicator();
            }
            
            zoomOut() {
                this.camera.zoom = Math.max(0.1, this.camera.zoom / 1.2);
                this.updateZoomIndicator();
            }
            
            resetZoom() {
                this.camera.zoom = 1;
                this.camera.x = 0;
                this.camera.y = 0;
                this.updateZoomIndicator();
            }
            
            // ==================== HISTORIAL ====================
            
            saveHistory() {
                const state = JSON.stringify(this.elements);
                
                // Eliminar historia futura si estamos en medio
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                this.history.push(state);
                this.historyIndex++;
                
                // Limitar historial a 50 estados
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.elements = JSON.parse(this.history[this.historyIndex]);
                    this.selectedElements = [];
                }
            }
            
            // ==================== PERSISTENCIA ====================
            
            showSaveModal() {
                document.getElementById('save-modal').classList.add('show');
                document.getElementById('project-name').focus();
            }
            
            hideSaveModal() {
                document.getElementById('save-modal').classList.remove('show');
            }
            
            saveProject() {
                const name = document.getElementById('project-name').value || 'proyecto-sin-nombre';
                
                const projectData = {
                    name: name,
                    date: new Date().toISOString(),
                    elements: this.elements,
                    camera: this.camera
                };
                
                // Guardar en localStorage
                const projects = JSON.parse(localStorage.getItem('flow-diagrams') || '[]');
                projects.push(projectData);
                localStorage.setItem('flow-diagrams', JSON.stringify(projects));
                
                alert(`Proyecto "${name}" guardado exitosamente`);
                this.hideSaveModal();
                document.getElementById('project-name').value = '';
            }

            setupPublishKey() {
                const keyInput = document.getElementById('publish-key');
                if (!keyInput) return;

                const stored = localStorage.getItem('flow-diagram-publish-key') || '';
                keyInput.value = String(stored);

                keyInput.addEventListener('input', () => {
                    const v = String(keyInput.value || '');
                    if (v) {
                        localStorage.setItem('flow-diagram-publish-key', v);
                    } else {
                        localStorage.removeItem('flow-diagram-publish-key');
                    }
                });
            }

            getPublishKey() {
                const keyInput = document.getElementById('publish-key');
                const v = keyInput ? String(keyInput.value || '').trim() : '';
                if (v) return v;

                const stored = localStorage.getItem('flow-diagram-publish-key');
                return stored ? String(stored).trim() : '';
            }

            showPublishModal() {
                const modal = document.getElementById('publish-modal');
                const result = document.getElementById('publish-result');
                modal.classList.add('show');
                document.getElementById('publish-name').value = '';
                document.getElementById('publish-folder').value = '';
                const keyInput = document.getElementById('publish-key');
                if (keyInput) keyInput.value = localStorage.getItem('flow-diagram-publish-key') || '';
                document.getElementById('publish-name').focus();
                result.style.display = 'none';
                result.textContent = '';

                // Reset estado de publicaci√≥n desde archivo
                this.publishFileProject = null;
                this.publishFileName = '';
                this.updatePublishFileUI();
            }

            hidePublishModal() {
                document.getElementById('publish-modal').classList.remove('show');
            }

            updatePublishFileUI(messageOverride) {
                const status = document.getElementById('publish-file-status');
                const btnClear = document.getElementById('btn-clear-publish-file');
                if (!status || !btnClear) return;

                if (messageOverride) {
                    status.textContent = messageOverride;
                    btnClear.style.display = this.publishFileProject ? 'inline-flex' : 'none';
                    return;
                }

                if (this.publishFileProject) {
                    status.textContent = `Fuente: Archivo JSON (${this.publishFileName || 'seleccionado'})`;
                    btnClear.style.display = 'inline-flex';
                } else {
                    status.textContent = 'Fuente: Canvas actual';
                    btnClear.style.display = 'none';
                }
            }

            pickPublishFile() {
                document.getElementById('publish-file-input').click();
            }

            clearPublishFile() {
                this.publishFileProject = null;
                this.publishFileName = '';
                this.updatePublishFileUI();
            }

            onPublishFileSelected(e) {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                this.publishFileName = file.name || '';
                this.updatePublishFileUI('Leyendo archivo...');

                const reader = new FileReader();
                reader.onload = (event) => {
                    let data;
                    try {
                        data = JSON.parse(String(event.target.result || ''));
                    } catch (error) {
                        this.publishFileProject = null;
                        this.updatePublishFileUI('‚ùå JSON inv√°lido (no se pudo parsear).');
                        return;
                    }

                    if (!data || typeof data !== 'object' || !Array.isArray(data.elements)) {
                        this.publishFileProject = null;
                        this.updatePublishFileUI('‚ùå El JSON no parece un proyecto v√°lido (falta "elements").');
                        return;
                    }

                    this.publishFileProject = data;
                    this.updatePublishFileUI();

                    // Auto-sugerir nombre si el usuario a√∫n no puso uno.
                    const nameInput = document.getElementById('publish-name');
                    if (nameInput && !String(nameInput.value || '').trim()) {
                        const fromJson = (typeof data.name === 'string' && data.name.trim()) ? data.name.trim() : '';
                        const base = String(this.publishFileName || '').replace(/\.json$/i, '').trim();
                        nameInput.value = fromJson || base || '';
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }

            async publishSticker() {
                const result = document.getElementById('publish-result');
                result.style.display = 'block';
                result.textContent = 'Publicando...';

                const sourceElements = this.publishFileProject ? this.publishFileProject.elements : this.elements;
                const sourceCamera = this.publishFileProject
                    ? (this.publishFileProject.camera || { x: 0, y: 0, zoom: 1 })
                    : this.camera;

                // Este flujo es para "stickers" vectoriales: no permitir im√°genes (ni siquiera dentro de grupos).
                const hasImages = this.hasImagesInElements(sourceElements);

                if (hasImages) {
                    result.textContent = '‚ùå No se puede publicar como sticker: elimina las im√°genes (image/imageSrc) y vuelve a intentar.';
                    return;
                }

                const totalElements = this.countElementsRecursive(sourceElements);
                if (totalElements > 2000) {
                    result.textContent = `‚ùå Proyecto demasiado grande para publicar como sticker (m√°x 2000 elementos, actual: ${totalElements}).`;
                    return;
                }

                const nameInput = (document.getElementById('publish-name').value || '').trim();
                const fileNameBase = String(this.publishFileName || '').replace(/\.json$/i, '').trim();
                const defaultName =
                    (this.publishFileProject && typeof this.publishFileProject.name === 'string' && this.publishFileProject.name.trim())
                        ? this.publishFileProject.name.trim()
                        : '';
                const name = nameInput || defaultName || fileNameBase;
                const folder = (document.getElementById('publish-folder').value || '').trim();

                const payload = {
                    name,
                    folder,
                    elements: sourceElements,
                    camera: sourceCamera,
                    tags: []
                };

                const headers = { 'Content-Type': 'application/json' };
                const publishKey = this.getPublishKey();
                if (publishKey) headers['x-publish-key'] = publishKey;

                let response;
                let data;
                try {
                    response = await fetch('/api/publish', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload)
                    });
                    data = await response.json();
                } catch (error) {
                    result.textContent = `‚ùå Error de red al publicar: ${error}`;
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const details = data && data.details ? `\n${JSON.stringify(data.details)}` : '';
                    const err = (data && data.error) || response.status;
                    const hint = err === 'Unauthorized'
                        ? '\nTip: pega tu PUBLISH_KEY en "Llave de publicaci√≥n" y vuelve a intentar.'
                        : '';
                    result.textContent = `‚ùå Error al publicar: ${err}${details}${hint}`;
                    return;
                }

                // Intentar copiar el link de preview autom√°ticamente (si el navegador lo permite)
                try {
                    await navigator.clipboard.writeText(data.previewUrl);
                } catch {
                    // Ignorar: algunos navegadores/browsers bloquean clipboard.
                }

                const deckUrl = `${window.location.origin}/?mode=deck&id=${encodeURIComponent(data.id)}`;

                result.innerHTML = `
                    <div><strong>Preview (modo sticker):</strong></div>
                    <input type="text" readonly value="${data.previewUrl}">
                    <div style="margin-top: 10px;"><strong>Deck (modo l√°mina):</strong></div>
                    <input type="text" readonly value="${deckUrl}">
                    <div style="margin-top: 10px;"><strong>JSON:</strong></div>
                    <input type="text" readonly value="${data.jsonUrl}">
                    <div style="margin-top: 10px;">Tip: el link de preview se intent√≥ copiar al portapapeles.</div>
                `;
            }

            showLibraryModal() {
                const modal = document.getElementById('library-modal');
                modal.classList.add('show');

                const input = document.getElementById('library-prefix');
                input.value = this.libraryPrefix || '';
                input.focus();

                const uploadStatus = document.getElementById('library-upload-status');
                if (uploadStatus) uploadStatus.textContent = '';

                this.refreshLibrary();
            }

            hideLibraryModal() {
                document.getElementById('library-modal').classList.remove('show');
            }

            libraryNavigateUp() {
                const input = document.getElementById('library-prefix');
                const current = (input.value || '')
                    .trim()
                    .replace(/^\/+/, '')
                    .replace(/\/+$/, '');

                if (!current) return;

                const parts = current.split('/').filter(Boolean);
                parts.pop();
                input.value = parts.join('/');
                this.refreshLibrary();
            }

            async refreshLibrary() {
                const input = document.getElementById('library-prefix');
                const prefix = (input.value || '')
                    .trim()
                    .replace(/^\/+/, '')
                    .replace(/\/+$/, '');

                this.libraryPrefix = prefix;

                const status = document.getElementById('library-status');
                const listEl = document.getElementById('library-list');
                status.textContent = 'Cargando biblioteca...';
                listEl.innerHTML = '';

                let response;
                let data;
                try {
                    response = await fetch(`/api/library?prefix=${encodeURIComponent(prefix)}&mode=folded&limit=200`);
                    data = await response.json();
                } catch (error) {
                    status.textContent = `‚ùå Error de red: ${error}`;
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const err = (data && data.error) || response.status;
                    const hint = err === 'BlobListFailed'
                        ? ' (Tip: configura BLOB_READ_WRITE_TOKEN en Vercel: Storage ‚Üí Blob)'
                        : '';
                    status.textContent = `‚ùå Error al listar biblioteca: ${err}${hint}`;
                    return;
                }

                const currentPrefix = (data.prefix || '').replace(/\/+$/, '');
                status.textContent = currentPrefix ? `Carpeta: /${currentPrefix}` : 'Carpeta: /';

                const folders = Array.isArray(data.folders) ? data.folders.slice() : [];
                const blobs = Array.isArray(data.blobs) ? data.blobs.slice() : [];

                folders.sort((a, b) => String(a).localeCompare(String(b)));
                blobs.sort((a, b) => String(a.pathname).localeCompare(String(b.pathname)));

                const addRow = ({ name, type, path, id, actions }) => {
                    const row = document.createElement('div');
                    row.className = 'library-row';
                    row.dataset.type = type;
                    if (path) row.dataset.path = path;
                    if (id) row.dataset.id = id;

                    const nameEl = document.createElement('div');
                    nameEl.className = 'library-name';
                    nameEl.textContent = name;

                    const actionsEl = document.createElement('div');
                    actionsEl.className = 'library-actions';

                    actions.forEach(({ label, action }) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn small';
                        btn.textContent = label;
                        btn.dataset.action = action;
                        actionsEl.appendChild(btn);
                    });

                    row.appendChild(nameEl);
                    row.appendChild(actionsEl);
                    listEl.appendChild(row);
                };

                const displayName = (fullPath) => {
                    const p = String(fullPath || '').replace(/\/+$/, '');
                    if (!currentPrefix) return p;
                    if (p === currentPrefix) return p.split('/').pop() || p;
                    if (p.startsWith(currentPrefix + '/')) {
                        return p.slice(currentPrefix.length + 1) || p;
                    }
                    return p;
                };

                folders.forEach((folderPath) => {
                    const clean = String(folderPath || '').replace(/\/+$/, '');
                    if (!clean) return;
                    addRow({
                        name: `üìÅ ${displayName(clean)}`,
                        type: 'folder',
                        path: clean,
                        actions: [{ label: 'Abrir', action: 'open-folder' }],
                    });
                });

                blobs.forEach((blob) => {
                    if (!blob || !blob.pathname) return;
                    const stickerId = String(blob.pathname);
                    addRow({
                        name: `‚ú® ${displayName(stickerId)}`,
                        type: 'sticker',
                        id: stickerId,
                        actions: [
                            { label: 'Insertar', action: 'insert' },
                            { label: 'Ver', action: 'preview' },
                        ],
                    });
                });

                if (folders.length === 0 && blobs.length === 0) {
                    status.textContent += ' (vac√≠o)';
                }
            }

            onLibraryClick(e) {
                const btn = e.target.closest('button[data-action]');
                if (!btn) return;

                const row = btn.closest('.library-row');
                if (!row) return;

                const action = btn.dataset.action;
                const type = row.dataset.type;

                if (action === 'open-folder' && type === 'folder') {
                    const path = row.dataset.path || '';
                    document.getElementById('library-prefix').value = path;
                    this.refreshLibrary();
                    return;
                }

                if (action === 'preview' && type === 'sticker') {
                    const id = row.dataset.id;
                    if (!id) return;
                    const url = `${window.location.origin}/?mode=sticker&id=${encodeURIComponent(id)}`;
                    window.open(url, '_blank', 'noopener');
                    return;
                }

                if (action === 'insert' && type === 'sticker') {
                    const id = row.dataset.id;
                    if (!id) return;
                    this.insertStickerById(id);
                }
            }

            pickLibraryUploadFile() {
                const input = document.getElementById('library-upload-input');
                if (!input) return;
                input.value = '';
                input.click();
            }

            onLibraryUploadSelected(e) {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                const uploadStatus = document.getElementById('library-upload-status');
                if (uploadStatus) uploadStatus.textContent = 'Leyendo archivo...';

                const reader = new FileReader();
                reader.onload = async (event) => {
                    let data;
                    try {
                        data = JSON.parse(String(event.target.result || ''));
                    } catch (error) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå JSON inv√°lido (no se pudo parsear).';
                        return;
                    }

                    if (!data || typeof data !== 'object' || !Array.isArray(data.elements)) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå El JSON no parece un proyecto v√°lido (falta "elements").';
                        return;
                    }

                    const elements = data.elements || [];
                    const camera = (data.camera && typeof data.camera === 'object')
                        ? data.camera
                        : { x: 0, y: 0, zoom: 1 };

                    // Rechazar im√°genes: la biblioteca est√° pensada para stickers vectoriales/animados.
                    if (this.hasImagesInElements(elements)) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå Este JSON contiene im√°genes (image/imageSrc). Elimina im√°genes para publicarlo como sticker.';
                        return;
                    }

                    const total = this.countElementsRecursive(elements);
                    if (total > 2000) {
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Proyecto demasiado grande (m√°x 2000 elementos, actual: ${total}).`;
                        return;
                    }

                    const baseName = String(file.name || '').replace(/\.json$/i, '').trim();
                    const jsonName = (typeof data.name === 'string' && data.name.trim()) ? data.name.trim() : '';
                    const name = jsonName || baseName || 'sticker';

                    const prefixInput = document.getElementById('library-prefix');
                    const folder = (prefixInput ? String(prefixInput.value || '') : '')
                        .trim()
                        .replace(/^\/+/, '')
                        .replace(/\/+$/, '');

                    const payload = {
                        name,
                        folder,
                        elements,
                        camera,
                        tags: []
                    };

                    if (uploadStatus) uploadStatus.textContent = 'Subiendo a biblioteca...';

                    const headers = { 'Content-Type': 'application/json' };
                    const publishKey = this.getPublishKey();
                    if (publishKey) headers['x-publish-key'] = publishKey;

                    let response;
                    let resJson;
                    try {
                        response = await fetch('/api/publish', {
                            method: 'POST',
                            headers,
                            body: JSON.stringify(payload)
                        });
                        resJson = await response.json();
                    } catch (error) {
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Error de red al publicar: ${error}`;
                        return;
                    }

                    if (!response.ok || !resJson || !resJson.ok) {
                        const err = (resJson && resJson.error) || response.status;
                        const hint =
                            err === 'Unauthorized'
                                ? '\nTip: pega tu PUBLISH_KEY en "Publicar" (modal) y vuelve a intentar.'
                                : (err === 'BlobWriteFailed'
                                    ? '\nTip: configura BLOB_READ_WRITE_TOKEN en Vercel (Storage ‚Üí Blob).'
                                    : '');
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Error al publicar: ${err}${hint}`;
                        return;
                    }

                    const stickerUrl = String(resJson.previewUrl || '').replace('mode=preview', 'mode=sticker');
                    const deckUrl = `${window.location.origin}/?mode=deck&id=${encodeURIComponent(resJson.id)}`;

                    // Intentar copiar el link sticker autom√°ticamente.
                    try {
                        if (stickerUrl) await navigator.clipboard.writeText(stickerUrl);
                    } catch {
                        // Ignorar
                    }

                    if (uploadStatus) {
                        uploadStatus.textContent =
                            `‚úÖ Publicado\n` +
                            `ID: ${resJson.id}\n` +
                            `Sticker: ${stickerUrl || resJson.previewUrl}\n` +
                            `Deck: ${deckUrl}\n` +
                            `JSON: ${resJson.jsonUrl}`;
                    }

                    this.refreshLibrary();
                };
                reader.readAsText(file);

                // Permitir re-seleccionar el mismo archivo.
                e.target.value = '';
            }

            walkElements(elements, visitor) {
                const stack = Array.isArray(elements) ? elements.slice() : [];
                while (stack.length) {
                    const elem = stack.pop();
                    if (!elem || typeof elem !== 'object') continue;

                    // Si el visitor devuelve false, detenemos el recorrido.
                    if (visitor(elem) === false) return;

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        for (let i = elem.elements.length - 1; i >= 0; i--) {
                            stack.push(elem.elements[i]);
                        }
                    }
                }
            }

            hasImagesInElements(elements) {
                let found = false;
                this.walkElements(elements, (elem) => {
                    if (elem.type === 'image' || typeof elem.imageSrc === 'string' || elem.imageData != null) {
                        found = true;
                        return false;
                    }
                    return true;
                });
                return found;
            }

            countElementsRecursive(elements) {
                let count = 0;
                this.walkElements(elements, () => {
                    count++;
                    return true;
                });
                return count;
            }

            // ==================== DECK (L√ÅMINA) ====================

            refreshDeckUI() {
                if (this.viewerMode !== 'deck') return;
                this.updateDeckControlPointsUI();
                this.applyDeckStateFromUrl();
                this.updateDeckShareStatus();
            }

            isControlPoint(elem) {
                if (!elem || typeof elem !== 'object') return false;
                const meta = (elem.meta && typeof elem.meta === 'object') ? elem.meta : null;

                if (elem.type === 'controlPoint' || elem.type === 'poi') return true;
                if (elem.controlPoint === true || elem.isControlPoint === true) return true;
                if (meta && (meta.controlPoint === true || meta.isControlPoint === true)) return true;

                const slide = (meta && meta.slide && typeof meta.slide === 'object')
                    ? meta.slide
                    : (elem.slide && typeof elem.slide === 'object' ? elem.slide : null);

                if (slide) return true;

                if (typeof elem.slideImageUrl === 'string' || typeof elem.slideText === 'string' || typeof elem.slideTitle === 'string') {
                    return true;
                }
                if (meta && (typeof meta.slideImageUrl === 'string' || typeof meta.slideText === 'string' || typeof meta.slideTitle === 'string')) {
                    return true;
                }

                return false;
            }

            collectControlPoints() {
                const cps = [];
                const seen = new Set();

                this.walkElements(this.elements, (elem) => {
                    if (!this.isControlPoint(elem)) return true;
                    const id = elem.id != null ? String(elem.id) : '';
                    if (id && seen.has(id)) return true;
                    if (id) seen.add(id);
                    cps.push(elem);
                    return true;
                });

                cps.sort((a, b) => {
                    const aLabel = this.getControlPointLabel(a);
                    const bLabel = this.getControlPointLabel(b);
                    const byLabel = String(aLabel).localeCompare(String(bLabel));
                    if (byLabel !== 0) return byLabel;
                    return String(a && a.id).localeCompare(String(b && b.id));
                });

                return cps;
            }

            getControlPointLabel(elem) {
                if (!elem || typeof elem !== 'object') return 'Punto';
                const meta = (elem.meta && typeof elem.meta === 'object') ? elem.meta : null;

                const slide = (meta && meta.slide && typeof meta.slide === 'object')
                    ? meta.slide
                    : (elem.slide && typeof elem.slide === 'object' ? elem.slide : null);

                const label =
                    (slide && (slide.title || slide.name)) ||
                    (meta && meta.slideTitle) ||
                    elem.slideTitle ||
                    (meta && meta.title) ||
                    elem.title ||
                    elem.name ||
                    '';

                const trimmed = String(label || '').trim();
                if (trimmed) return trimmed;
                return elem.id != null ? `CP ${String(elem.id)}` : 'Punto';
            }

            updateDeckControlPointsUI() {
                if (this.viewerMode !== 'deck') return;

                const listEl = document.getElementById('deck-control-points');
                if (!listEl) return;

                const cps = this.collectControlPoints();
                listEl.innerHTML = '';

                if (cps.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.color = 'rgba(255, 255, 255, 0.75)';
                    empty.style.fontSize = '13px';
                    empty.textContent = '(No hay puntos de control en este dise√±o)';
                    listEl.appendChild(empty);
                    return;
                }

                cps.forEach((elem) => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'deck-cp';
                    btn.dataset.cpId = elem.id != null ? String(elem.id) : '';
                    if (this.activeControlPointId != null && String(this.activeControlPointId) === String(elem.id)) {
                        btn.classList.add('active');
                    }

                    const name = document.createElement('span');
                    name.className = 'deck-cp-name';
                    name.textContent = this.getControlPointLabel(elem);

                    const id = document.createElement('span');
                    id.className = 'deck-cp-id';
                    id.textContent = elem.id != null ? String(elem.id) : '';

                    btn.appendChild(name);
                    btn.appendChild(id);
                    listEl.appendChild(btn);
                });
            }

            onDeckControlPointClick(e) {
                if (this.viewerMode !== 'deck') return;

                const btn = e.target.closest('button[data-cp-id]');
                if (!btn) return;

                const id = btn.dataset.cpId;
                if (!id) return;

                const elem = this.findElementByIdRecursive(id);
                if (!elem) return;
                this.setActiveControlPoint(elem, { focus: true, updateUrl: true });
            }

            findElementByIdRecursive(id) {
                if (id == null) return null;
                const needle = String(id);
                let found = null;
                this.walkElements(this.elements, (elem) => {
                    if (elem && elem.id != null && String(elem.id) === needle) {
                        found = elem;
                        return false;
                    }
                    return true;
                });
                return found;
            }

            applyDeckStateFromUrl() {
                if (this.viewerMode !== 'deck') return;

                const urlParams = new URLSearchParams(window.location.search);
                const cp = urlParams.get('cp');

                if (cp) {
                    if (this.activeControlPointId != null && String(this.activeControlPointId) === String(cp)) {
                        return;
                    }
                    const elem = this.findElementByIdRecursive(cp);
                    if (elem) {
                        this.setActiveControlPoint(elem, { focus: false, updateUrl: false });
                        return;
                    }
                }

                if (this.activeControlPointId != null) {
                    const existing = this.findElementByIdRecursive(this.activeControlPointId);
                    if (existing) return;
                }

                const cps = this.collectControlPoints();
                if (cps.length > 0) {
                    this.setActiveControlPoint(cps[0], { focus: false, updateUrl: true });
                } else {
                    this.updateDeckSlideUI(null);
                }
            }

            setActiveControlPoint(elem, options) {
                if (!elem || typeof elem !== 'object') return;
                if (elem.id == null) return;

                const opts = options && typeof options === 'object' ? options : {};
                const focus = opts.focus !== false;
                const updateUrl = opts.updateUrl !== false;

                this.activeControlPointId = String(elem.id);
                this.selectedElements = [elem];

                if (focus) {
                    this.focusCameraOnElement(elem);
                }

                this.updateDeckSlideUI(elem);
                this.updateDeckControlPointsUI();

                if (updateUrl) {
                    this.updateDeckUrlParam('cp', String(elem.id));
                }

                this.updateDeckShareStatus();
            }

            updateDeckUrlParam(key, value) {
                try {
                    const url = new URL(window.location.href);
                    if (value == null || value === '') {
                        url.searchParams.delete(key);
                    } else {
                        url.searchParams.set(key, String(value));
                    }
                    history.replaceState(null, '', url.toString());
                } catch {
                    // Ignorar
                }
            }

            extractSlideInfo(elem) {
                const meta = (elem && elem.meta && typeof elem.meta === 'object') ? elem.meta : {};
                const slideObj = (meta.slide && typeof meta.slide === 'object')
                    ? meta.slide
                    : (elem && elem.slide && typeof elem.slide === 'object' ? elem.slide : {});

                const titleRaw =
                    slideObj.title ||
                    slideObj.name ||
                    meta.slideTitle ||
                    (elem && elem.slideTitle) ||
                    meta.title ||
                    (elem && elem.title) ||
                    (elem && elem.name) ||
                    '';

                const imageUrl =
                    slideObj.imageUrl ||
                    slideObj.image ||
                    meta.slideImageUrl ||
                    (elem && elem.slideImageUrl) ||
                    '';

                const textRaw =
                    slideObj.text ||
                    meta.slideText ||
                    (elem && elem.slideText) ||
                    meta.description ||
                    (elem && elem.description) ||
                    '';

                const title = String(titleRaw || '').trim() || 'Punto de control';
                const text = String(textRaw || '').trim();

                return { title, imageUrl: String(imageUrl || '').trim(), text };
            }

            updateDeckSlideUI(elem) {
                if (this.viewerMode !== 'deck') return;

                const titleEl = document.getElementById('deck-slide-title');
                const imgEl = document.getElementById('deck-slide-image');
                const textEl = document.getElementById('deck-slide-text');

                if (!titleEl || !imgEl || !textEl) return;

                if (!elem) {
                    titleEl.textContent = '';
                    textEl.textContent = '';
                    imgEl.removeAttribute('src');
                    imgEl.style.display = 'none';
                    return;
                }

                const info = this.extractSlideInfo(elem);
                titleEl.textContent = info.title;
                textEl.textContent = info.text || '';

                if (info.imageUrl) {
                    imgEl.src = info.imageUrl;
                    imgEl.style.display = 'block';
                } else {
                    imgEl.removeAttribute('src');
                    imgEl.style.display = 'none';
                }
            }

            getElementBounds(elem) {
                if (!elem || typeof elem !== 'object') return null;

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    if (Number.isFinite(elem.x) && Number.isFinite(elem.y) &&
                        Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        return { minX: x1, minY: y1, maxX: x2, maxY: y2 };
                    }
                    return this.getElementsBounds(elem.elements);
                }

                if (elem.type === 'line') {
                    const minX = Math.min(elem.x, elem.endX);
                    const minY = Math.min(elem.y, elem.endY);
                    const maxX = Math.max(elem.x, elem.endX);
                    const maxY = Math.max(elem.y, elem.endY);
                    return { minX, minY, maxX, maxY };
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
                    let minX = Infinity;
                    let minY = Infinity;
                    let maxX = -Infinity;
                    let maxY = -Infinity;
                    elem.points.forEach((p) => {
                        if (!p) return;
                        if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (Number.isFinite(elem.x) && Number.isFinite(elem.y)) {
                    if (Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        return { minX: x1, minY: y1, maxX: x2, maxY: y2 };
                    }
                    return { minX: elem.x, minY: elem.y, maxX: elem.x, maxY: elem.y };
                }

                return null;
            }

            focusCameraOnElement(elem) {
                const bounds = this.getElementBounds(elem);
                if (!bounds) return;

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;

                const screen = this.worldToScreen(centerX, centerY);
                this.camera.x += (this.canvas.width / 2) - screen.x;
                this.camera.y += (this.canvas.height / 2) - screen.y;
            }

            getDeckShareUrl() {
                try {
                    return window.location.href;
                } catch {
                    return '';
                }
            }

            updateDeckShareStatus() {
                if (this.viewerMode !== 'deck') return;
                const statusEl = document.getElementById('deck-share-status');
                if (!statusEl) return;

                const url = this.getDeckShareUrl();
                if (!url) {
                    statusEl.textContent = '‚ö†Ô∏è No se pudo generar link.';
                    return;
                }

                try {
                    const parsed = new URL(url);
                    const dataParam = parsed.searchParams.get('data') || '';
                    const hasId = Boolean(parsed.searchParams.get('id'));
                    if (!hasId && dataParam && dataParam.length > 1500) {
                        statusEl.textContent = 'Tip: publica el proyecto para obtener un link corto (usa "Publicar").';
                        return;
                    }
                } catch {
                    // ignorar
                }

                statusEl.textContent = `Link actual: ${url}`;
            }

            async copyDeckLink() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                const statusEl = document.getElementById('deck-share-status');
                if (!url) {
                    if (statusEl) statusEl.textContent = '‚ö†Ô∏è No hay link para copiar.';
                    return;
                }

                try {
                    await navigator.clipboard.writeText(url);
                    if (statusEl) statusEl.textContent = '‚úÖ Link copiado al portapapeles.';
                } catch {
                    if (statusEl) statusEl.textContent = `Copia manual: ${url}`;
                }
            }

            async shareDeckNative() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                if (!url) return;

                const titleEl = document.getElementById('deck-slide-title');
                const title = titleEl && titleEl.textContent ? titleEl.textContent : 'L√°mina';

                if (navigator.share) {
                    try {
                        await navigator.share({ title, text: title, url });
                        return;
                    } catch {
                        // si el usuario cancela, no hacemos nada
                        return;
                    }
                }

                await this.copyDeckLink();
            }

            shareDeckToWhatsApp() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                if (!url) return;

                const titleEl = document.getElementById('deck-slide-title');
                const title = titleEl && titleEl.textContent ? titleEl.textContent : 'L√°mina';
                const text = `${title}\n${url}`;
                const waUrl = `https://wa.me/?text=${encodeURIComponent(text)}`;
                window.open(waUrl, '_blank', 'noopener');
            }

            setupDeckResizer() {
                if (this._deckResizerSetup) return;
                this._deckResizerSetup = true;

                const handle = document.getElementById('deck-resize-handle');
                if (!handle) return;

                handle.addEventListener('pointerdown', (e) => {
                    if (this.viewerMode !== 'deck') return;
                    this._deckResizing = true;
                    try {
                        handle.setPointerCapture(e.pointerId);
                    } catch {
                        // Ignorar
                    }
                    e.preventDefault();
                });

                handle.addEventListener('pointermove', (e) => {
                    if (!this._deckResizing) return;
                    if (this.viewerMode !== 'deck') return;

                    if (this.deckLayout === 'vertical') {
                        const minH = 220;
                        const maxH = Math.floor(window.innerHeight * 0.8);
                        const newH = Math.max(minH, Math.min(maxH, Math.floor(window.innerHeight - e.clientY)));
                        localStorage.setItem('deck-panel-height', String(newH));
                    } else {
                        const minW = 280;
                        const maxW = Math.floor(window.innerWidth * 0.7);
                        const newW = Math.max(minW, Math.min(maxW, Math.floor(window.innerWidth - e.clientX)));
                        localStorage.setItem('deck-panel-width', String(newW));
                    }

                    this.applyDeckSizing();
                    this.resizeCanvas();
                });

                const stop = (e) => {
                    if (!this._deckResizing) return;
                    this._deckResizing = false;
                    try {
                        handle.releasePointerCapture(e.pointerId);
                    } catch {
                        // Ignorar
                    }
                };

                handle.addEventListener('pointerup', stop);
                handle.addEventListener('pointercancel', stop);
            }

            setDeckLayout(layout) {
                this.deckLayout = layout === 'vertical' ? 'vertical' : 'horizontal';
                document.body.classList.add('deck-mode');
                document.body.classList.toggle('deck-horizontal', this.deckLayout === 'horizontal');
                document.body.classList.toggle('deck-vertical', this.deckLayout === 'vertical');
            }

            applyDeckSizing() {
                if (this.viewerMode !== 'deck') return;

                const deckPanel = document.getElementById('deck-panel');
                const container = document.getElementById('canvas-container');
                if (!deckPanel || !container) return;

                container.style.position = 'fixed';
                container.style.right = 'auto';
                container.style.bottom = 'auto';
                container.style.background = 'transparent';

                if (this.deckLayout === 'vertical') {
                    const minH = 220;
                    const maxH = Math.floor(window.innerHeight * 0.8);
                    const stored = Number(localStorage.getItem('deck-panel-height') || '');
                    const desired = Number.isFinite(stored) && stored > 0 ? stored : 380;
                    const panelH = Math.max(minH, Math.min(maxH, Math.floor(desired)));

                    deckPanel.style.top = 'auto';
                    deckPanel.style.left = '0';
                    deckPanel.style.right = '0';
                    deckPanel.style.bottom = '0';
                    deckPanel.style.width = '100vw';
                    deckPanel.style.height = `${panelH}px`;

                    const availableH = Math.max(0, window.innerHeight - panelH);
                    const side = Math.max(240, Math.floor(Math.min(window.innerWidth, availableH)));
                    const left = Math.max(0, Math.floor((window.innerWidth - side) / 2));
                    const top = Math.max(0, Math.floor((availableH - side) / 2));

                    container.style.width = `${side}px`;
                    container.style.height = `${side}px`;
                    container.style.left = `${left}px`;
                    container.style.top = `${top}px`;
                } else {
                    const minW = 280;
                    const maxW = Math.floor(window.innerWidth * 0.7);
                    const stored = Number(localStorage.getItem('deck-panel-width') || '');
                    const desired = Number.isFinite(stored) && stored > 0 ? stored : 420;
                    const panelW = Math.max(minW, Math.min(maxW, Math.floor(desired)));

                    deckPanel.style.top = '0';
                    deckPanel.style.left = 'auto';
                    deckPanel.style.right = '0';
                    deckPanel.style.bottom = '0';
                    deckPanel.style.width = `${panelW}px`;
                    deckPanel.style.height = '100vh';

                    const availableW = Math.max(0, window.innerWidth - panelW);
                    const side = Math.max(240, Math.floor(Math.min(window.innerHeight, availableW)));
                    const top = Math.max(0, Math.floor((window.innerHeight - side) / 2));

                    container.style.width = `${side}px`;
                    container.style.height = `${side}px`;
                    container.style.left = '0';
                    container.style.top = `${top}px`;
                }
            }

            applyStickerMode() {
                // Ocultar deck
                const deckPanel = document.getElementById('deck-panel');
                if (deckPanel) deckPanel.classList.remove('show');
                document.body.classList.remove('deck-mode', 'deck-horizontal', 'deck-vertical');

                // Ocultar UI
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('properties-panel').style.display = 'none';
                document.getElementById('status-bar').style.display = 'none';
                document.getElementById('zoom-indicator').style.display = 'none';
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('close-path-hint').style.display = 'none';

                // Ajustar canvas al 100% de la pantalla
                const container = document.getElementById('canvas-container');
                container.style.top = '0';
                container.style.bottom = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.width = '';
                container.style.height = '';
                container.style.background = 'transparent';

                // Fondo transparente (tipo sticker)
                document.documentElement.style.background = 'transparent';
                document.body.style.background = 'transparent';

                // Deshabilitar interacciones de edici√≥n (solo navegaci√≥n)
                this.viewerMode = 'sticker';
                this.readOnly = true;
                this.tool = 'select';
                this.showGrid = false;
                this.backgroundColor = null;
                this.selectedElements = [];
                this.canvas.style.cursor = 'grab';

                // Recalcular tama√±o del canvas con el layout nuevo
                this.resizeCanvas();
            }

            applyDeckMode() {
                // Ocultar UI de edici√≥n
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('properties-panel').style.display = 'none';
                document.getElementById('status-bar').style.display = 'none';
                document.getElementById('zoom-indicator').style.display = 'none';
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('close-path-hint').style.display = 'none';

                // Mostrar panel deck
                const deckPanel = document.getElementById('deck-panel');
                if (deckPanel) deckPanel.classList.add('show');

                // Fondo transparente (widget)
                document.documentElement.style.background = 'transparent';
                document.body.style.background = 'transparent';

                this.viewerMode = 'deck';
                this.readOnly = true;
                this.tool = 'select';
                this.showGrid = false;
                this.backgroundColor = null;
                this.selectedElements = [];
                this.canvas.style.cursor = 'grab';

                // Layout horizontal/vertical (por query o responsive)
                const urlParams = new URLSearchParams(window.location.search);
                const rawLayout = String(urlParams.get('layout') || '').toLowerCase();
                const layout =
                    rawLayout === 'vertical' || rawLayout === 'v'
                        ? 'vertical'
                        : rawLayout === 'horizontal' || rawLayout === 'h'
                            ? 'horizontal'
                            : (window.innerWidth < 900 ? 'vertical' : 'horizontal');

                this.setDeckLayout(layout);
                this.applyDeckSizing();
                this.resizeCanvas();

                // UI info (lista + diapositiva + link)
                this.refreshDeckUI();

                console.log('üß© MODO DECK ACTIVADO: L√°mina informativa (sticker + panel)');
            }

            applyViewerModeFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const mode = urlParams.get('mode');

                if (mode === 'deck') {
                    this.applyDeckMode();
                    return;
                }

                if (mode === 'preview' || mode === 'sticker') {
                    this.applyStickerMode();
                }
            }

            flattenGroupElements(elements) {
                const out = [];
                (elements || []).forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;
                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        out.push(...this.flattenGroupElements(elem.elements));
                    } else {
                        out.push(elem);
                    }
                });
                return out;
            }

            getElementsBounds(elements) {
                let minX = Infinity;
                let minY = Infinity;
                let maxX = -Infinity;
                let maxY = -Infinity;

                const addPoint = (x, y) => {
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                };

                (elements || []).forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        const bounds = this.getElementsBounds(elem.elements);
                        if (bounds) {
                            addPoint(bounds.minX, bounds.minY);
                            addPoint(bounds.maxX, bounds.maxY);
                        } else if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
                                   typeof elem.width === 'number' && typeof elem.height === 'number') {
                            addPoint(elem.x, elem.y);
                            addPoint(elem.x + elem.width, elem.y + elem.height);
                        }
                        return;
                    }

                    if (elem.type === 'line') {
                        addPoint(elem.x, elem.y);
                        addPoint(elem.endX, elem.endY);
                        return;
                    }

                    if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                        elem.points.forEach((p) => addPoint(p.x, p.y));
                        return;
                    }

                    if (typeof elem.x === 'number' && typeof elem.y === 'number') {
                        if (typeof elem.width === 'number' && typeof elem.height === 'number') {
                            addPoint(elem.x, elem.y);
                            addPoint(elem.x + elem.width, elem.y + elem.height);
                        } else {
                            addPoint(elem.x, elem.y);
                        }
                    }
                });

                if (!Number.isFinite(minX)) return null;
                return { minX, minY, maxX, maxY };
            }

            offsetElement(elem, dx, dy) {
                if (!elem || typeof elem !== 'object') return;

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    if (typeof elem.x === 'number') elem.x += dx;
                    if (typeof elem.y === 'number') elem.y += dy;
                    elem.elements.forEach((child) => this.offsetElement(child, dx, dy));
                    return;
                }

                if (elem.type === 'line') {
                    elem.x += dx;
                    elem.y += dy;
                    elem.endX += dx;
                    elem.endY += dy;
                    return;
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                    elem.points.forEach((p) => {
                        p.x += dx;
                        p.y += dy;
                    });
                    return;
                }

                if (typeof elem.x === 'number') elem.x += dx;
                if (typeof elem.y === 'number') elem.y += dy;
            }

            assignNewIdsRecursive(elem, idMap) {
                const map = idMap || new Map();
                if (!elem || typeof elem !== 'object') return map;

                const oldId = elem.id;
                const newId = Date.now() + Math.random();
                elem.id = newId;
                if (oldId != null) map.set(oldId, newId);

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    elem.elements.forEach((child) => this.assignNewIdsRecursive(child, map));
                }

                return map;
            }

            async insertStickerById(id) {
                const status = document.getElementById('library-status');
                status.textContent = `Insertando: ${id}...`;

                let response;
                let project;
                try {
                    response = await fetch(`/api/project?id=${encodeURIComponent(id)}`);
                    project = await response.json();
                } catch (error) {
                    status.textContent = `‚ùå Error de red al cargar sticker: ${error}`;
                    return;
                }

                if (!response.ok) {
                    status.textContent = `‚ùå No se pudo cargar el sticker (${response.status})`;
                    return;
                }

                const rawElements = Array.isArray(project.elements) ? project.elements : [];
                const cloned = JSON.parse(JSON.stringify(rawElements));

                // Rechazar im√°genes para mantenerlo como "sticker" vectorial.
                if (this.hasImagesInElements(cloned)) {
                    status.textContent = '‚ùå Sticker contiene im√°genes (no soportado para inserci√≥n tipo sticker).';
                    return;
                }

                if (cloned.length === 0) {
                    status.textContent = '‚ö†Ô∏è Sticker vac√≠o';
                    return;
                }

                const groupName =
                    (project && typeof project.name === 'string' && project.name.trim())
                        ? project.name.trim()
                        : (String(id).split('/').filter(Boolean).pop() || String(id));

                const group = {
                    id: Date.now() + Math.random(),
                    type: 'group',
                    elements: cloned,
                    locked: false,
                    active: true,
                    connectionStatus: 'none',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    name: groupName,
                    stickerSourceId: id
                };

                // Renombrar IDs para evitar colisiones (incluye hijos).
                this.assignNewIdsRecursive(group);

                // Colocar el sticker centrado en el viewport actual.
                const bounds = this.getElementsBounds(group.elements);
                if (bounds) {
                    group.x = bounds.minX;
                    group.y = bounds.minY;
                    group.width = bounds.maxX - bounds.minX;
                    group.height = bounds.maxY - bounds.minY;

                    const centerStickerX = (bounds.minX + bounds.maxX) / 2;
                    const centerStickerY = (bounds.minY + bounds.maxY) / 2;
                    const centerView = this.screenToWorld(this.canvas.width / 2, this.canvas.height / 2);
                    const dx = centerView.x - centerStickerX;
                    const dy = centerView.y - centerStickerY;
                    this.offsetElement(group, dx, dy);
                } else {
                    group.x = 0;
                    group.y = 0;
                    group.width = 0;
                    group.height = 0;
                }

                this.elements.push(group);
                this.selectedElements = [group];
                this.saveHistory();
                this.updatePropertiesPanel();
                this.updateStatusBar();

                const innerCount = this.countElementsRecursive(group.elements);
                status.textContent = `‚úÖ Insertado: ${id} (1 grupo, ${innerCount} elementos)`;
            }
            
            loadProject() {
                // Activar el input de archivo para cargar JSON
                document.getElementById('file-input').click();
            }
            
            loadFromLocalStorage() {
                // Cargar √∫ltimo proyecto autom√°ticamente
                const projects = JSON.parse(localStorage.getItem('flow-diagrams') || '[]');
                if (projects.length > 0) {
                    const lastProject = projects[projects.length - 1];
                    this.elements = lastProject.elements || [];
                    this.camera = lastProject.camera || { x: 0, y: 0, zoom: 1 };
                }
                
                this.saveHistory();
                this.updateZoomIndicator();
                this.refreshDeckUI();
            }
            
            loadFromURLParameter() {
                const urlParams = new URLSearchParams(window.location.search);

                // 1) JSON embebido en par√°metro (?data=...)
                const jsonData = urlParams.get('data');
                if (jsonData) {
                    let data;
                    try {
                        // URLSearchParams ya decodifica, pero dejamos fallback por compatibilidad.
                        data = JSON.parse(jsonData);
                    } catch (error) {
                        try {
                            data = JSON.parse(decodeURIComponent(jsonData));
                        } catch (error2) {
                            console.error('‚ùå Error al parsear JSON desde URL:', error2);
                            return;
                        }
                    }
                    
                    this.elements = data.elements || [];
                    this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                    this.selectedElements = [];
                    this.saveHistory();
                    this.updateZoomIndicator();
                    this.refreshDeckUI();
                    console.log('‚úÖ Proyecto cargado desde par√°metro data');
                    return;
                }

                // 2) Cargar por ID publicado (?id=...)
                const projectId = urlParams.get('id');
                if (projectId) {
                    fetch(`/api/project?id=${encodeURIComponent(projectId)}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.elements = data.elements || [];
                            this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                            this.selectedElements = [];
                            this.saveHistory();
                            this.updateZoomIndicator();
                            this.refreshDeckUI();
                            console.log('‚úÖ Proyecto cargado desde ID');
                        })
                        .catch(error => {
                            console.error('‚ùå Error al cargar proyecto desde ID:', error);
                        });
                    return;
                }

                // 3) Cargar desde URL externa (?project=...)
                const projectUrl = urlParams.get('project');
                if (projectUrl) {
                    fetch(projectUrl)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.elements = data.elements || [];
                            this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                            this.selectedElements = [];
                            this.saveHistory();
                            this.updateZoomIndicator();
                            this.refreshDeckUI();
                            console.log('‚úÖ Proyecto cargado desde URL');
                        })
                        .catch(error => {
                            console.error('‚ùå Error al cargar proyecto desde URL:', error);
                        });
                    return;
                }

                // 4) Auto-carga opcional: buscar ./project.json (misma carpeta)
                fetch('./project.json', { cache: 'no-store' })
                    .then(async response => {
                        if (response.status === 404) return null;
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        // En despliegues tipo SPA, un rewrite puede devolver HTML con status 200.
                        // Si no parece JSON, lo ignoramos silenciosamente.
                        const contentType = (response.headers.get('content-type') || '').toLowerCase();
                        if (contentType.includes('text/html')) return null;

                        if (contentType.includes('json')) {
                            return response.json();
                        }

                        const text = await response.text();
                        try {
                            return JSON.parse(text);
                        } catch {
                            return null;
                        }
                    })
                    .then(data => {
                        if (!data) return;
                        this.elements = data.elements || [];
                        this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                        this.selectedElements = [];
                        this.saveHistory();
                        this.updateZoomIndicator();
                        this.refreshDeckUI();
                        console.log('‚úÖ Proyecto cargado desde project.json');
                    })
                    .catch(error => {
                        console.error('‚ùå Error al cargar project.json:', error);
                    });
            }
            
            newProject() {
                if (confirm('¬øCrear nuevo proyecto? Los cambios no guardados se perder√°n.')) {
                    this.elements = [];
                    this.selectedElements = [];
                    this.camera = { x: 0, y: 0, zoom: 1 };
                    this.history = [];
                    this.historyIndex = -1;
                    this.saveHistory();
                    this.updateZoomIndicator();
                }
            }
            
            exportProject() {
                const projectData = {
                    name: 'proyecto-exportado',
                    date: new Date().toISOString(),
                    elements: this.elements,
                    camera: this.camera
                };
                
                const blob = new Blob([JSON.stringify(projectData, null, 2)], 
                                     { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flow-diagram-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            importProject(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        this.elements = data.elements || [];
                        this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                        this.selectedElements = [];
                        this.saveHistory();
                        this.updateZoomIndicator();
                        this.refreshDeckUI();
                        alert('Proyecto importado exitosamente');
                    } catch (error) {
                        alert('Error al importar proyecto');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }
            
            // ==================== UI ====================
            
            updatePropertiesPanel() {
                if (this.selectedElements.length === 1) {
                    const elem = this.selectedElements[0];
                    
                    document.getElementById('prop-name').value = elem.name || '';
                    document.getElementById('prop-fill-color').value = elem.fillColor;
                    document.getElementById('prop-stroke-color').value = elem.strokeColor;
                    
                    if (elem.type === 'line') {
                        document.getElementById('prop-anim-color').value = elem.animColor || '#4caf50';
                        document.getElementById('prop-flow-direction').value = elem.flowDirection || 'right';
                    }
                    
                    document.getElementById('prop-connection-status').value = elem.connectionStatus || 'none';
                    document.getElementById('prop-active').value = elem.active ? 'true' : 'false';
                    
                    document.getElementById('properties-panel').classList.add('show');
                } else {
                    this.hidePropertiesPanel();
                }
            }
            
            hidePropertiesPanel() {
                document.getElementById('properties-panel').classList.remove('show');
            }
            
            updateSelectedProperties() {
                this.selectedElements.forEach(elem => {
                    elem.name = document.getElementById('prop-name').value;
                    elem.fillColor = document.getElementById('prop-fill-color').value;
                    elem.strokeColor = document.getElementById('prop-stroke-color').value;
                    elem.connectionStatus = document.getElementById('prop-connection-status').value;
                    elem.active = document.getElementById('prop-active').value === 'true';
                    
                    if (elem.type === 'line') {
                        elem.animColor = document.getElementById('prop-anim-color').value;
                        elem.flowDirection = document.getElementById('prop-flow-direction').value;
                    }
                });
            }
            
            updateZoomIndicator() {
                document.getElementById('zoom-indicator').textContent = 
                    `Zoom: ${Math.round(this.camera.zoom * 100)}%`;
            }
            
            updateStatusBar() {
                document.getElementById('status-text').textContent = 
                    `Listo | Elementos: ${this.elements.length} | Seleccionados: ${this.selectedElements.length}`;
            }
        }
        
        // ==================== INICIALIZAR SISTEMA ====================
        
        const system = new FlowDiagramSystem();
        
        console.log('üöÄ Sistema de Diagramas de Flujo v1.2.0 - FASE A Iniciado');
        console.log('üìö Arquitectura modular lista para expansi√≥n');
        console.log('');
        console.log('‚ú® NUEVAS CARACTER√çSTICAS v1.2.0 - FASE A:');
        console.log('   ‚úì Insertar im√°genes como capas base (PNG con transparencia)');
        console.log('   ‚úì Dibujar encima de im√°genes con todas las herramientas');
        console.log('   ‚úì Convertir trazos en pol√≠gonos cerrados (cierra autom√°tico)');
        console.log('   ‚úì Sistema de capas Z-index (Men√∫ contextual con bot√≥n derecho)');
        console.log('   ‚úì Traer al frente / Enviar atr√°s');
        console.log('   ‚úì Duplicar elementos con men√∫ contextual');
        console.log('');
        console.log('üé® DIBUJO CON L√ÅPIZ MEJORADO:');
        console.log('   - Dibuja con l√°piz (P)');
        console.log('   - Ac√©rcate al punto inicial para CERRAR la figura autom√°ticamente');
        console.log('   - Los pol√≠gonos cerrados se rellenan con color');
        console.log('   - Crea formas personalizadas trazando el contorno');
        console.log('');
        console.log('üñºÔ∏è TRABAJO CON IM√ÅGENES:');
        console.log('   - Click en "Imagen" o presiona I');
        console.log('   - Redimensiona manteniendo proporci√≥n');
        console.log('   - Dibuja ENCIMA de la imagen para crear diagramas');
        console.log('   - Soporta PNG, JPG, GIF, WEBP');
        console.log('');
        console.log('üóÇÔ∏è CONTROL DE CAPAS:');
        console.log('   - Bot√≥n derecho sobre elemento ‚Üí Men√∫ contextual');
        console.log('   - Traer al frente de todo / Enviar al fondo');
        console.log('   - Traer adelante / Enviar atr√°s (un nivel)');
        console.log('   - Duplicar / Eliminar');
        console.log('');
        console.log('‚å®Ô∏è ATAJOS DE TECLADO:');
        console.log('   V = Seleccionar | R = Rect√°ngulo | C = C√≠rculo | L = L√≠nea | P = L√°piz | I = Imagen');
        console.log('   Espacio = Pan (mover canvas) | Ctrl+C/V = Copiar/Pegar');
        console.log('   Doble clic en elemento = Activar/Desactivar animaci√≥n');
        console.log('   Bot√≥n derecho = Men√∫ contextual de capas');
        
        // ==================== MODOS IA (PREVIEW / STICKER / DECK) ====================

        function applyIAmodes() {
            system.applyViewerModeFromUrl();
        }

        // Ejecutar al cargar la p√°gina
        window.addEventListener('load', applyIAmodes);
    </script>
</body>
</html>
