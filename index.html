<!DOCTYPE html>
<html lang="es" data-build="2026-02-09-boot3">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Diagramas de Flujo Interactivos v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #eee;
        }

        :root {
            --viewer-studio-bg:
                radial-gradient(1200px 760px at 50% 38%, rgba(0, 212, 255, 0.16), transparent 58%),
                radial-gradient(980px 680px at 18% 78%, rgba(233, 69, 96, 0.10), transparent 62%),
                radial-gradient(980px 680px at 82% 78%, rgba(72, 234, 121, 0.10), transparent 62%),
                radial-gradient(1100px 720px at 50% 92%, rgba(0, 0, 0, 0.55), transparent 62%),
                linear-gradient(180deg, #050712 0%, #0f172a 55%, #050712 100%);
        }

        html.viewer-bg-transparent,
        body.viewer-bg-transparent {
            background: transparent !important;
        }

        body.viewer-bg-studio {
            background: var(--viewer-studio-bg) !important;
            position: relative;
            isolation: isolate;
            perspective: 1200px;
        }

        body.viewer-bg-studio #canvas-container {
            background: transparent;
        }

        /* Fondo con "profundidad" (2.5D): glow + grid suave (solo en modos visor) */
        body.viewer-bg-studio::before {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: -1;
            background:
                radial-gradient(900px 560px at 50% 18%, rgba(255, 255, 255, 0.08), transparent 62%),
                radial-gradient(1100px 700px at 50% 92%, rgba(0, 0, 0, 0.42), transparent 60%);
        }

        body.viewer-bg-studio::after {
            content: '';
            position: fixed;
            left: -35%;
            right: -35%;
            top: 42%;
            bottom: -40%;
            pointer-events: none;
            z-index: -1;
            background:
                repeating-linear-gradient(0deg, rgba(255, 255, 255, 0.065) 0 1px, transparent 1px 46px),
                repeating-linear-gradient(90deg, rgba(255, 255, 255, 0.055) 0 1px, transparent 1px 46px);
            background-position: 0 0, 0 0;
            transform-origin: center bottom;
            transform: perspective(980px) rotateX(66deg);
            opacity: 0.20;
            mask-image: radial-gradient(closest-side, rgba(0,0,0,1), transparent 70%);
            animation: viewerGridDrift 24s linear infinite;
        }

        @keyframes viewerGridDrift {
            0%   { background-position: 0 0, 0 0; }
            100% { background-position: 46px 46px, 46px 46px; }
        }
        /* ==================== BOOT SCREEN (DIAGNOSTICO) ==================== */
        #boot-screen {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(5, 7, 18, 0.92);
            z-index: 99998;
            padding: 16px;
        }

        #boot-screen.hidden {
            display: none;
        }

        #boot-screen .boot-card {
            width: min(560px, 92vw);
            background: rgba(22, 33, 62, 0.96);
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 16px;
            padding: 16px 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
        }

        #boot-screen .boot-title {
            font-weight: 800;
            color: #00d4ff;
            margin-bottom: 6px;
            font-size: 16px;
            letter-spacing: 0.2px;
        }

        #boot-screen .boot-sub {
            opacity: 0.88;
            font-size: 13px;
            line-height: 1.45;
        }

        #boot-screen .boot-code {
            margin-top: 10px;
            padding: 10px;
            border-radius: 10px;
            background: rgba(15, 52, 96, 0.55);
            color: rgba(255, 255, 255, 0.9);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            white-space: pre-wrap;
            user-select: text;
        }

        /* ==================== PANEL OBJETOS (CAPAS) ==================== */
        #layers-panel {
            position: fixed;
            left: 0;
            top: 52px;
            bottom: 24px;
            width: 236px;
            background: rgba(22, 33, 62, 0.98);
            color: #eee;
            border-right: 2px solid #0f3460;
            box-shadow: 8px 0 30px rgba(0, 0, 0, 0.35);
            z-index: 950;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        #layers-panel.show {
            display: flex;
        }

        body.layers-open #canvas-container {
            left: 236px;
        }

        .layers-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(15, 52, 96, 0.35);
        }

        .layers-title {
            font-weight: 700;
            letter-spacing: 0.3px;
            color: #00d4ff;
        }

        .layers-controls {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        #layers-filter {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(15, 52, 96, 0.65);
            color: #eee;
            font-size: 13px;
        }

        #layers-filter:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.22);
        }

        .layers-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        #layers-status {
            padding: 6px 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.75);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        #layers-list {
            flex: 1;
            overflow: auto;
            padding: 10px;
        }

        .layers-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            background: rgba(15, 52, 96, 0.22);
            cursor: pointer;
            user-select: none;
            margin-bottom: 8px;
        }

        .layers-item:hover {
            background: rgba(233, 69, 96, 0.12);
            border-color: rgba(233, 69, 96, 0.35);
        }

        .layers-item.selected {
            background: rgba(0, 212, 255, 0.10);
            border-color: rgba(0, 212, 255, 0.45);
        }

        .layers-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 0;
        }

        .layers-type {
            width: 18px;
            text-align: center;
            opacity: 0.95;
            flex: 0 0 auto;
        }

        .layers-name {
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }

        .layers-badges {
            display: flex;
            gap: 6px;
            font-size: 11px;
            opacity: 0.85;
        }

        .layers-actions {
            display: flex;
            gap: 6px;
            flex: 0 0 auto;
        }

        .layers-actions .btn.small {
            padding: 5px 8px;
            font-size: 11px;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 6px 8px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            z-index: 1000;
            border-bottom: 2px solid #0f3460;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .btn {
            padding: 6px 10px;
            background: #0f3460;
            border: none;
            border-radius: 5px;
            color: #eee;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .btn:hover {
            background: #e94560;
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.active {
            background: #e94560;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        #shape-type {
            padding: 6px 10px;
            background: #0f3460;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 5px;
            color: #eee;
            font-size: 12px;
            cursor: pointer;
            display: none;
            height: 30px;
        }

        body.shape-tool-active #shape-type {
            display: block;
        }

        #shape-type:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.22);
        }

        .separator {
            width: 2px;
            background: #0f3460;
            margin: 0 3px;
        }

        #canvas-container {
            position: fixed;
            top: 52px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: #1a1a2e;
            cursor: grab;
        }

        #canvas-container.grabbing {
            cursor: grabbing;
        }

	        #main-canvas {
	            position: absolute;
	            top: 0;
	            left: 0;
	            touch-action: none; /* Evita scroll/zoom nativo sobre el canvas (mobile) */
	        }

        #properties-panel {
            position: fixed;
            right: 10px;
            top: 62px;
            background: #16213e;
            padding: 10px;
            border-radius: 8px;
            min-width: 210px;
            max-height: 84vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
        }

        #properties-panel.show {
            display: block;
        }

        .property-group {
            margin-bottom: 15px;
        }

	        .property-group label {
	            display: block;
	            margin-bottom: 5px;
	            font-size: 12px;
	            color: #aaa;
	        }

		        .property-group input:not([type="checkbox"]):not([type="range"]),
		        .property-group textarea,
		        .property-group select {
		            width: 100%;
		            padding: 8px;
		            background: #0f3460;
		            border: 1px solid #1a1a2e;
		            border-radius: 5px;
		            color: #eee;
		            font-size: 14px;
		        }

		        .property-group textarea {
		            resize: vertical;
		            min-height: 78px;
		        }

		        .property-checkbox {
		            display: flex;
		            align-items: center;
		            gap: 8px;
		            margin-top: 6px;
		            color: #aaa;
		            font-size: 12px;
		        }

	        .property-checkbox input[type="checkbox"] {
	            width: auto;
	            padding: 0;
	            margin: 0;
	        }

	        .property-range-row {
	            display: flex;
	            align-items: center;
	            gap: 10px;
	        }

	        .property-range-row input[type="range"] {
	            flex: 1;
	            width: 100%;
	            padding: 0;
	            background: transparent;
	            border: none;
	        }

	        .property-range-row span {
	            width: 52px;
	            text-align: right;
	            font-size: 12px;
	            color: #aaa;
	        }

        .color-picker {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #zoom-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #16213e;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #16213e;
            padding: 8px 15px;
            font-size: 12px;
            border-top: 2px solid #0f3460;
            display: flex;
            justify-content: space-between;
        }

        #build-tag {
            opacity: 0.65;
            font-size: 11px;
            user-select: text;
        }

        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 5px;
        }

        .indicator-connected {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .indicator-error {
            background: #f44336;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .indicator-disconnected {
            background: rgba(255, 255, 255, 0.3);
        }

        input[type="file"] {
            display: none;
        }

        #publish-result {
            margin-top: 12px;
            padding: 10px;
            background: #0f3460;
            border-radius: 8px;
            font-size: 12px;
            word-break: break-all;
            display: none;
        }

        #publish-file-status {
            margin-top: 8px;
            font-size: 12px;
            color: #aaa;
        }

        #library-status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }

        #library-upload-status {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
        }

        #library-list {
            margin-top: 10px;
            background: #0f3460;
            border-radius: 8px;
            max-height: 55vh;
            overflow-y: auto;
        }

        .library-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .library-left {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
            flex: 1;
            margin-right: 10px;
        }

        .library-thumb {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.04);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            flex-shrink: 0;
            color: #cfe8ff;
            font-size: 14px;
        }

        .library-thumb iframe {
            width: 100%;
            height: 100%;
            border: 0;
            pointer-events: none;
            transform: scale(0.5);
            transform-origin: top left;
            width: 200%;
            height: 200%;
        }

        .library-row:last-child {
            border-bottom: none;
        }

        .library-name {
            flex: 1;
            font-size: 13px;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .library-actions {
            display: flex;
            gap: 8px;
        }

        .btn.small {
            padding: 4px 7px;
            font-size: 11px;
        }

        /* ==================== DECK MODE (L√ÅMINA) ==================== */

        #deck-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 440px;
            background: rgba(255, 255, 255, 0.92);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #0b1020;
            border-left: 1px solid rgba(15, 52, 96, 0.25);
            box-shadow: -18px 0 60px rgba(0,0,0,0.35);
            z-index: 1500;
            display: none;
            flex-direction: column;
            gap: 0;
            overflow: hidden;
            min-height: 0; /* Fix flex overflow: permite que .deck-content pueda scrollear */
        }

        #deck-panel.show {
            display: flex;
        }

        body.deck-mode #canvas-container {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 16px;
            box-shadow: 0 24px 80px rgba(0,0,0,0.55);
        }

        /* Columna intermedia (navegaci√≥n de diapositivas) para evitar el "hueco" en pantallas anchas. */

        #deck-nav {
            position: fixed;
            top: 0;
            right: 440px; /* JS recalcula seg√∫n el ancho del panel derecho */
            bottom: 0;
            width: 300px;
            background: rgba(255, 255, 255, 0.88);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #0b1020;
            border-left: 1px solid rgba(15, 52, 96, 0.18);
            box-shadow: -10px 0 40px rgba(0,0,0,0.22);
            z-index: 1490;
            display: none;
            flex-direction: column;
            overflow: hidden;
            min-height: 0; /* Fix flex overflow: permite que #deck-nav-list pueda scrollear */
        }

        #deck-nav.show {
            display: flex;
        }

        .deck-nav-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            padding: 14px 14px 10px 14px;
            border-bottom: 1px solid rgba(15, 52, 96, 0.12);
        }

        .deck-nav-title {
            font-size: 12px;
            font-weight: 900;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            color: rgba(15, 52, 96, 0.85);
        }

        #deck-nav-count {
            font-size: 12px;
            font-weight: 800;
            color: rgba(11, 16, 32, 0.7);
        }

        #deck-nav-list {
            flex: 1;
            overflow: auto;
            min-height: 0; /* Permite que la lista sea scrollable dentro del layout flex */
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            padding: 12px 14px 14px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

	        .deck-nav-item {
	            width: 100%;
	            display: grid;
	            grid-template-columns: 26px 1fr 56px;
	            gap: 10px;
	            align-items: start;
	            padding: 10px;
	            border-radius: 12px;
	            background: rgba(15, 52, 96, 0.06);
            border: 1px solid rgba(15, 52, 96, 0.14);
            cursor: pointer;
            text-align: left;
        }

        .deck-nav-item:hover {
            border-color: rgba(233, 69, 96, 0.55);
        }

        .deck-nav-item.active {
            border-color: #e94560;
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.14) inset;
        }

        .deck-nav-badge {
            width: 24px;
            height: 24px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #e94560;
            border: 1px solid rgba(233, 69, 96, 0.55);
            font-size: 12px;
            font-weight: 900;
            color: #fff;
            box-shadow: 0 8px 18px rgba(0,0,0,0.10);
        }

	        .deck-nav-main {
	            display: flex;
	            flex-direction: column;
	            gap: 6px;
	            min-width: 0;
	        }

	        .deck-nav-thumb {
	            width: 56px;
	            height: 42px;
	            border-radius: 10px;
	            background: rgba(15, 52, 96, 0.10);
	            border: 1px solid rgba(15, 52, 96, 0.12);
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            overflow: hidden;
	            color: rgba(11, 16, 32, 0.55);
	            font-weight: 900;
	            font-size: 14px;
	        }

	        .deck-nav-thumb img {
	            width: 100%;
	            height: 100%;
	            object-fit: cover;
	            display: block;
	        }

	        .deck-nav-name {
	            font-size: 13px;
	            font-weight: 800;
	            color: rgba(11, 16, 32, 0.94);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .deck-nav-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            font-size: 11px;
            color: rgba(15, 52, 96, 0.72);
        }

        .deck-nav-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(15, 52, 96, 0.12);
        }

        .deck-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 14px 14px 10px 14px;
            border-bottom: 1px solid rgba(15, 52, 96, 0.12);
        }

        .deck-title {
            font-size: 14px;
            font-weight: 800;
            color: #0b1020;
            letter-spacing: 0.4px;
        }

        .deck-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .deck-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px 14px;
            overflow: auto;
            min-height: 0; /* Importante: permite scroll dentro de flex + overflow:hidden */
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }

        .deck-block {
            background: rgba(255, 255, 255, 0.92);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(15, 52, 96, 0.12);
            box-shadow: 0 10px 24px rgba(0,0,0,0.06);
            overflow: hidden;
        }

        .deck-block h3 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: rgba(15, 52, 96, 0.85);
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        #deck-control-points {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .deck-cp {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(15, 52, 96, 0.06);
            border: 1px solid rgba(15, 52, 96, 0.15);
            color: #0b1020;
            cursor: pointer;
            text-align: left;
        }

        .deck-cp:hover {
            border-color: rgba(233, 69, 96, 0.6);
        }

        .deck-cp.active {
            border-color: #e94560;
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.18) inset;
        }

	        .deck-cp-name {
	            flex: 1;
	            font-size: 13px;
	            overflow: hidden;
	            text-overflow: ellipsis;
	            white-space: nowrap;
	        }

	        .deck-cp-badge {
	            width: 22px;
	            height: 22px;
	            border-radius: 999px;
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            background: #e94560;
	            border: 1px solid rgba(233, 69, 96, 0.55);
	            font-size: 12px;
	            font-weight: 800;
	            color: #fff;
	            box-shadow: 0 6px 14px rgba(0,0,0,0.08);
	        }

	        .deck-cp-id {
	            font-size: 11px;
	            color: rgba(15, 52, 96, 0.55);
	        }

	        .deck-slide-nav {
	            display: flex;
	            align-items: center;
	            justify-content: space-between;
	            gap: 8px;
	            margin-bottom: 10px;
	        }

	        #deck-slide-count {
	            font-size: 12px;
	            color: rgba(15, 52, 96, 0.7);
	            font-weight: 700;
	            letter-spacing: 0.2px;
	        }

	        #deck-slide-title {
	            font-size: 14px;
	            font-weight: 900;
	            margin-bottom: 6px;
	            color: #0b1020;
	        }

	        #deck-slide {
	            display: flex;
	            flex-direction: column;
	            gap: 10px;
	        }

	        .deck-slide-media {
	            border-radius: 12px;
	            background: rgba(15, 52, 96, 0.06);
	            border: 1px solid rgba(15, 52, 96, 0.12);
	            padding: 10px;
	        }

	        #deck-slide-image {
	            width: 100%;
	            max-height: 320px;
	            object-fit: contain;
	            border-radius: 10px;
	            background: rgba(255, 255, 255, 0.8);
	            display: none;
	        }

	        #deck-slide-iframe,
	        #deck-slide-video {
	            width: 100%;
	            border-radius: 10px;
	            background: rgba(15, 52, 96, 0.06);
	            display: none;
	        }

	        #deck-slide-iframe {
	            border: 0;
	            height: 240px;
	        }

	        #deck-slide-video {
	            max-height: 240px;
	        }

	        .deck-slide-info {
	            border-radius: 12px;
	            background: rgba(255, 255, 255, 0.92);
	            border: 1px solid rgba(15, 52, 96, 0.12);
	            padding: 10px 10px 12px 10px;
	        }

	        .deck-slide-info-title {
	            font-weight: 900;
	            letter-spacing: 0.6px;
	            color: rgba(15, 52, 96, 0.88);
	            text-transform: uppercase;
	            font-size: 12px;
	            margin-bottom: 8px;
	        }

	        #deck-slide-text {
	            font-size: 13px;
	            line-height: 1.45;
	            color: rgba(11, 16, 32, 0.92);
	            white-space: pre-wrap;
	        }

        .deck-share-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        #deck-share-status {
            margin-top: 10px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.75);
            word-break: break-word;
        }

        .deck-footer {
            padding: 12px 14px 14px 14px;
            background: rgba(22, 33, 62, 0.98);
            border-top: 1px solid rgba(15, 52, 96, 0.35);
            color: #eee;
        }

        #deck-resize-handle {
            position: absolute;
            background: transparent;
            z-index: 1;
            touch-action: none;
        }

        body.deck-horizontal #deck-resize-handle {
            left: -6px;
            top: 0;
            bottom: 0;
            width: 12px;
            cursor: ew-resize;
        }

        body.deck-vertical #deck-resize-handle {
            top: -6px;
            left: 0;
            right: 0;
            height: 12px;
            cursor: ns-resize;
        }

        #deck-resize-handle::before {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.14);
            border-radius: 2px;
        }

        body.deck-horizontal #deck-resize-handle::before {
            left: 5px;
            top: 20px;
            bottom: 20px;
            width: 2px;
        }

        body.deck-vertical #deck-resize-handle::before {
            top: 5px;
            left: 20px;
            right: 20px;
            height: 2px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #e94560;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 5px;
            color: #eee;
        }

        .modal-content textarea {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            border-radius: 5px;
            color: #eee;
            min-height: 140px;
            resize: vertical;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .modal-hint {
            font-size: 12px;
            opacity: 0.85;
            margin-top: -8px;
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Scrollbar personalizado */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #0f3460;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #e94560;
        }

        /* Handles de redimensionamiento */
        .resize-handle {
            fill: #e94560;
            stroke: #fff;
            stroke-width: 2;
            cursor: pointer;
        }

        .resize-handle:hover {
            fill: #ff6b81;
        }

        /* Cursor para pan */
        #canvas-container.pan-mode {
            cursor: move;
        }

        /* Men√∫ contextual */
        #context-menu {
            position: fixed;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 8px;
            padding: 4px 0;
            min-width: 156px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 3000;
            display: none;
        }

        #context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 8px 14px;
            cursor: pointer;
            color: #eee;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .context-menu-item:hover {
            background: #0f3460;
        }

        .context-menu-separator {
            height: 1px;
            background: #0f3460;
            margin: 5px 0;
        }

        /* Overlay para cerrar l√≠neas */
        .close-path-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(233, 69, 96, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 2500;
            display: none;
            animation: pulse 2s infinite;
        }

        .close-path-hint.show {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); }
        }
    </style>
</head>
<body>
    <!-- Boot screen: si se queda visible, el motor JS no arranco -->
    <div id="boot-screen">
        <div class="boot-card">
            <div class="boot-title">Cargando motor...</div>
            <div class="boot-sub">
                Si esto no desaparece en 2-3 segundos, hubo un error de JavaScript.
                Abre F12 &rarr; Console y copia el error.
                Tip: prueba en modo incognito para descartar extensiones.
            </div>
            <div class="boot-code" id="boot-build">build: 2026-02-09-boot3</div>
        </div>
    </div>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- Herramientas de dibujo -->
        <button class="btn" id="btn-select" title="Seleccionar (V)">
            <span>‚úã</span> Seleccionar
        </button>
        <button class="btn" id="btn-rectangle" title="Rect√°ngulo (R)">
            <span>‚ñ≠</span> Rect√°ngulo
        </button>
	        <button class="btn" id="btn-circle" title="C√≠rculo (C)">
	            <span>‚óè</span> C√≠rculo
	        </button>
	        <button class="btn" id="btn-poi" title="Punto de Informaci√≥n (K)">
	            <span>üìç</span> Punto
	        </button>
	        <button class="btn" id="btn-shape" title="Formas (T)">
	            <span>‚¨ü</span> Formas
	        </button>
	        <select id="shape-type" title="Tipo de forma">
	            <option value="triangle">Tri√°ngulo</option>
            <option value="trapezoid">Trapecio</option>
            <option value="diamond">Rombo</option>
            <option value="star5">Estrella (5)</option>
            <option value="star6">Estrella (6)</option>
            <option value="star7">Estrella (7)</option>
            <option value="star8">Estrella (8)</option>
            <option value="gear">Engrane</option>
        </select>
        <button class="btn" id="btn-line" title="L√≠nea Animada (L)">
            <span>‚Üí</span> L√≠nea
        </button>
        <button class="btn" id="btn-route" title="Ruta / V√≠a (U)">
            <span>üõ§Ô∏è</span> Ruta
        </button>
        <button class="btn" id="btn-metro" title="Mover Metro (N)">
            <span>üöá</span> Metro
        </button>
        <button class="btn" id="btn-person-male" title="Mover Hombre (H)">
            <span>üöπ</span> Hombre
        </button>
        <button class="btn" id="btn-person-female" title="Mover Mujer (J)">
            <span>üö∫</span> Mujer
        </button>
        <button class="btn" id="btn-portal-in" title="Portal Import (Q)">
            <span>üåÄ</span> Import
        </button>
        <button class="btn" id="btn-portal-out" title="Portal Export (W)">
            <span>üõ∏</span> Export
        </button>
        <button class="btn" id="btn-pencil" title="Dibujo Libre (P)">
            <span>‚úèÔ∏è</span> L√°piz
        </button>
        
	        <button class="btn" id="btn-image" title="Insertar Imagen (I)">
	            <span>üñºÔ∏è</span> Imagen
	        </button>
	        <button class="btn" id="btn-video" title="Insertar Video (M)">
	            <span>üéûÔ∏è</span> Video
	        </button>
	        <button class="btn" id="btn-bucket" title="Bote de pintura (B)">
	            <span>üé®</span> Pintar
	        </button>
	        
	        <div class="separator"></div>
        
        <!-- Acciones -->
        <button class="btn" id="btn-group" title="Agrupar (Ctrl+G)">
            <span>‚äû</span> Agrupar
        </button>
        <button class="btn" id="btn-ungroup" title="Desagrupar">
            <span>‚äü</span> Desagrupar
        </button>
        <button class="btn" id="btn-lock" title="Fijar/Desfijar (Ctrl+L)">
            <span>üîí</span> Fijar
        </button>
        <button class="btn" id="btn-bring-front" title="Traer al Frente">
            <span>‚¨ÜÔ∏è</span> Al Frente
        </button>
        <button class="btn" id="btn-send-back" title="Enviar Atr√°s">
            <span>‚¨áÔ∏è</span> Atr√°s
        </button>
        
        <div class="separator"></div>
        
        <!-- Edici√≥n -->
        <button class="btn" id="btn-copy" title="Copiar (Ctrl+C)">
            <span>üìã</span> Copiar
        </button>
        <button class="btn" id="btn-paste" title="Pegar (Ctrl+V)">
            <span>üìÑ</span> Pegar
        </button>
        <button class="btn" id="btn-delete" title="Eliminar (Del)">
            <span>üóëÔ∏è</span> Eliminar
        </button>
        <button class="btn" id="btn-undo" title="Deshacer (Ctrl+Z)">
            <span>‚Ü∂</span> Deshacer
        </button>
        
        <div class="separator"></div>
        
        <!-- Zoom -->
        <button class="btn" id="btn-zoom-in" title="Acercar (+)">
            <span>üîç+</span>
        </button>
        <button class="btn" id="btn-zoom-out" title="Alejar (-)">
            <span>üîç-</span>
        </button>
        <button class="btn" id="btn-zoom-reset" title="Restablecer Zoom (0)">
            <span>‚äô</span> 100%
        </button>
        
        <div class="separator"></div>
        
        <!-- Archivo -->
        <button class="btn" id="btn-new" title="Nuevo Proyecto">
            <span>üìÑ</span> Nuevo
        </button>
        <button class="btn" id="btn-save" title="Guardar (Ctrl+S)">
            <span>üíæ</span> Guardar
        </button>
        <button class="btn" id="btn-load" title="Cargar">
            <span>üìÇ</span> Cargar
        </button>
        <button class="btn" id="btn-export" title="Exportar JSON">
            <span>‚¨áÔ∏è</span> Exportar
        </button>
        <button class="btn" id="btn-publish" title="Publicar sticker vectorial (Link IA)">
            <span>üîó</span> Publicar Vector
        </button>
        <button class="btn" id="btn-publish-sticker" title="Publicar stiker en carpeta stickers">
            <span>‚ú®</span> Publicar Stiker
        </button>
        <button class="btn" id="btn-publish-project" title="Publicar proyecto (incluye im√°genes/fondo)">
            <span>üñºÔ∏è</span> Publicar Proyecto
        </button>
        <button class="btn" id="btn-library" title="Biblioteca de Stickers">
            <span>üìö</span> Biblioteca
        </button>
        <button class="btn" id="btn-grouped-library" title="Colecci√≥n de Agrupados">
            <span>üì¶</span> Agrupados
        </button>
        <button class="btn" id="btn-stkers-library" title="Colecci√≥n Stkers (animados)">
            <span>‚ú®</span> Stkers
        </button>
        <button class="btn" id="btn-layers" title="Objetos (O)">
            <span>‚â°</span> Objetos
        </button>
        
        <input type="file" id="file-input" accept=".json">
        <input type="file" id="publish-file-input" accept=".json">
        <input type="file" id="library-upload-input" accept=".json">
        <input type="file" id="image-input" accept="image/png,image/jpeg,image/jpg,image/gif,image/webp">
        <input type="file" id="video-input" accept="video/mp4,video/webm,video/ogg">
    </div>

    <!-- Panel Objetos (Capas) -->
    <div id="layers-panel">
        <div class="layers-header">
            <div class="layers-title">Objetos</div>
            <div class="layers-actions">
                <button class="btn small" id="btn-layers-hide" title="Ocultar panel">Ocultar</button>
            </div>
        </div>
        <div class="layers-controls">
            <input type="text" id="layers-filter" placeholder="Buscar (nombre/tipo)...">
            <div class="layers-buttons">
                <button class="btn small" id="btn-layers-unlock-all" title="Quitar fijado/bloqueo a todo">Desbloquear todo</button>
                <button class="btn small" id="btn-layers-delete-selected" title="Eliminar lo seleccionado">Eliminar selecci√≥n</button>
            </div>
        </div>
        <div id="layers-status"></div>
        <div id="layers-list"></div>
    </div>

	    <!-- Canvas Container -->
	    <div id="canvas-container">
	        <canvas id="main-canvas"></canvas>
	    </div>

	    <!-- Deck Nav (Modo L√°mina: columna intermedia para navegar diapositivas) -->
	    <div id="deck-nav">
	        <div class="deck-nav-header">
	            <div class="deck-nav-title">Diapositivas</div>
	            <div id="deck-nav-count"></div>
	        </div>
	        <div id="deck-nav-list"></div>
	    </div>

	    <!-- Deck Panel (Modo L√°mina / Informativo) -->
	    <div id="deck-panel">
	        <div id="deck-resize-handle" title="Redimensionar panel"></div>
	        <div class="deck-header">
            <div class="deck-title">L√°mina</div>
            <div class="deck-actions">
                <button class="btn small" id="btn-deck-copy-link" title="Copiar enlace de la l√°mina">Copiar Link</button>
            </div>
        </div>

        <div class="deck-content">
        <div class="deck-block">
            <h3>Puntos de Control</h3>
            <div id="deck-control-points"></div>
        </div>

	        <div class="deck-block">
	            <h3>Diapositiva</h3>
	            <div id="deck-slide">
	                <div class="deck-slide-nav">
	                    <button class="btn small" id="btn-deck-prev" title="Anterior">‚óÄ</button>
	                    <div id="deck-slide-count"></div>
	                    <button class="btn small" id="btn-deck-next" title="Siguiente">‚ñ∂</button>
		                </div>
		                <div id="deck-slide-title"></div>
		                <div class="deck-slide-media">
		                    <img id="deck-slide-image" alt="Diapositiva">
		                    <iframe id="deck-slide-iframe" title="Video" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
		                    <video id="deck-slide-video" controls></video>
		                </div>
		                <div class="deck-slide-info">
		                    <div class="deck-slide-info-title">+INFO</div>
		                    <div id="deck-slide-text"></div>
		                </div>
		            </div>
		        </div>
		        </div>

        <div class="deck-footer">
            <div class="deck-share-row">
                <button class="btn" id="btn-deck-whatsapp" title="Enviar link a WhatsApp">WhatsApp</button>
                <button class="btn" id="btn-deck-share" title="Compartir (si est√° disponible)">Compartir</button>
                <button class="btn" id="btn-deck-moltbook" title="Publicar link en Moltbook">Moltbook</button>
            </div>
            <div id="deck-share-status"></div>
        </div>
    </div>

    <!-- Panel de Propiedades -->
    <div id="properties-panel">
	        <h3>Propiedades</h3>
	        <div class="property-group">
	            <label>Nombre:</label>
	            <input type="text" id="prop-name" placeholder="Nombre del elemento">
	        </div>
	        <div class="property-group" id="prop-control-point-group" style="display:none;">
	            <label class="property-checkbox">
	                <input type="checkbox" id="prop-cp-enabled">
	                Punto de Informaci√≥n (L√°mina)
	            </label>
	            <div id="prop-cp-details" style="display:none; margin-top: 10px;">
	                <label>Orden (Diapositiva #):</label>
	                <input type="number" id="prop-cp-order" min="1" step="1" placeholder="1">
	                <label>T√≠tulo:</label>
	                <input type="text" id="prop-slide-title" placeholder="T√≠tulo de la diapositiva">
	                <label>Texto:</label>
	                <textarea id="prop-slide-text" placeholder="Texto descriptivo (se muestra en modo L√°mina)"></textarea>
	                <label>Imagen (URL):</label>
	                <input type="text" id="prop-slide-image-url" placeholder="https://... o /assets/...">
	                <label>Video (URL):</label>
	                <input type="text" id="prop-slide-video-url" placeholder="YouTube o mp4/webm">
	            </div>
	        </div>
			        <div class="property-group">
			            <label>Color de Relleno:</label>
			            <input type="color" id="prop-fill-color" class="color-picker" value="#0f3460">
			            <label class="property-checkbox">
			                <input type="checkbox" id="prop-fill-transparent"> Transparente
		            </label>
			            <label class="property-checkbox" style="margin-top: 8px;">
			                <input type="checkbox" id="prop-fill-gradient-enabled"> Degradado (lineal)
			            </label>
			            <div id="prop-fill-gradient-controls" style="display:none; margin-top: 8px;">
			                <label>Color A:</label>
			                <input type="color" id="prop-fill-gradient-a" class="color-picker" value="#00d4ff">
			                <label>Color B:</label>
			                <input type="color" id="prop-fill-gradient-b" class="color-picker" value="#e94560">
			                <label>√Ångulo:</label>
			                <input type="range" id="prop-fill-gradient-angle" min="0" max="360" step="15" value="90">
			                <div id="prop-fill-gradient-angle-value" style="margin-top: 4px; font-size: 12px; color: #aaa;">90¬∞</div>
			            </div>
			        </div>
	        <div class="property-group">
	            <label>Color de Borde:</label>
	            <input type="color" id="prop-stroke-color" class="color-picker" value="#e94560">
	            <label class="property-checkbox">
	                <input type="checkbox" id="prop-stroke-transparent"> Transparente
	            </label>
	        </div>
	        <div class="property-group" id="prop-line-width-group">
	            <label>Ancho de L√≠nea:</label>
	            <div class="property-range-row">
	                <input type="range" id="prop-line-width" min="1" max="20" value="3">
	                <span id="prop-line-width-value">3px</span>
	            </div>
	        </div>
	        <div class="property-group">
	            <label>Color de Animaci√≥n:</label>
	            <input type="color" id="prop-anim-color" class="color-picker" value="#4caf50">
	        </div>
        <div class="property-group">
            <label>Direcci√≥n de Flujo:</label>
            <select id="prop-flow-direction">
                <option value="right">Izquierda ‚Üí Derecha</option>
                <option value="left">Derecha ‚Üí Izquierda</option>
            </select>
        </div>
        <div class="property-group">
            <label>Estado de Conexi√≥n:</label>
            <select id="prop-connection-status">
                <option value="none">Sin Conectar</option>
                <option value="connected">Conectado ‚úì</option>
                <option value="error">Error ‚úó</option>
            </select>
        </div>
        <div class="property-group">
            <label>Activo:</label>
            <select id="prop-active">
                <option value="true">S√≠ - Animando</option>
                <option value="false">No - Pausado</option>
            </select>
        </div>
        <div class="property-group" id="prop-route-tools" style="display:none;">
            <label class="property-checkbox">
                <input type="checkbox" id="prop-is-route"> Usar como ruta de movimiento
            </label>
            <label>Tipo de ruta:</label>
            <select id="prop-route-curve">
                <option value="line">L√≠nea</option>
                <option value="circle">C√≠rculo</option>
                <option value="semi">Semic√≠rculo</option>
                <option value="quarter">Cuarto de c√≠rculo</option>
                <option value="custom">Arco libre (grados)</option>
            </select>
            <label>Lado del arco:</label>
            <select id="prop-route-arc-side">
                <option value="left">Izquierda</option>
                <option value="right">Derecha</option>
            </select>
            <div id="prop-route-arc-deg-wrap" style="display:none; margin-top:8px;">
                <label>Grados de arco:</label>
                <div class="property-range-row">
                    <input type="range" id="prop-route-arc-deg" min="5" max="355" value="120">
                    <span id="prop-route-arc-deg-value">120¬∞</span>
                </div>
            </div>
        </div>
        <div class="property-group" id="prop-mover-tools" style="display:none;">
            <label class="property-checkbox">
                <input type="checkbox" id="prop-follow-route"> Seguir ruta
            </label>
            <label>ID de Ruta:</label>
            <input type="text" id="prop-route-id" placeholder="ID de l√≠nea/path/pol√≠gono">
            <button class="btn small" id="btn-bind-nearest-route" title="Asigna la ruta m√°s cercana al mover">
                Vincular ruta cercana
            </button>
            <label>Velocidad:</label>
            <div class="property-range-row">
                <input type="range" id="prop-mover-speed" min="1" max="300" value="40">
                <span id="prop-mover-speed-value">40</span>
            </div>
            <label>Modo ruta:</label>
            <select id="prop-route-mode">
                <option value="loop">Loop (repite)</option>
                <option value="stop">Stop al final</option>
            </select>
            <label class="property-checkbox">
                <input type="checkbox" id="prop-auto-connect-route"> Auto-conectar ruta
            </label>
        </div>
        <div class="property-group" id="prop-mover-size-tools" style="display:none;">
            <label>Ancho actor:</label>
            <div class="property-range-row">
                <input type="range" id="prop-mover-width" min="12" max="320" value="44">
                <span id="prop-mover-width-value">44</span>
            </div>
            <label>Alto actor:</label>
            <div class="property-range-row">
                <input type="range" id="prop-mover-height" min="12" max="320" value="28">
                <span id="prop-mover-height-value">28</span>
            </div>
        </div>
        <div class="property-group" id="prop-portal-tools" style="display:none;">
            <label>Tipo Portal:</label>
            <select id="prop-portal-kind">
                <option value="import">Import</option>
                <option value="export">Export</option>
            </select>
            <label>Canal (key):</label>
            <input type="text" id="prop-portal-key" placeholder="A1">
        </div>
        <div class="property-group" id="prop-geometry-tools" style="display:none;">
            <label>Geometr√≠a:</label>
            <button class="btn small" id="btn-convert-to-polygon" title="Convierte la figura en pol√≠gono editable por puntos">
                Convertir a Pol√≠gono
            </button>
        </div>
    </div>

    <!-- Indicador de Zoom -->
    <div id="zoom-indicator">Zoom: 100%</div>

    <!-- Barra de Estado -->
    <div id="status-bar">
        <span id="status-text">Listo | Elementos: 0 | Seleccionados: 0</span>
        <span id="build-tag">build: 2026-02-09-boot3</span>
        <span id="cursor-pos">X: 0, Y: 0</span>
    </div>

	    <!-- Men√∫ Contextual -->
	    <div id="context-menu">
	        <div class="context-menu-item" id="ctx-bring-to-front">
	            <span>‚¨ÜÔ∏è</span> Traer al Frente de Todo
	        </div>
        <div class="context-menu-item" id="ctx-bring-forward">
            <span>‚Üë</span> Traer Adelante
        </div>
        <div class="context-menu-item" id="ctx-send-backward">
            <span>‚Üì</span> Enviar Atr√°s
        </div>
        <div class="context-menu-item" id="ctx-send-to-back">
            <span>‚¨áÔ∏è</span> Enviar al Fondo
        </div>
        <div class="context-menu-separator"></div>
	        <div class="context-menu-item" id="ctx-line-width">
	            <span>üìè</span> Cambiar Ancho...
	        </div>
	        <div class="context-menu-item" id="ctx-crop">
	            <span>‚úÇÔ∏è</span> Recortar...
	        </div>
            <div class="context-menu-item" id="ctx-auto-trim-image">
                <span>üß≠</span> Autoajustar PNG al contorno
            </div>
            <div class="context-menu-item" id="ctx-vectorize-image">
                <span>‚¨ü</span> Convertir PNG a vector
            </div>
	        <div class="context-menu-separator"></div>
	        <div class="context-menu-item" id="ctx-rotate-left">
	            <span>‚Ü∫</span> Girar -15¬∞
	        </div>
	        <div class="context-menu-item" id="ctx-rotate-right">
	            <span>‚Üª</span> Girar +15¬∞
	        </div>
	        <div class="context-menu-item" id="ctx-flip-x">
	            <span>‚áã</span> Voltear (Espejo)
	        </div>
	        <div class="context-menu-separator"></div>
	        <div class="context-menu-item" id="ctx-duplicate">
	            <span>üìã</span> Duplicar
	        </div>
        <div class="context-menu-item" id="ctx-save-grouped">
            <span>üì¶</span> Guardar agrupado en biblioteca
        </div>
	        <div class="context-menu-item" id="ctx-delete">
            <span>üóëÔ∏è</span> Eliminar
        </div>
    </div>

    <!-- Hint para cerrar paths -->
    <div class="close-path-hint" id="close-path-hint">
        Haz clic cerca del inicio para cerrar la figura ‚ú®
    </div>

    <!-- Modal para Guardar -->
    <div id="save-modal" class="modal">
        <div class="modal-content">
            <h2>Guardar Proyecto</h2>
            <input type="text" id="project-name" placeholder="Nombre del proyecto">
            <div class="modal-buttons">
                <button class="btn" id="btn-cancel-save">Cancelar</button>
                <button class="btn" id="btn-confirm-save">Guardar</button>
            </div>
        </div>
    </div>

    <!-- Modal para Publicar -->
    <div id="publish-modal" class="modal">
        <div class="modal-content">
            <h2>Publicar</h2>
            <div class="modal-hint" id="publish-mode-hint">
                <strong>Vector:</strong> sin im√°genes (ideal como sticker/biblioteca). <strong>Proyecto:</strong> permite im√°genes/fondo (sube assets).
            </div>
            <input type="text" id="publish-name" placeholder="Nombre (opcional)">
            <input type="text" id="publish-folder" placeholder="Carpeta (ej: metro/linea-1) (opcional)">
            <input type="password" id="publish-key" placeholder="Llave de publicaci√≥n (PUBLISH_KEY) (opcional)">
            <div class="modal-hint">Solo si configuraste <code>PUBLISH_KEY</code> en Vercel. Se guarda en este navegador.</div>
            <div class="modal-buttons" style="justify-content: flex-start;">
                <button class="btn small" id="btn-pick-publish-file" title="Publicar desde un archivo JSON">Subir JSON‚Ä¶</button>
                <button class="btn small" id="btn-clear-publish-file" title="Volver a publicar el canvas actual" style="display:none;">Usar Canvas</button>
                <button class="btn small" id="btn-toggle-paste-json" title="Pegar JSON (desde chat/IA)">Pegar JSON‚Ä¶</button>
            </div>
            <div id="publish-file-status"></div>
            <div id="publish-paste-box" style="display:none; margin-top: 10px;">
                <textarea id="publish-json-text" placeholder="Pega aqu√≠ el JSON del sticker (IA-friendly tambi√©n funciona)."></textarea>
                <div class="modal-buttons" style="justify-content: flex-start;">
                    <button class="btn small" id="btn-use-pasted-json">Usar JSON pegado</button>
                    <button class="btn small" id="btn-clear-pasted-json">Limpiar</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn" id="btn-cancel-publish">Cancelar</button>
                <button class="btn" id="btn-confirm-publish">Publicar Vector</button>
                <button class="btn" id="btn-confirm-publish-project">Publicar Proyecto</button>
            </div>
            <div id="publish-result"></div>
        </div>
    </div>

    <!-- Modal Biblioteca -->
    <div id="library-modal" class="modal">
        <div class="modal-content">
            <h2>Biblioteca</h2>
            <div class="modal-buttons" style="justify-content:flex-start;">
                <button class="btn small" id="btn-library-mode-library">Biblioteca</button>
                <button class="btn small" id="btn-library-mode-grouped">Agrupados</button>
                <button class="btn small" id="btn-library-mode-stkers">Stkers</button>
            </div>
            <input type="text" id="library-prefix" placeholder="Carpeta (ej: metro/linea-1) (vac√≠o = ra√≠z)">
            <div class="modal-buttons">
                <button class="btn" id="btn-library-up">Arriba</button>
                <button class="btn" id="btn-library-refresh">Actualizar</button>
                <button class="btn" id="btn-library-upload" title="Subir un JSON a esta carpeta">Subir nuevo archivo</button>
                <button class="btn" id="btn-library-close">Cerrar</button>
            </div>
            <div id="library-status"></div>
            <div id="library-upload-status"></div>
            <div id="library-list"></div>
        </div>
    </div>

    <script>
        // ==================== SISTEMA MODULAR ====================
        // Arquitectura base que permite agregar m√≥dulos sin romper el n√∫cleo

        // ==================== HARDENING / DIAGNOSTICO ====================
        // Evita que un fallo de localStorage o un JSON corrupto "mate" toda la UI.

        function safeLocalStorageGet(key, fallback = null) {
            try {
                const v = localStorage.getItem(String(key));
                return v === null ? fallback : v;
            } catch {
                return fallback;
            }
        }

        function safeLocalStorageSet(key, value) {
            try {
                localStorage.setItem(String(key), String(value));
                return true;
            } catch {
                return false;
            }
        }

        function safeLocalStorageRemove(key) {
            try {
                localStorage.removeItem(String(key));
                return true;
            } catch {
                return false;
            }
        }

        function safeLocalStorageGetJSON(key, fallback) {
            const raw = safeLocalStorageGet(key, null);
            if (raw === null || raw === undefined || raw === '') return fallback;
            try {
                return JSON.parse(raw);
            } catch {
                return fallback;
            }
        }

        function safeLocalStorageSetJSON(key, value) {
            try {
                return safeLocalStorageSet(key, JSON.stringify(value));
            } catch {
                return false;
            }
        }

        function setBuildLabelsFromHtmlAttr() {
            const build = (document.documentElement && document.documentElement.getAttribute('data-build')) || '';
            const bootEl = document.getElementById('boot-build');
            if (bootEl && build) bootEl.textContent = `build: ${build}`;
            const tagEl = document.getElementById('build-tag');
            if (tagEl && build) tagEl.textContent = `build: ${build}`;
        }

        function hideBootScreen() {
            const el = document.getElementById('boot-screen');
            if (el) el.classList.add('hidden');
        }

        function installGlobalErrorOverlay() {
            if (window.__flowGlobalErrorOverlayInstalled) return;
            window.__flowGlobalErrorOverlayInstalled = true;

            const ensureOverlay = () => {
                let root = document.getElementById('fatal-error-overlay');
                if (root) return root;

                root = document.createElement('div');
                root.id = 'fatal-error-overlay';
                root.style.cssText =
                    'position:fixed;left:0;right:0;bottom:0;max-height:45vh;overflow:auto;z-index:99999;' +
                    'background:rgba(0,0,0,0.92);color:#eee;border-top:2px solid #e94560;' +
                    'padding:12px;font:12px/1.4 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;' +
                    'display:none;';

                root.innerHTML = `
                    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
                        <strong style="color:#e94560">Error</strong>
                        <span id="fatal-error-context" style="opacity:0.8"></span>
                        <button id="fatal-error-copy" style="padding:6px 10px;border:0;border-radius:6px;background:#0f3460;color:#eee;cursor:pointer">Copiar</button>
                        <button id="fatal-error-clear" style="padding:6px 10px;border:0;border-radius:6px;background:#0f3460;color:#eee;cursor:pointer">Limpiar storage</button>
                        <button id="fatal-error-hide" style="padding:6px 10px;border:0;border-radius:6px;background:#0f3460;color:#eee;cursor:pointer">Cerrar</button>
                    </div>
                    <pre id="fatal-error-text" style="white-space:pre-wrap;margin:0"></pre>
                `;

                const parent = document.body || document.documentElement;
                parent.appendChild(root);

                const hideBtn = root.querySelector('#fatal-error-hide');
                if (hideBtn) {
                    hideBtn.addEventListener('click', () => {
                        root.style.display = 'none';
                    });
                }

                const copyBtn = root.querySelector('#fatal-error-copy');
                if (copyBtn) {
                    copyBtn.addEventListener('click', async () => {
                        const pre = root.querySelector('#fatal-error-text');
                        const txt = pre ? String(pre.textContent || '') : '';
                        try {
                            await navigator.clipboard.writeText(txt);
                        } catch {
                            const ta = document.createElement('textarea');
                            ta.value = txt;
                            ta.style.position = 'fixed';
                            ta.style.left = '-9999px';
                            (document.body || document.documentElement).appendChild(ta);
                            ta.select();
                            try {
                                document.execCommand('copy');
                            } catch {
                                // Ignorar
                            }
                            ta.remove();
                        }
                    });
                }

                const clearBtn = root.querySelector('#fatal-error-clear');
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => {
                        const ok = confirm('Esto borra proyectos y settings guardados localmente en este navegador. ¬øContinuar?');
                        if (!ok) return;

                        [
                            'flow-diagrams',
                            'flow-diagram-shape-type',
                            'flow-diagram-layers-open',
                            'flow-diagram-publish-key',
                            'deck-panel-width',
                            'deck-panel-height'
                        ].forEach((k) => safeLocalStorageRemove(k));

                        alert('Storage limpiado. Recarga la p√°gina.');
                    });
                }

                return root;
            };

	            window.showFatalError = (err, context) => {
	                const root = ensureOverlay();
	                const ctx = root.querySelector('#fatal-error-context');
	                const pre = root.querySelector('#fatal-error-text');

	                const msg = (err && (err.stack || err.message)) ? String(err.stack || err.message) : String(err);
	                if (ctx) ctx.textContent = context ? `(${String(context)})` : '';
	                if (pre) pre.textContent = msg;
	                root.style.display = 'block';
	            };

	            const shouldIgnoreGlobalError = (payload, meta) => {
	                const raw = (payload && (payload.stack || payload.message)) ? String(payload.stack || payload.message) : String(payload || '');
	                const msg = raw.toLowerCase();
	                const m = String(meta || '').toLowerCase();

	                // Extensiones del navegador (ej. MetaMask) inyectan scripts y a veces lanzan errores/rejections.
	                if (msg.includes('chrome-extension://') || msg.includes('moz-extension://') || msg.includes('safari-extension://')) return true;
	                if (m.startsWith('chrome-extension://') || m.startsWith('moz-extension://') || m.startsWith('safari-extension://')) return true;

	                // Caso com√∫n: MetaMask no conectado (no es un bug del editor).
	                if (msg.includes('metamask')) return true;
	                return false;
	            };

	            window.addEventListener('error', (e) => {
	                try {
	                    const payload = e && (e.error || e.message) ? (e.error || e.message) : 'Error';
	                    const meta = e && e.filename ? String(e.filename) : '';
	                    if (shouldIgnoreGlobalError(payload, meta)) return;
	                    window.showFatalError(payload, 'window.error');
	                } catch {
	                    // Ignorar
	                }
	            });

	            window.addEventListener('unhandledrejection', (e) => {
	                try {
	                    const payload = e && e.reason ? e.reason : 'Unhandled rejection';
	                    if (shouldIgnoreGlobalError(payload, '')) return;
	                    window.showFatalError(payload, 'unhandledrejection');
	                } catch {
	                    // Ignorar
	                }
	            });
        }

        setBuildLabelsFromHtmlAttr();
        installGlobalErrorOverlay();

        class FlowDiagramSystem {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.elements = [];
                this.selectedElements = [];
                this.clipboard = null;
                this.history = [];
                this.historyIndex = -1;
                
                // Estado del canvas
                this.camera = {
                    x: 0,
                    y: 0,
                    zoom: 1,
                    targetZoom: 1
                };
                
                // Estado de interacci√≥n
                this.tool = 'select';
                this.isDragging = false;
                this.isPanning = false;
                this.dragStart = { x: 0, y: 0 };
                this.tempElement = null;
                this.hoveredElement = null;
                this.resizingElement = null;
                this.resizeHandle = null;
                this.drawingPath = null;
                this.spacePressed = false;
                this.contextMenuElement = null;
                this.loadedImages = {}; // Cache de im√°genes cargadas
                this.loadedVideos = {}; // Cache de videos cargados (HTMLVideoElement)
                this.autoClosePathDistance = 15; // Distancia para auto-cerrar paths
                // Touch (mobile)
                this.touches = [];
                this.lastTouchDistance = 0;
                this.lastTouchCenter = { x: 0, y: 0 };
                this._touchMode = null; // null | 'mouse' | 'pinch'
                this._touchMouseDown = false;
                this._nudgeHistoryTimer = null; // Debounce para movimientos por teclado
                this.selectionBox = null; // { start:{x,y}, end:{x,y}, additive:boolean, base:[] }
                // Herramienta "Formas" (plantillas vectoriales)
                this.shapeType = safeLocalStorageGet('flow-diagram-shape-type', 'triangle') || 'triangle';
                // Panel Objetos (Capas)
                this.layersPanelOpen = (safeLocalStorageGet('flow-diagram-layers-open', '1') || '1') !== '0';
                this.layersFilter = '';

                // Modo visor (IA/preview): sin edici√≥n, sin grid y con fondo transparente.
                this.readOnly = false;
                this.showGrid = true;
                this.backgroundColor = '#1a1a2e'; // null => transparente
                this.viewerMode = null; // null | 'sticker' | 'deck'
                this.depthFx = false; // Sombra suave para dar "volumen" en modos visor
                this.viewerShowLabels = true; // En visor: ocultar nombres por defecto (override: ?labels=1)

                // Estado del "deck" (l√°mina informativa)
                this.deckLayout = 'horizontal'; // 'horizontal' | 'vertical'
                this.activeControlPointId = null;
                this._deckResizing = false;

                // Publicaci√≥n desde archivo
                this.publishFileProject = null;
                this.publishFileName = '';
                this.publishIntent = 'vector'; // 'vector' | 'sticker' | 'project'

                // Navegaci√≥n de biblioteca
                this.libraryPrefix = '';
                this.libraryMode = 'library'; // 'library' | 'grouped' | 'stkers'

                // "Canal" vivo (IA -> Canvas): polling por sesi√≥n (?listen=...)
                this.listenSession = null;
                this.listenTimer = null;
                this.listenLastDate = null;
                
                // M√≥dulos (permite expandir funcionalidad)
                this.modules = {};
                
                this.init();
            }
            
            init() {
                const safe = (label, fn, critical = false) => {
                    try {
                        fn();
                        return true;
                    } catch (err) {
                        try {
                            if (window.showFatalError) window.showFatalError(err, label);
                        } catch {
                            // Ignorar
                        }
                        console.error(err);
                        if (critical) return false;
                        return true;
                    }
                };

                if (!safe('init.resizeCanvas', () => this.resizeCanvas(), true)) return;
                if (!safe('init.setupEventListeners', () => this.setupEventListeners(), true)) return;
                safe('init.setupContextMenu', () => this.setupContextMenu());
                safe('init.setupLayersPanel', () => this.setupLayersPanel());
                safe('init.loadFromLocalStorage', () => this.loadFromLocalStorage());
                safe('init.startAnimationLoop', () => this.startAnimationLoop());

                // Seleccionar herramienta por defecto
                safe('init.defaultTool', () => {
                    const btn = document.getElementById('btn-select');
                    if (btn) btn.classList.add('active');
                });

                // NUEVO: Cargar JSON desde par√°metros de URL (si existen)
                safe('init.loadFromURLParameter', () => this.loadFromURLParameter());

                // Boot OK: ocultar pantalla de carga.
                safe('init.hideBootScreen', () => hideBootScreen());
            }
            
            resizeCanvas() {
                const toolbar = document.getElementById('toolbar');
                const statusBar = document.getElementById('status-bar');
                const toolbarHeight = toolbar ? toolbar.offsetHeight : 0;
                const statusHeight = statusBar ? statusBar.offsetHeight : 0;

                // Panel de Objetos (Capas): respetar el layout real (toolbar/status-bar).
                const layersPanel = document.getElementById('layers-panel');
                if (layersPanel) {
                    layersPanel.style.top = `${toolbarHeight}px`;
                    layersPanel.style.bottom = `${statusHeight}px`;
                }

                // Mantener el contenedor del canvas alineado con el layout real (toolbar/status-bar)
                // Nota: en modo deck, el tama√±o/posici√≥n del contenedor se controla externamente.
                const container = document.getElementById('canvas-container');
                if (container && this.viewerMode !== 'deck') {
                    container.style.top = `${toolbarHeight}px`;
                    container.style.bottom = `${statusHeight}px`;
                }

                if (container) {
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = Math.max(0, Math.floor(rect.width));
                    this.canvas.height = Math.max(0, Math.floor(rect.height));
                    return;
                }

                // Fallback
                this.canvas.width = window.innerWidth;
                this.canvas.height = Math.max(0, window.innerHeight - toolbarHeight - statusHeight);
            }
            
            setupEventListeners() {
                // Resize
                window.addEventListener('resize', () => {
                    if (this.viewerMode === 'deck') {
                        this.applyDeckSizing();
                    }
                    this.resizeCanvas();
                });
                
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('click', (e) => this.onClick(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevenir men√∫ contextual

                // Touch events (mobile)
                this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });
                this.canvas.addEventListener('touchcancel', (e) => this.onTouchEnd(e), { passive: false });
                
                // Cerrar men√∫ contextual al hacer clic fuera
                document.addEventListener('click', () => this.hideContextMenu());
                
                // Prevenir scroll en el canvas
                this.canvas.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
                
                // Keyboard events
                window.addEventListener('keydown', (e) => this.onKeyDown(e));
                window.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // Toolbar buttons
                this.setupToolbar();
                
                // Properties panel
                this.setupPropertiesPanel();
            }
            
	            setupToolbar() {
                // Herramientas de dibujo
                document.getElementById('btn-select').addEventListener('click', () => this.setTool('select'));
                document.getElementById('btn-rectangle').addEventListener('click', () => this.setTool('rectangle'));
                document.getElementById('btn-circle').addEventListener('click', () => this.setTool('circle'));
                document.getElementById('btn-poi').addEventListener('click', () => this.setTool('poi'));
                document.getElementById('btn-shape').addEventListener('click', () => this.setTool('shape'));
	                const shapeTypeSelect = document.getElementById('shape-type');
	                if (shapeTypeSelect) {
	                    shapeTypeSelect.value = this.shapeType || 'triangle';
	                    shapeTypeSelect.addEventListener('change', () => {
                        this.shapeType = String(shapeTypeSelect.value || 'triangle');
                        safeLocalStorageSet('flow-diagram-shape-type', this.shapeType);
                    });
                }
                document.getElementById('btn-line').addEventListener('click', () => this.setTool('line'));
                document.getElementById('btn-route').addEventListener('click', () => this.setTool('route'));
                document.getElementById('btn-metro').addEventListener('click', () => this.setTool('mover-metro'));
                document.getElementById('btn-person-male').addEventListener('click', () => this.setTool('mover-male'));
                document.getElementById('btn-person-female').addEventListener('click', () => this.setTool('mover-female'));
                document.getElementById('btn-portal-in').addEventListener('click', () => this.setTool('portal-in'));
                document.getElementById('btn-portal-out').addEventListener('click', () => this.setTool('portal-out'));
                document.getElementById('btn-pencil').addEventListener('click', () => this.setTool('pencil'));
                document.getElementById('btn-image').addEventListener('click', () => this.insertImage());
                document.getElementById('btn-video').addEventListener('click', () => this.insertVideo());
                document.getElementById('btn-bucket').addEventListener('click', () => this.setTool('bucket'));
                
                // Acciones
                document.getElementById('btn-group').addEventListener('click', () => this.groupElements());
                document.getElementById('btn-ungroup').addEventListener('click', () => this.ungroupElements());
                document.getElementById('btn-lock').addEventListener('click', () => this.toggleLock());
                document.getElementById('btn-bring-front').addEventListener('click', () => this.bringToFront());
                document.getElementById('btn-send-back').addEventListener('click', () => this.sendToBack());
                
                // Edici√≥n
                document.getElementById('btn-copy').addEventListener('click', () => this.copyElements());
                document.getElementById('btn-paste').addEventListener('click', () => this.pasteElements());
                document.getElementById('btn-delete').addEventListener('click', () => this.deleteElements());
                document.getElementById('btn-undo').addEventListener('click', () => this.undo());
                
                // Zoom
                document.getElementById('btn-zoom-in').addEventListener('click', () => this.zoomIn());
                document.getElementById('btn-zoom-out').addEventListener('click', () => this.zoomOut());
                document.getElementById('btn-zoom-reset').addEventListener('click', () => this.resetZoom());
                
                // Archivo
                document.getElementById('btn-new').addEventListener('click', () => this.newProject());
                document.getElementById('btn-save').addEventListener('click', () => this.showSaveModal());
                document.getElementById('btn-load').addEventListener('click', () => this.loadProject());
                document.getElementById('btn-export').addEventListener('click', () => this.exportProject());
                document.getElementById('btn-publish').addEventListener('click', () => this.showPublishModal('vector'));
                document.getElementById('btn-publish-sticker').addEventListener('click', () => this.showPublishModal('sticker'));
                document.getElementById('btn-publish-project').addEventListener('click', () => this.showPublishModal('project'));
                document.getElementById('btn-library').addEventListener('click', () => this.showLibraryModal());
                document.getElementById('btn-grouped-library').addEventListener('click', () => this.showLibraryModal('grouped'));
                document.getElementById('btn-stkers-library').addEventListener('click', () => this.showLibraryModal('stkers'));
                
                // Modal de guardado
                document.getElementById('btn-cancel-save').addEventListener('click', () => this.hideSaveModal());
                document.getElementById('btn-confirm-save').addEventListener('click', () => this.saveProject());

                // Modal de publicaci√≥n
                document.getElementById('btn-cancel-publish').addEventListener('click', () => this.hidePublishModal());
                document.getElementById('btn-confirm-publish').addEventListener('click', () => this.publishSticker());
                document.getElementById('btn-confirm-publish-project').addEventListener('click', () => this.publishProject());
                document.getElementById('btn-pick-publish-file').addEventListener('click', () => this.pickPublishFile());
                document.getElementById('btn-clear-publish-file').addEventListener('click', () => this.clearPublishFile());
                document.getElementById('btn-toggle-paste-json').addEventListener('click', () => this.togglePublishPasteBox());
                document.getElementById('btn-use-pasted-json').addEventListener('click', () => this.usePastedPublishJson());
                document.getElementById('btn-clear-pasted-json').addEventListener('click', () => this.clearPastedPublishJson());
                this.setupPublishKey();

                // Modal biblioteca
                document.getElementById('btn-library-close').addEventListener('click', () => this.hideLibraryModal());
                document.getElementById('btn-library-refresh').addEventListener('click', () => this.refreshLibrary());
                document.getElementById('btn-library-up').addEventListener('click', () => this.libraryNavigateUp());
                document.getElementById('btn-library-upload').addEventListener('click', () => this.pickLibraryUploadFile());
                document.getElementById('btn-library-mode-library').addEventListener('click', () => this.setLibraryMode('library'));
                document.getElementById('btn-library-mode-grouped').addEventListener('click', () => this.setLibraryMode('grouped'));
                document.getElementById('btn-library-mode-stkers').addEventListener('click', () => this.setLibraryMode('stkers'));
                document.getElementById('library-prefix').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') this.refreshLibrary();
                });
                document.getElementById('library-list').addEventListener('click', (e) => this.onLibraryClick(e));
                
                // File input
                document.getElementById('file-input').addEventListener('change', (e) => this.importProject(e));
                document.getElementById('publish-file-input').addEventListener('change', (e) => this.onPublishFileSelected(e));
                document.getElementById('library-upload-input').addEventListener('change', (e) => this.onLibraryUploadSelected(e));
                document.getElementById('image-input').addEventListener('change', (e) => this.loadImageFile(e));
                document.getElementById('video-input').addEventListener('change', (e) => this.loadVideoFile(e));

                // Deck (l√°mina informativa)
	                const deckList = document.getElementById('deck-control-points');
	                if (deckList) {
	                    deckList.addEventListener('click', (e) => this.onDeckControlPointClick(e));
	                }
	                const deckNavList = document.getElementById('deck-nav-list');
	                if (deckNavList) {
	                    deckNavList.addEventListener('click', (e) => this.onDeckControlPointClick(e));
	                }
	                const deckWhatsapp = document.getElementById('btn-deck-whatsapp');
	                if (deckWhatsapp) {
	                    deckWhatsapp.addEventListener('click', () => this.shareDeckToWhatsApp());
	                }
                const deckShare = document.getElementById('btn-deck-share');
                if (deckShare) {
                    deckShare.addEventListener('click', () => this.shareDeckNative());
                }
                const deckMoltbook = document.getElementById('btn-deck-moltbook');
                if (deckMoltbook) {
                    deckMoltbook.addEventListener('click', () => this.shareDeckToMoltbook());
                }
	                const deckCopyLink = document.getElementById('btn-deck-copy-link');
	                if (deckCopyLink) {
	                    deckCopyLink.addEventListener('click', () => this.copyDeckLink());
	                }
	                const deckPrev = document.getElementById('btn-deck-prev');
	                if (deckPrev) {
	                    deckPrev.addEventListener('click', () => this.goToDeckControlPoint(-1));
	                }
	                const deckNext = document.getElementById('btn-deck-next');
	                if (deckNext) {
	                    deckNext.addEventListener('click', () => this.goToDeckControlPoint(1));
	                }
	                this.setupDeckResizer();
	            }
            
	            setupContextMenu() {
	                document.getElementById('ctx-bring-to-front').addEventListener('click', () => {
	                    this.bringToFrontComplete();
	                    this.hideContextMenu();
	                });
                
                document.getElementById('ctx-bring-forward').addEventListener('click', () => {
                    this.bringToFront();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-send-backward').addEventListener('click', () => {
                    this.sendToBack();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-send-to-back').addEventListener('click', () => {
                    this.sendToBackComplete();
                    this.hideContextMenu();
                });
                
                document.getElementById('ctx-duplicate').addEventListener('click', () => {
                    this.duplicateSelected();
                    this.hideContextMenu();
                });

                const ctxSaveGrouped = document.getElementById('ctx-save-grouped');
                if (ctxSaveGrouped) {
                    ctxSaveGrouped.addEventListener('click', async () => {
                        await this.saveSelectionAsGroupedLibrary();
                        this.hideContextMenu();
                    });
                }
                
                document.getElementById('ctx-delete').addEventListener('click', () => {
                    this.deleteElements();
                    this.hideContextMenu();
                });

                const ctxLineWidth = document.getElementById('ctx-line-width');
                if (ctxLineWidth) {
                    ctxLineWidth.addEventListener('click', () => {
                        this.changeLineWidth();
                        this.hideContextMenu();
                    });
                }

	                const ctxCrop = document.getElementById('ctx-crop');
	                if (ctxCrop) {
	                    ctxCrop.addEventListener('click', () => {
	                        this.cropSelectedElement();
	                        this.hideContextMenu();
	                    });
	                }

                    const ctxAutoTrimImage = document.getElementById('ctx-auto-trim-image');
                    if (ctxAutoTrimImage) {
                        ctxAutoTrimImage.addEventListener('click', async () => {
                            await this.autoTrimSelectedImageToAlpha();
                            this.hideContextMenu();
                        });
                    }

                    const ctxVectorizeImage = document.getElementById('ctx-vectorize-image');
                    if (ctxVectorizeImage) {
                        ctxVectorizeImage.addEventListener('click', async () => {
                            await this.convertSelectedImageToVectorPolygon();
                            this.hideContextMenu();
                        });
                    }

	                const ctxRotateLeft = document.getElementById('ctx-rotate-left');
	                if (ctxRotateLeft) {
	                    ctxRotateLeft.addEventListener('click', () => {
	                        this.rotateSelectedElements(-15);
	                        this.hideContextMenu();
	                    });
	                }

	                const ctxRotateRight = document.getElementById('ctx-rotate-right');
	                if (ctxRotateRight) {
	                    ctxRotateRight.addEventListener('click', () => {
	                        this.rotateSelectedElements(15);
	                        this.hideContextMenu();
	                    });
	                }

	                const ctxFlipX = document.getElementById('ctx-flip-x');
	                if (ctxFlipX) {
	                    ctxFlipX.addEventListener('click', () => {
	                        this.flipSelectedElementsX();
	                        this.hideContextMenu();
	                    });
	                }
	            }
            
		            setupPropertiesPanel() {
		                const inputs = [
		                    'prop-name',
		                    'prop-cp-enabled',
		                    'prop-cp-order',
		                    'prop-slide-title',
		                    'prop-slide-text',
		                    'prop-slide-image-url',
		                    'prop-slide-video-url',
		                    'prop-fill-color',
		                    'prop-stroke-color',
		                    'prop-anim-color',
	                    'prop-flow-direction',
	                    'prop-connection-status',
	                    'prop-active',
	                    'prop-stroke-transparent',
                        'prop-is-route',
                        'prop-route-curve',
                        'prop-route-arc-side',
                        'prop-route-arc-deg',
                        'prop-route-id',
                        'prop-follow-route',
                        'prop-route-mode',
                        'prop-auto-connect-route',
                        'prop-portal-kind',
                        'prop-portal-key',
		                ];
	                
		                inputs.forEach(id => {
		                    const el = document.getElementById(id);
		                    if (!el) return;
		                    el.addEventListener('change', () => this.updateSelectedProperties());
		                });

		                // Fill: Transparente vs Degradado (lineal)
		                const fillCb = document.getElementById('prop-fill-transparent');
		                const fgEnabled = document.getElementById('prop-fill-gradient-enabled');
		                const fgControls = document.getElementById('prop-fill-gradient-controls');
		                const fgA = document.getElementById('prop-fill-gradient-a');
		                const fgB = document.getElementById('prop-fill-gradient-b');
		                const fgAngle = document.getElementById('prop-fill-gradient-angle');
		                const fgAngleValue = document.getElementById('prop-fill-gradient-angle-value');

		                const syncFillGradientUI = () => {
		                    const on = Boolean(fgEnabled && fgEnabled.checked);
		                    if (fgControls) fgControls.style.display = on ? 'block' : 'none';
		                    if (fgAngle && fgAngleValue) {
		                        const v = String(fgAngle.value || '0');
		                        fgAngleValue.textContent = `${v}¬∞`;
		                    }
		                };

		                if (fillCb) {
		                    fillCb.addEventListener('change', () => {
		                        if (fillCb.checked && fgEnabled) fgEnabled.checked = false;
		                        syncFillGradientUI();
		                        this.updateSelectedProperties();
		                    });
		                }

		                if (fgEnabled) {
		                    fgEnabled.addEventListener('change', () => {
		                        if (fgEnabled.checked && fillCb) fillCb.checked = false;
		                        syncFillGradientUI();
		                        this.updateSelectedProperties();
		                    });
		                }

		                if (fgA) fgA.addEventListener('change', () => this.updateSelectedProperties());
		                if (fgB) fgB.addEventListener('change', () => this.updateSelectedProperties());
		                if (fgAngle) {
		                    const onAngle = () => {
		                        syncFillGradientUI();
		                        this.updateSelectedProperties();
		                    };
		                    fgAngle.addEventListener('input', onAngle);
		                    fgAngle.addEventListener('change', onAngle);
		                }

		                syncFillGradientUI();

	                const lw = document.getElementById('prop-line-width');
	                const lwVal = document.getElementById('prop-line-width-value');
	                if (lw) {
	                    const onChange = () => {
	                        const v = String(lw.value || '');
	                        if (lwVal) lwVal.textContent = `${v || 0}px`;
	                        this.updateSelectedProperties();
	                    };
	                    lw.addEventListener('input', onChange);
	                    lw.addEventListener('change', onChange);
	                }

	                const btnConvert = document.getElementById('btn-convert-to-polygon');
	                if (btnConvert) {
	                    btnConvert.addEventListener('click', () => this.convertSelectedToPolygon());
	                }

                    const bindNearestRouteBtn = document.getElementById('btn-bind-nearest-route');
                    if (bindNearestRouteBtn) {
                        bindNearestRouteBtn.addEventListener('click', () => this.bindSelectedMoversToNearestRoute());
                    }

                    const moverSpeed = document.getElementById('prop-mover-speed');
                    const moverSpeedVal = document.getElementById('prop-mover-speed-value');
                    if (moverSpeed) {
                        const onMoverSpeed = () => {
                            if (moverSpeedVal) moverSpeedVal.textContent = String(moverSpeed.value || '0');
                            this.updateSelectedProperties();
                        };
                        moverSpeed.addEventListener('input', onMoverSpeed);
                        moverSpeed.addEventListener('change', onMoverSpeed);
                    }

                    const moverWidth = document.getElementById('prop-mover-width');
                    const moverWidthVal = document.getElementById('prop-mover-width-value');
                    const moverHeight = document.getElementById('prop-mover-height');
                    const moverHeightVal = document.getElementById('prop-mover-height-value');
                    if (moverWidth) {
                        const onMoverWidth = () => {
                            if (moverWidthVal) moverWidthVal.textContent = String(moverWidth.value || '0');
                            this.updateSelectedProperties();
                        };
                        moverWidth.addEventListener('input', onMoverWidth);
                        moverWidth.addEventListener('change', onMoverWidth);
                    }
                    if (moverHeight) {
                        const onMoverHeight = () => {
                            if (moverHeightVal) moverHeightVal.textContent = String(moverHeight.value || '0');
                            this.updateSelectedProperties();
                        };
                        moverHeight.addEventListener('input', onMoverHeight);
                        moverHeight.addEventListener('change', onMoverHeight);
                    }

                    const routeArcDeg = document.getElementById('prop-route-arc-deg');
                    const routeArcDegVal = document.getElementById('prop-route-arc-deg-value');
                    if (routeArcDeg) {
                        const onArcDeg = () => {
                            if (routeArcDegVal) routeArcDegVal.textContent = `${String(routeArcDeg.value || '0')}¬∞`;
                            this.updateSelectedProperties();
                        };
                        routeArcDeg.addEventListener('input', onArcDeg);
                        routeArcDeg.addEventListener('change', onArcDeg);
                    }

	                const cpEnabled = document.getElementById('prop-cp-enabled');
	                const cpDetails = document.getElementById('prop-cp-details');
	                if (cpEnabled) {
	                    cpEnabled.addEventListener('change', () => {
	                        if (cpDetails) cpDetails.style.display = cpEnabled.checked ? 'block' : 'none';
	                        // Al activar/desactivar, refrescar valores (orden/t√≠tulo default).
	                        this.updatePropertiesPanel();
	                    });
	                }
	            }

            // ==================== PANEL OBJETOS (CAPAS) ====================

            setupLayersPanel() {
                const panel = document.getElementById('layers-panel');
                if (!panel) return;

                const btnToggle = document.getElementById('btn-layers');
                if (btnToggle) {
                    btnToggle.addEventListener('click', () => this.toggleLayersPanel());
                }

                const btnHide = document.getElementById('btn-layers-hide');
                if (btnHide) {
                    btnHide.addEventListener('click', () => this.setLayersPanelOpen(false));
                }

                const filter = document.getElementById('layers-filter');
                if (filter) {
                    filter.value = this.layersFilter || '';
                    filter.addEventListener('input', () => {
                        this.layersFilter = String(filter.value || '');
                        this.refreshLayersPanel();
                    });
                }

                const btnUnlockAll = document.getElementById('btn-layers-unlock-all');
                if (btnUnlockAll) {
                    btnUnlockAll.addEventListener('click', () => this.unlockAllElements());
                }

                const btnDeleteSel = document.getElementById('btn-layers-delete-selected');
                if (btnDeleteSel) {
                    btnDeleteSel.addEventListener('click', () => this.deleteElements());
                }

                const list = document.getElementById('layers-list');
                if (list) {
                    list.addEventListener('click', (e) => this.onLayersListClick(e));
                }

                this.setLayersPanelOpen(this.layersPanelOpen, { persist: false });
                this.refreshLayersPanel();
            }

            setLayersPanelOpen(open, options) {
                const opts = options && typeof options === 'object' ? options : {};
                const v = Boolean(open);
                this.layersPanelOpen = v;

                const panel = document.getElementById('layers-panel');
                if (panel) panel.classList.toggle('show', v);
                document.body.classList.toggle('layers-open', v);

                if (opts.persist !== false) {
                    safeLocalStorageSet('flow-diagram-layers-open', v ? '1' : '0');
                }

                this.resizeCanvas();
                if (v) this.refreshLayersPanel();
                this.updateLayersSelectionHighlight();
            }

            toggleLayersPanel() {
                this.setLayersPanelOpen(!this.layersPanelOpen);
            }

            getLayerTypeIcon(elem) {
                const t = elem && elem.type ? String(elem.type) : '';
                const icons = {
                    rectangle: '‚ñ≠',
                    circle: '‚óè',
                    line: '‚Üí',
                    mover: 'üö∂',
                    portal: 'üåÄ',
                    polygon: '‚¨†',
                    path: '‚úé',
                    image: 'üñºÔ∏è',
                    video: 'üéûÔ∏è',
                    group: '‚äû'
                };
                return icons[t] || '‚Ä¢';
            }

            getLayerTypeLabel(elem) {
                const t = elem && elem.type ? String(elem.type) : '';
                const labels = {
                    rectangle: 'Rect√°ngulo',
                    circle: 'C√≠rculo',
                    line: 'L√≠nea',
                    mover: 'Actor',
                    portal: 'Portal',
                    polygon: 'Pol√≠gono',
                    path: 'Trazado',
                    image: 'Imagen',
                    video: 'Video',
                    group: 'Grupo'
                };
                return labels[t] || t || 'Elemento';
            }

            getLayerDisplayName(elem) {
                if (!elem || typeof elem !== 'object') return 'Elemento';
                const name = (typeof elem.name === 'string' ? elem.name.trim() : '');
                if (name) return name;

                if (elem.type === 'group') {
                    const n = Array.isArray(elem.elements) ? elem.elements.length : 0;
                    return `Grupo (${n})`;
                }
                if (elem.type === 'mover') {
                    const k = String(elem.moverKind || 'metro');
                    if (k === 'male') return 'Actor Hombre';
                    if (k === 'female') return 'Actor Mujer';
                    return 'Actor Metro';
                }
                if (elem.type === 'portal') {
                    const k = String(elem.portalKind || 'import');
                    const key = String(elem.portalKey || 'A1');
                    return `${k === 'export' ? 'Portal Export' : 'Portal Import'} ¬∑ ${key}`;
                }

                const label = this.getLayerTypeLabel(elem);
                const id = elem.id != null ? String(elem.id) : '';
                const shortId = id ? id.slice(-6) : '';
                return shortId ? `${label} ¬∑ ${shortId}` : label;
            }

            findTopLevelElementById(idRaw) {
                const id = String(idRaw || '');
                return this.elements.find((e) => String(e && e.id) === id) || null;
            }

            updateLayersSelectionHighlight() {
                const panel = document.getElementById('layers-panel');
                if (!panel || !panel.classList.contains('show')) return;

                const list = document.getElementById('layers-list');
                if (!list) return;

                const selected = new Set(this.selectedElements.map((e) => String(e && e.id)));
                list.querySelectorAll('.layers-item').forEach((el) => {
                    const id = el.getAttribute('data-id') || '';
                    el.classList.toggle('selected', selected.has(String(id)));
                });
            }

            refreshLayersPanel() {
                const panel = document.getElementById('layers-panel');
                if (!panel || !panel.classList.contains('show')) return;

                const list = document.getElementById('layers-list');
                const status = document.getElementById('layers-status');
                if (!list || !status) return;

                const q = String(this.layersFilter || '').trim().toLowerCase();
                const elements = Array.isArray(this.elements) ? this.elements.slice().reverse() : [];

                list.innerHTML = '';

                let shown = 0;
                elements.forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;

                    const type = String(elem.type || '').toLowerCase();
                    const name = this.getLayerDisplayName(elem);
                    const haystack = `${type} ${name}`.toLowerCase();
                    if (q && !haystack.includes(q)) return;

                    shown++;

                    const row = document.createElement('div');
                    row.className = 'layers-item';
                    row.setAttribute('data-id', String(elem.id));

                    const meta = document.createElement('div');
                    meta.className = 'layers-meta';

                    const typeIcon = document.createElement('div');
                    typeIcon.className = 'layers-type';
                    typeIcon.textContent = this.getLayerTypeIcon(elem);

                    const nameEl = document.createElement('div');
                    nameEl.className = 'layers-name';
                    nameEl.textContent = name;

                    const badges = document.createElement('div');
                    badges.className = 'layers-badges';
                    if (elem.locked) {
                        const b = document.createElement('span');
                        b.textContent = 'üîí';
                        badges.appendChild(b);
                    }
                    if (elem.active === false) {
                        const b = document.createElement('span');
                        b.textContent = '‚è∏';
                        badges.appendChild(b);
                    }

                    meta.appendChild(typeIcon);
                    meta.appendChild(nameEl);
                    meta.appendChild(badges);

                    const actions = document.createElement('div');
                    actions.className = 'layers-actions';

                    const btnFocus = document.createElement('button');
                    btnFocus.className = 'btn small';
                    btnFocus.textContent = 'Ir';
                    btnFocus.setAttribute('data-action', 'focus');
                    btnFocus.setAttribute('title', 'Centrar vista en este objeto');

                    const btnLock = document.createElement('button');
                    btnLock.className = 'btn small';
                    btnLock.textContent = elem.locked ? 'Desbloq' : 'Bloq';
                    btnLock.setAttribute('data-action', 'lock');
                    btnLock.setAttribute('title', elem.locked ? 'Desbloquear' : 'Bloquear');

                    const btnDelete = document.createElement('button');
                    btnDelete.className = 'btn small';
                    btnDelete.textContent = 'Borrar';
                    btnDelete.setAttribute('data-action', 'delete');
                    btnDelete.setAttribute('title', 'Eliminar este objeto del proyecto');

                    actions.appendChild(btnFocus);
                    actions.appendChild(btnLock);
                    actions.appendChild(btnDelete);

                    if (elem.type === 'group') {
                        const btnUngroup = document.createElement('button');
                        btnUngroup.className = 'btn small';
                        btnUngroup.textContent = 'Desagrupar';
                        btnUngroup.setAttribute('data-action', 'ungroup');
                        btnUngroup.setAttribute('title', 'Desagrupar (convertir grupo en elementos sueltos)');
                        actions.appendChild(btnUngroup);
                    }

                    row.appendChild(meta);
                    row.appendChild(actions);

                    list.appendChild(row);
                });

                status.textContent = `Objetos: ${shown}/${this.elements.length}`;
                this.updateLayersSelectionHighlight();
            }

            onLayersListClick(e) {
                if (this.readOnly) return;

                const actionBtn = e.target && e.target.closest ? e.target.closest('[data-action]') : null;
                const row = e.target && e.target.closest ? e.target.closest('.layers-item') : null;
                if (!row) return;

                const id = row.getAttribute('data-id') || '';
                const elem = this.findTopLevelElementById(id);
                if (!elem) return;

                const action = actionBtn ? String(actionBtn.getAttribute('data-action') || '') : '';

                if (action === 'lock') {
                    elem.locked = !elem.locked;
                    this.saveHistory();
                    return;
                }

                if (action === 'delete') {
                    // Borrado forzado: aunque sea dif√≠cil seleccionarlo desde el canvas.
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) this.elements.splice(idx, 1);
                    this.selectedElements = this.selectedElements.filter((s) => s !== elem);
                    this.saveHistory();
                    this.hidePropertiesPanel();
                    this.updateStatusBar();
                    return;
                }

                if (action === 'ungroup' && elem.type === 'group') {
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) {
                        this.elements.splice(idx, 1);
                        if (Array.isArray(elem.elements)) this.elements.push(...elem.elements);
                        this.selectedElements = [];
                        this.saveHistory();
                    }
                    return;
                }

                if (action === 'focus') {
                    this.focusCameraOnElement(elem);
                    return;
                }

                // Click en la fila: seleccionar (Ctrl para multi-selecci√≥n)
                if (e.ctrlKey || e.metaKey) {
                    const i = this.selectedElements.indexOf(elem);
                    if (i >= 0) {
                        this.selectedElements.splice(i, 1);
                    } else {
                        this.selectedElements.push(elem);
                    }
                } else {
                    this.selectedElements = [elem];
                }

                this.updatePropertiesPanel();
                this.updateStatusBar();
                this.updateLayersSelectionHighlight();
            }

            unlockAllElements() {
                if (this.readOnly) return;
                this.walkElements(this.elements, (elem) => {
                    if (elem && typeof elem === 'object') elem.locked = false;
                    return true;
                });
                this.saveHistory();
            }

            getElementBoundsForFocus(elem) {
                if (!elem || typeof elem !== 'object') return null;

                if (elem.type === 'line') {
                    const pts = this.getRoutePoints(elem);
                    if (!pts.length) return null;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    pts.forEach((p) => {
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    elem.points.forEach((p) => {
                        if (!p) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (elem.type === 'group') {
                    // Preferir bounds del grupo; si est√°n mal, usar c√°lculo recursivo.
                    const x1 = Number(elem.x);
                    const y1 = Number(elem.y);
                    const w = Number(elem.width);
                    const h = Number(elem.height);
                    if (Number.isFinite(x1) && Number.isFinite(y1) && Number.isFinite(w) && Number.isFinite(h)) {
                        const minX = Math.min(x1, x1 + w);
                        const maxX = Math.max(x1, x1 + w);
                        const minY = Math.min(y1, y1 + h);
                        const maxY = Math.max(y1, y1 + h);
                        return { minX, minY, maxX, maxY };
                    }
                    if (Array.isArray(elem.elements)) return this.getElementsBounds(elem.elements);
                    return null;
                }

                if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
                    typeof elem.width === 'number' && typeof elem.height === 'number') {
                    const minX = Math.min(elem.x, elem.x + elem.width);
                    const maxX = Math.max(elem.x, elem.x + elem.width);
                    const minY = Math.min(elem.y, elem.y + elem.height);
                    const maxY = Math.max(elem.y, elem.y + elem.height);
                    return { minX, minY, maxX, maxY };
                }

                return null;
            }

            focusCameraOnElement(elem) {
                const bounds = this.getElementBoundsForFocus(elem);
                if (!bounds) return;

                const cx = (bounds.minX + bounds.maxX) / 2;
                const cy = (bounds.minY + bounds.maxY) / 2;
                const z = this.camera.zoom || 1;

                this.camera.x = this.canvas.width / 2 - cx * z;
                this.camera.y = this.canvas.height / 2 - cy * z;
                this.updateZoomIndicator();
            }
            
	            setTool(tool) {
	                if (this.readOnly) {
	                    // En modo visor no permitimos cambiar herramientas.
	                    this.tool = 'select';
	                    return;
	                }

	                this.tool = tool;
	                
                const btnMap = {
                    'select': 'btn-select',
                    'rectangle': 'btn-rectangle',
                    'circle': 'btn-circle',
                    'poi': 'btn-poi',
                    'shape': 'btn-shape',
                    'bucket': 'btn-bucket',
                    'line': 'btn-line',
                    'route': 'btn-route',
                    'mover-metro': 'btn-metro',
                    'mover-male': 'btn-person-male',
                    'mover-female': 'btn-person-female',
                    'portal-in': 'btn-portal-in',
                    'portal-out': 'btn-portal-out',
                    'pencil': 'btn-pencil'
                };

                // Actualizar UI (solo botones de herramientas, no toda la toolbar)
                Object.values(btnMap).forEach((id) => {
                    const b = document.getElementById(id);
                    if (b) b.classList.remove('active');
                });
                
                if (btnMap[tool]) {
                    document.getElementById(btnMap[tool]).classList.add('active');
                }

                // Mostrar/ocultar selector de formas
                document.body.classList.toggle('shape-tool-active', tool === 'shape');
            }

            // ==================== TOUCH SUPPORT ====================

            onTouchStart(e) {
                if (!e) return;
                e.preventDefault();
                this.hideContextMenu();

                const touches = Array.from(e.touches || []);
                this.touches = touches;

                if (touches.length >= 2) {
                    this._touchMode = 'pinch';
                    this._touchMouseDown = false;
                    this.isPanning = false;
                    this.isDragging = false;
                    this.resizingElement = null;
                    this.resizeHandle = null;

                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    this.lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                    this.lastTouchCenter = {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2
                    };

                    const container = document.getElementById('canvas-container');
                    if (container) container.classList.remove('grabbing');
                    return;
                }

                if (touches.length === 1) {
                    this._touchMode = 'mouse';
                    this._touchMouseDown = true;
                    const t = touches[0];
                    this.onMouseDown({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        button: 0,
                        ctrlKey: false,
                        preventDefault: () => {}
                    });
                }
            }

            onTouchMove(e) {
                if (!e) return;
                e.preventDefault();

                const touches = Array.from(e.touches || []);
                this.touches = touches;

                if (touches.length >= 2) {
                    this._touchMode = 'pinch';
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const center = {
                        x: (touches[0].clientX + touches[1].clientX) / 2,
                        y: (touches[0].clientY + touches[1].clientY) / 2
                    };

                    if (this.lastTouchDistance > 0) {
                        const zoomFactor = distance / this.lastTouchDistance;
                        if (Number.isFinite(zoomFactor) && zoomFactor > 0) {
                            const newZoom = Math.max(0.1, Math.min(5, this.camera.zoom * zoomFactor));
                            const rect = this.canvas.getBoundingClientRect();
                            const canvasX = center.x - rect.left;
                            const canvasY = center.y - rect.top;

                            const worldBefore = this.screenToWorld(canvasX, canvasY);
                            this.camera.zoom = newZoom;
                            const worldAfter = this.screenToWorld(canvasX, canvasY);

                            // Mantener el punto bajo el centro de los dedos
                            this.camera.x += (worldAfter.x - worldBefore.x) * this.camera.zoom;
                            this.camera.y += (worldAfter.y - worldBefore.y) * this.camera.zoom;
                        }

                        // Pan con 2 dedos (delta en pixeles de pantalla)
                        const dx2 = center.x - this.lastTouchCenter.x;
                        const dy2 = center.y - this.lastTouchCenter.y;
                        this.camera.x += dx2;
                        this.camera.y += dy2;
                        this.updateZoomIndicator();
                    }

                    this.lastTouchDistance = distance;
                    this.lastTouchCenter = center;
                    return;
                }

                if (touches.length === 1) {
                    const t = touches[0];
                    // Si venimos de un pinch, dejamos el modo "mouse" sin forzar mousedown.
                    this._touchMode = 'mouse';
                    this.onMouseMove({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        preventDefault: () => {}
                    });
                }
            }

            onTouchEnd(e) {
                if (!e) return;
                e.preventDefault();

                const touches = Array.from(e.touches || []);
                this.touches = touches;

                if (touches.length < 2) this.lastTouchDistance = 0;

                if (touches.length === 0) {
                    if (this._touchMouseDown) {
                        this.onMouseUp({ preventDefault: () => {} });
                    } else {
                        this.isPanning = false;
                        this.isDragging = false;
                        const container = document.getElementById('canvas-container');
                        if (container) container.classList.remove('grabbing');
                    }

                    this._touchMouseDown = false;
                    this._touchMode = null;
                }
            }
            
            // ==================== TRANSFORMACIONES ====================
            
            screenToWorld(x, y) {
                return {
                    x: (x - this.camera.x) / this.camera.zoom,
                    y: (y - this.camera.y) / this.camera.zoom
                };
            }
            
	            worldToScreen(x, y) {
	                return {
	                    x: x * this.camera.zoom + this.camera.x,
	                    y: y * this.camera.zoom + this.camera.y
	                };
	            }

	            // ==================== TRANSFORMACIONES DE ELEMENTO (ROTAR/VOLTEAR) ====================

	            getElementRotationDegrees(elem) {
	                const v = Number(elem && elem.rotation);
	                return Number.isFinite(v) ? v : 0;
	            }

	            elementHasBoxTransform(elem) {
	                if (!elem || typeof elem !== 'object') return false;
	                if (!(elem.type === 'image' || elem.type === 'video' || elem.type === 'rectangle' || elem.type === 'circle')) return false;
	                const rot = this.getElementRotationDegrees(elem);
	                const flipX = elem.flipX === true;
	                const flipY = elem.flipY === true;
	                return rot !== 0 || flipX || flipY;
	            }

	            applyElementBoxTransformToContext(elem) {
	                if (!this.ctx) return false;
	                if (!this.elementHasBoxTransform(elem)) return false;
	                if (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) || !Number.isFinite(elem.width) || !Number.isFinite(elem.height)) return false;

	                const rotDeg = this.getElementRotationDegrees(elem);
	                const flipX = elem.flipX === true;
	                const flipY = elem.flipY === true;
	                if (rotDeg === 0 && !flipX && !flipY) return false;

	                const cx = elem.x + elem.width / 2;
	                const cy = elem.y + elem.height / 2;

	                this.ctx.save();
	                this.ctx.translate(cx, cy);
	                if (rotDeg) this.ctx.rotate((rotDeg * Math.PI) / 180);
	                this.ctx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
	                this.ctx.translate(-cx, -cy);
	                return true;
	            }

	            restoreElementBoxTransform(applied) {
	                if (applied) this.ctx.restore();
	            }

	            transformPointToElementBoxLocal(elem, x, y) {
	                if (!elem || typeof elem !== 'object') return { x, y };
	                if (!this.elementHasBoxTransform(elem)) return { x, y };
	                if (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) || !Number.isFinite(elem.width) || !Number.isFinite(elem.height)) return { x, y };

	                const rotDeg = this.getElementRotationDegrees(elem);
	                const flipX = elem.flipX === true;
	                const flipY = elem.flipY === true;
	                if (rotDeg === 0 && !flipX && !flipY) return { x, y };

	                const cx = elem.x + elem.width / 2;
	                const cy = elem.y + elem.height / 2;

	                let dx = x - cx;
	                let dy = y - cy;

	                // Inversa de rotaci√≥n (pasar del mundo -> espacio local no rotado).
	                const a = (-rotDeg * Math.PI) / 180;
	                const cos = Math.cos(a);
	                const sin = Math.sin(a);
	                let rx = dx * cos - dy * sin;
	                let ry = dx * sin + dy * cos;

	                // Inversa de escala (flip). Como es +/-1, dividir es seguro.
	                const sx = flipX ? -1 : 1;
	                const sy = flipY ? -1 : 1;
	                rx /= sx;
	                ry /= sy;

	                return { x: rx + cx, y: ry + cy };
	            }
	            
	            // ==================== EVENTOS DEL MOUSE ====================
            
            onMouseDown(e) {
                // Si hab√≠a un marco de selecci√≥n activo, cancelarlo al iniciar otra interacci√≥n.
                this.selectionBox = null;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);

                // Modo visor: solo pan/zoom (sin selecci√≥n, sin edici√≥n, sin men√∫ contextual)
                if (this.readOnly) {
                    // En deck: permitir seleccionar "puntos de control" (sin editar).
                    if (this.viewerMode === 'deck' && e.button === 0 && !this.spacePressed) {
                        const clicked = this.getElementAt(worldPos.x, worldPos.y);
                        if (clicked && this.isControlPoint(clicked)) {
                            this.setActiveControlPoint(clicked, { focus: true, updateUrl: true });
                            return;
                        }
                    }

                    // Pan con click izquierdo o rueda (o espacio si se mantiene compatibilidad)
                    if (e.button === 0 || e.button === 1 || this.spacePressed) {
                        e.preventDefault();
                        this.isPanning = true;
                        this.dragStart = { x: mouseX, y: mouseY };
                        document.getElementById('canvas-container').classList.add('grabbing');
                        this.canvas.style.cursor = 'grabbing';
                    }
                    return;
                }
                
                // Men√∫ contextual con bot√≥n derecho
                if (e.button === 2) {
                    const clickedElement = this.getElementAt(worldPos.x, worldPos.y);
                    if (clickedElement) {
                        if (!this.selectedElements.includes(clickedElement)) {
                            this.selectedElements = [clickedElement];
                        }
                        this.showContextMenu(e.clientX, e.clientY);
                        this.updatePropertiesPanel();
                        return;
                    }
                }
                
                // Pan con rueda del mouse o espacio
	                if (e.button === 1 || this.spacePressed) {
	                    e.preventDefault();
	                    this.isPanning = true;
	                    this.dragStart = { x: mouseX, y: mouseY };
	                    document.getElementById('canvas-container').classList.add('grabbing');
	                    return;
	                }

	                // Herramienta Punto (Punto de Informaci√≥n / L√°mina): click para colocar
	                if (this.tool === 'poi' && e.button === 0) {
	                    const cp = this.createControlPointAt(worldPos.x, worldPos.y);
	                    this.elements.push(cp);
	                    this.selectedElements = [cp];
	                    this.ensureControlPointOrders(this.elements);
	                    this.saveHistory();
	                    this.updatePropertiesPanel();
	                    this.updateStatusBar();
	                    this.setTool('select');
	                    return;
	                }

	                // Herramienta Pintar (bote): click para aplicar relleno al elemento bajo el cursor.
	                if (this.tool === 'bucket' && e.button === 0) {
	                    const clicked = this.getElementAt(worldPos.x, worldPos.y);
	                    if (clicked && !clicked.locked) {
	                        this.selectedElements = [clicked];
	                        this.applyBucketFillToElement(clicked);
	                        this.saveHistory();
	                        this.updatePropertiesPanel();
	                        this.updateStatusBar();
	                    }
	                    return;
	                }
	                
	                if (this.tool === 'select') {
	                    // Verificar si estamos sobre un handle de redimensionamiento
	                    const handleInfo = this.getResizeHandleAt(worldPos.x, worldPos.y);
	                    if (handleInfo) {
                        this.resizingElement = handleInfo.element;
                        this.resizeHandle = handleInfo.handle;
                        this.dragStart = { x: worldPos.x, y: worldPos.y };
                        return;
                    }
                    
                    const clicked = this.getElementAt(worldPos.x, worldPos.y);
                    
                    if (clicked) {
                        if (!e.ctrlKey && !this.selectedElements.includes(clicked)) {
                            this.selectedElements = [clicked];
                        } else if (e.ctrlKey) {
                            const idx = this.selectedElements.indexOf(clicked);
                            if (idx >= 0) {
                                this.selectedElements.splice(idx, 1);
                            } else {
                                this.selectedElements.push(clicked);
                            }
                        }
                        
                        this.isDragging = true;
                        this.dragStart = { x: worldPos.x, y: worldPos.y };
                        this.updatePropertiesPanel();
                    } else {
                        // Marco de selecci√≥n (marquee) al arrastrar en vac√≠o
                        if (e.button === 0) {
                            const additive = Boolean(e.ctrlKey);
                            const base = additive ? (Array.isArray(this.selectedElements) ? [...this.selectedElements] : []) : [];
                            this.selectionBox = {
                                start: { x: worldPos.x, y: worldPos.y },
                                end: { x: worldPos.x, y: worldPos.y },
                                additive,
                                base
                            };
                            if (!additive) {
                                this.selectedElements = [];
                                this.hidePropertiesPanel();
                            }
                            this.updateLayersSelectionHighlight();
                        } else if (!e.ctrlKey) {
                            this.selectedElements = [];
                            this.hidePropertiesPanel();
                        }
                    }
                } else if (this.tool === 'pencil') {
                    // Iniciar dibujo libre
                    this.drawingPath = {
                        type: 'path',
                        id: Date.now() + Math.random(),
                        points: [{ x: worldPos.x, y: worldPos.y }],
                        strokeColor: '#e94560',
                        lineWidth: 3,
                        locked: false,
                        active: true,
                        connectionStatus: 'none',
                        fillColor: 'transparent',
                        name: '',
                        closed: false
                    };
                    
                    // Mostrar hint de cerrar path
                    document.getElementById('close-path-hint').classList.add('show');
                } else {
                    // Crear nuevo elemento
                    this.dragStart = { x: worldPos.x, y: worldPos.y };
                    this.tempElement = this.createElementAt(worldPos.x, worldPos.y);
                }
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                // Actualizar posici√≥n del cursor
                document.getElementById('cursor-pos').textContent = 
                    `X: ${Math.round(worldPos.x)}, Y: ${Math.round(worldPos.y)}`;

                // Marco de selecci√≥n (marquee)
                if (this.selectionBox && !this.readOnly) {
                    this.selectionBox.end = { x: worldPos.x, y: worldPos.y };
                    this.updateBoxSelectionFromMarquee();
                    this.canvas.style.cursor = 'crosshair';
                    return;
                }
                
                // Pan
                if (this.isPanning) {
                    this.camera.x += mouseX - this.dragStart.x;
                    this.camera.y += mouseY - this.dragStart.y;
                    this.dragStart = { x: mouseX, y: mouseY };
                    return;
                }

                // Modo visor: no hay hover/handles; cursor depende del tipo (deck permite "puntos de control").
                if (this.readOnly) {
                    if (this.viewerMode === 'deck') {
                        this.hoveredElement = this.getElementAt(worldPos.x, worldPos.y);
                        const isCp = this.hoveredElement && this.isControlPoint(this.hoveredElement);
                        this.canvas.style.cursor = isCp ? 'pointer' : 'grab';
                    } else {
                        this.canvas.style.cursor = 'grab';
                    }
                    return;
                }
                
                // Redimensionar elemento
                if (this.resizingElement) {
                    this.resizeElement(this.resizingElement, this.resizeHandle, worldPos);
                    return;
                }
                
                // Dibujo libre
                if (this.drawingPath) {
                    const firstPoint = this.drawingPath.points[0];
                    const distance = Math.sqrt(
                        Math.pow(worldPos.x - firstPoint.x, 2) + 
                        Math.pow(worldPos.y - firstPoint.y, 2)
                    );
                    
                    // Detectar si estamos cerca del punto inicial para cerrar
                    if (this.drawingPath.points.length > 3 && distance < this.autoClosePathDistance) {
                        this.drawingPath.nearStart = true;
                    } else {
                        this.drawingPath.nearStart = false;
                        this.drawingPath.points.push({ x: worldPos.x, y: worldPos.y });
                    }
                    return;
                }
                
                // Drag elementos
                if (this.isDragging && this.tool === 'select') {
                    const dx = worldPos.x - this.dragStart.x;
                    const dy = worldPos.y - this.dragStart.y;
                    
                    this.selectedElements.forEach(elem => {
                        if (!elem.locked) {
                            this.offsetElement(elem, dx, dy);
                        }
                    });
                    
                    this.dragStart = { x: worldPos.x, y: worldPos.y };
                }
                
                // Dibujar elemento temporal
                if (this.tempElement) {
                    if (this.tool === 'rectangle' || this.tool === 'circle') {
                        this.tempElement.width = worldPos.x - this.tempElement.x;
                        this.tempElement.height = worldPos.y - this.tempElement.y;
                    } else if (this.tool === 'shape') {
                        this.tempElement.points = this.buildShapePoints(
                            this.tempElement.shapeType || this.shapeType,
                            this.dragStart.x,
                            this.dragStart.y,
                            worldPos.x,
                            worldPos.y
                        );
                    } else if (this.tool === 'line' || this.tool === 'route') {
                        this.tempElement.endX = worldPos.x;
                        this.tempElement.endY = worldPos.y;
                    }
                }
                
                // Hover
                this.hoveredElement = this.getElementAt(worldPos.x, worldPos.y);
                
                // Actualizar cursor si est√° sobre un handle
                const handleInfo = this.getResizeHandleAt(worldPos.x, worldPos.y);
                if (handleInfo) {
                    this.canvas.style.cursor = this.getResizeCursor(handleInfo.handle);
                } else if (this.tool === 'select' && !this.isDragging) {
                    this.canvas.style.cursor = this.hoveredElement ? 'move' : 'default';
                } else if (this.tool === 'pencil') {
                    this.canvas.style.cursor = 'crosshair';
                }
            }
            
            onMouseUp(e) {
                // Finalizar marco de selecci√≥n
                if (this.selectionBox && !this.readOnly) {
                    this.updateBoxSelectionFromMarquee({ finalize: true });
                    this.selectionBox = null;
                    // Mostrar panel solo si hay un elemento seleccionado.
                    this.updatePropertiesPanel();
                }

                if (this.isPanning) {
                    this.isPanning = false;
                    document.getElementById('canvas-container').classList.remove('grabbing');
                }
                
                if (this.resizingElement) {
                    this.normalizeBoxElementInPlace(this.resizingElement);
                    this.resizingElement = null;
                    this.resizeHandle = null;
                    this.saveHistory();
                }
                
                if (this.drawingPath) {
                    // Ocultar hint
                    document.getElementById('close-path-hint').classList.remove('show');
                    
                    // Solo agregar el path si tiene m√°s de 2 puntos
                    if (this.drawingPath.points.length > 2) {
                        // Si est√° cerca del inicio, cerrar la figura
                        if (this.drawingPath.nearStart) {
                            this.drawingPath.closed = true;
                            this.drawingPath.fillColor = '#0f3460'; // Darle color de relleno
                            // Convertir a tipo 'polygon' para que tenga propiedades editables
                            this.drawingPath.type = 'polygon';
                        }
                        
                        this.elements.push(this.drawingPath);
                        this.saveHistory();
                    }
                    this.drawingPath = null;
                }
                
                if (this.tempElement) {
                    this.normalizeBoxElementInPlace(this.tempElement);
                    this.elements.push(this.tempElement);
                    this.saveHistory();
                    this.tempElement = null;
                    this.setTool('select');
                }
                
                this.isDragging = false;
                this.canvas.style.cursor = this.readOnly ? 'grab' : 'default';
                this.updateStatusBar();
            }
            
            onClick(e) {
                if (this.readOnly) return;

                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                const element = this.getElementAt(worldPos.x, worldPos.y);
                
                // Toggle activaci√≥n con doble click
                if (element && e.detail === 2) {
                    element.active = !element.active;
                }
            }
            
            onWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                const newZoom = Math.max(0.1, Math.min(5, this.camera.zoom * zoomFactor));
                
                // Zoom hacia el cursor
                const worldBefore = this.screenToWorld(mouseX, mouseY);
                this.camera.zoom = newZoom;
                const worldAfter = this.screenToWorld(mouseX, mouseY);
                
                this.camera.x += (worldAfter.x - worldBefore.x) * this.camera.zoom;
                this.camera.y += (worldAfter.y - worldBefore.y) * this.camera.zoom;
                
                this.updateZoomIndicator();
            }
            
            onKeyDown(e) {
                if (this.readOnly) {
                    // En modo visor solo permitimos navegaci√≥n (pan/zoom) y evitamos crear/modificar elementos.
                    switch (e.key) {
                        case '+':
                        case '=':
                            e.preventDefault();
                            this.zoomIn();
                            break;
                        case '-':
                            e.preventDefault();
                            this.zoomOut();
                            break;
                        case '0':
                            e.preventDefault();
                            this.resetZoom();
                            break;
                        case 'ArrowUp':
                        case 'ArrowDown':
                        case 'ArrowLeft':
                        case 'ArrowRight': {
                            e.preventDefault();
                            const step = e.shiftKey ? 120 : (e.altKey ? 10 : 40);
                            if (e.key === 'ArrowUp') this.camera.y -= step;
                            if (e.key === 'ArrowDown') this.camera.y += step;
                            if (e.key === 'ArrowLeft') this.camera.x -= step;
                            if (e.key === 'ArrowRight') this.camera.x += step;
                            break;
                        }
                    }
                    return;
                }

                // No capturar atajos cuando el usuario est√° escribiendo en inputs/textarea/select
                // o cuando hay un modal abierto (para permitir pegar llaves/paths sin abrir herramientas).
                const target = e.target;
                const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
                const isFormField =
                    tag === 'input' ||
                    tag === 'textarea' ||
                    tag === 'select' ||
                    (target && target.isContentEditable);

                const anyModalOpen = Boolean(document.querySelector('.modal.show'));
                if (isFormField || anyModalOpen) {
                    // Permitir cerrar modales con Escape.
                    if (anyModalOpen && e.key === 'Escape') {
                        const publishModal = document.getElementById('publish-modal');
                        if (publishModal && publishModal.classList.contains('show')) this.hidePublishModal();

                        const libraryModal = document.getElementById('library-modal');
                        if (libraryModal && libraryModal.classList.contains('show')) this.hideLibraryModal();

                        const saveModal = document.getElementById('save-modal');
                        if (saveModal && saveModal.classList.contains('show')) this.hideSaveModal();

                        e.preventDefault();
                    }
                    return;
                }

                // Detectar espacio para pan
                if (e.code === 'Space' && !this.spacePressed) {
                    this.spacePressed = true;
                    document.getElementById('canvas-container').classList.add('pan-mode');
                    e.preventDefault();
                    return;
                }

                // Flechas: si hay selecci√≥n ‚Üí nudge; si no ‚Üí pan del canvas.
                if (!e.ctrlKey && !e.metaKey &&
                    (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                    e.preventDefault();

                    const hasSelection = Array.isArray(this.selectedElements) && this.selectedElements.length > 0;
                    if (hasSelection) {
                        const px = e.shiftKey ? 10 : (e.altKey ? 0.25 : 1);
                        const dx = (e.key === 'ArrowLeft' ? -px : (e.key === 'ArrowRight' ? px : 0)) / (this.camera.zoom || 1);
                        const dy = (e.key === 'ArrowUp' ? -px : (e.key === 'ArrowDown' ? px : 0)) / (this.camera.zoom || 1);

                        let movedAny = false;
                        this.selectedElements.forEach((elem) => {
                            if (!elem || typeof elem !== 'object') return;
                            if (elem.locked) return;
                            this.offsetElement(elem, dx, dy);
                            movedAny = true;
                        });

                        if (movedAny) this.scheduleNudgeHistorySave();
                    } else {
                        const step = e.shiftKey ? 120 : (e.altKey ? 10 : 40);
                        if (e.key === 'ArrowUp') this.camera.y -= step;
                        if (e.key === 'ArrowDown') this.camera.y += step;
                        if (e.key === 'ArrowLeft') this.camera.x -= step;
                        if (e.key === 'ArrowRight') this.camera.x += step;
                    }
                    return;
                }
                
                // Atajos de teclado
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key.toLowerCase()) {
                        case 'c':
                            e.preventDefault();
                            this.copyElements();
                            break;
                        case 'v':
                            e.preventDefault();
                            this.pasteElements();
                            break;
                        case 's':
                            e.preventDefault();
                            this.showSaveModal();
                            break;
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'g':
                            e.preventDefault();
                            this.groupElements();
                            break;
                        case 'l':
                            e.preventDefault();
                            this.toggleLock();
                            break;
                    }
                } else {
                    switch(e.key) {
                        case 'Delete':
                        case 'Backspace':
                            e.preventDefault();
                            this.deleteElements();
                            break;
                        case 'v':
                            this.setTool('select');
                            break;
                        case 'r':
                            this.setTool('rectangle');
                            break;
                        case 'c':
                            this.setTool('circle');
                            break;
	                        case 't':
	                            this.setTool('shape');
	                            break;
	                        case 'k':
	                            this.setTool('poi');
	                            break;
	                        case 'l':
	                            this.setTool('line');
	                            break;
                        case 'u':
                            this.setTool('route');
                            break;
                        case 'n':
                            this.setTool('mover-metro');
                            break;
                        case 'h':
                            this.setTool('mover-male');
                            break;
                        case 'j':
                            this.setTool('mover-female');
                            break;
                        case 'q':
                            this.setTool('portal-in');
                            break;
                        case 'w':
                            this.setTool('portal-out');
                            break;
                        case 'p':
                            this.setTool('pencil');
                            break;
                        case 'i':
                            this.insertImage();
                            break;
	                        case 'm':
	                            this.insertVideo();
	                            break;
	                        case 'b':
	                            this.setTool('bucket');
	                            break;
	                        case 'o':
	                        case 'O':
	                            this.toggleLayersPanel();
	                            break;
                        case '+':
                        case '=':
                            this.zoomIn();
                            break;
                        case '-':
                            this.zoomOut();
                            break;
                        case '0':
                            this.resetZoom();
                            break;
                    }
                }
            }
            
            onKeyUp(e) {
                if (this.readOnly) return;

                if (e.code === 'Space') {
                    this.spacePressed = false;
                    document.getElementById('canvas-container').classList.remove('pan-mode');
                }
            }
            
            // ==================== INSERCI√ìN DE IM√ÅGENES ====================
            
            insertImage() {
                document.getElementById('image-input').click();
            }
            
            loadImageFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Crear elemento de imagen en el canvas
                        const imageElement = {
                            type: 'image',
                            id: Date.now() + Math.random(),
                            x: -this.camera.x / this.camera.zoom,
                            y: -this.camera.y / this.camera.zoom,
                            width: img.width,
                            height: img.height,
                            originalWidth: img.width,
                            originalHeight: img.height,
                            imageSrc: event.target.result,
                            imageData: img,
                            locked: false,
                            active: true,
                            connectionStatus: 'none',
                            fillColor: 'transparent',
                            strokeColor: 'transparent',
                            name: file.name,
                            opacity: 1,
                            zIndex: this.elements.length // Al fondo inicialmente
                        };
                        
                        // Guardar en cache
                        this.loadedImages[imageElement.id] = img;
                        
                        this.elements.push(imageElement);
                        this.selectedElements = [imageElement];
                        this.saveHistory();
                        this.updatePropertiesPanel();
                        // Autoajuste inicial del PNG para que la caja se acerque al contorno real.
                        setTimeout(() => {
                            this.autoTrimSelectedImageToAlpha().catch(() => {});
                        }, 0);
                        
                        // Ordenar elementos por zIndex
                        this.sortElementsByZIndex();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            }

            // ==================== INSERCI√ìN DE VIDEO ====================

            insertVideo() {
                const raw = prompt(
                    'Pega una URL directa a video (mp4/webm) o deja vac√≠o para elegir un archivo local.\n' +
                    'Nota: videos locales (blob:) no se conservan bien al exportar/publicar; para compartir usa URL.',
                    ''
                );
                if (raw === null) return;
                const s = String(raw || '').trim();
                if (s) {
                    const name = s.split('?')[0].split('#')[0].split('/').pop() || 'video';
                    this.createVideoElementFromSrc(s, { name });
                    return;
                }
                document.getElementById('video-input').click();
            }

            loadVideoFile(e) {
                const file = e.target.files[0];
                if (!file) return;

                const objectUrl = URL.createObjectURL(file);
                this.createVideoElementFromSrc(objectUrl, { name: file.name, isObjectUrl: true });

                // Permitir re-seleccionar el mismo archivo.
                e.target.value = '';
            }

            createVideoElementFromSrc(src, options) {
                const opts = options && typeof options === 'object' ? options : {};
                const id = Date.now() + Math.random();

                const vid = document.createElement('video');
                vid.src = String(src || '');
                vid.loop = true;
                vid.muted = true;
                vid.playsInline = true;
                vid.preload = 'auto';

                const x = -this.camera.x / this.camera.zoom;
                const y = -this.camera.y / this.camera.zoom;

                // Insertar de inmediato con tama√±o placeholder (se ajusta al cargar metadata).
                const placeholderW = 640;
                const placeholderH = 360;
                const videoElement = {
                    type: 'video',
                    id,
                    x,
                    y,
                    width: placeholderW,
                    height: placeholderH,
                    originalWidth: placeholderW,
                    originalHeight: placeholderH,
                    videoSrc: String(src || ''),
                    videoData: vid,
                    loop: true,
                    muted: true,
                    autoplay: true,
                    locked: false,
                    active: true,
                    connectionStatus: 'loading',
                    fillColor: 'transparent',
                    strokeColor: 'transparent',
                    name: typeof opts.name === 'string' ? opts.name : 'video',
                    opacity: 1,
                    zIndex: this.elements.length
                };

                this.loadedVideos[videoElement.id] = vid;
                this.elements.push(videoElement);
                this.selectedElements = [videoElement];
                this.saveHistory();
                this.updatePropertiesPanel();
                this.sortElementsByZIndex();

                const tryPlay = () => {
                    if (videoElement.active === false) return;
                    if (vid.paused) {
                        const p = vid.play();
                        if (p && typeof p.catch === 'function') p.catch(() => {});
                    }
                };

                let metaApplied = false;
                const applyMeta = () => {
                    if (metaApplied) return;
                    metaApplied = true;

                    const vw = Number(vid.videoWidth) || placeholderW;
                    const vh = Number(vid.videoHeight) || placeholderH;

                    videoElement.originalWidth = vw;
                    videoElement.originalHeight = vh;

                    // Si el usuario no lo redimension√≥ a√∫n, ajustamos al tama√±o real.
                    if (videoElement.width === placeholderW && videoElement.height === placeholderH) {
                        videoElement.width = vw;
                        videoElement.height = vh;
                    }

                    videoElement.connectionStatus = 'connected';
                    tryPlay();
                };

                vid.addEventListener('loadedmetadata', applyMeta, { once: true });
                vid.addEventListener('canplay', tryPlay);
                vid.addEventListener('error', () => {
                    videoElement.connectionStatus = 'error';
                });

                // Algunos navegadores requieren load() expl√≠cito.
                try { vid.load(); } catch {}
            }
            
            sortElementsByZIndex() {
                this.elements.sort((a, b) => {
                    const zA = a.zIndex !== undefined ? a.zIndex : this.elements.indexOf(a);
                    const zB = b.zIndex !== undefined ? b.zIndex : this.elements.indexOf(b);
                    return zA - zB;
                });
            }
            
            // ==================== GESTI√ìN DE CAPAS (Z-INDEX) ====================
            
            bringToFront() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const currentIndex = this.elements.indexOf(elem);
                    if (currentIndex < this.elements.length - 1) {
                        // Intercambiar con el siguiente
                        const nextElem = this.elements[currentIndex + 1];
                        this.elements[currentIndex] = nextElem;
                        this.elements[currentIndex + 1] = elem;
                    }
                });
                
                this.saveHistory();
            }
            
            sendToBack() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const currentIndex = this.elements.indexOf(elem);
                    if (currentIndex > 0) {
                        // Intercambiar con el anterior
                        const prevElem = this.elements[currentIndex - 1];
                        this.elements[currentIndex] = prevElem;
                        this.elements[currentIndex - 1] = elem;
                    }
                });
                
                this.saveHistory();
            }
            
            bringToFrontComplete() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const index = this.elements.indexOf(elem);
                    if (index >= 0) {
                        this.elements.splice(index, 1);
                        this.elements.push(elem);
                    }
                });
                
                this.saveHistory();
            }
            
            sendToBackComplete() {
                if (this.selectedElements.length === 0) return;
                
                this.selectedElements.forEach(elem => {
                    const index = this.elements.indexOf(elem);
                    if (index >= 0) {
                        this.elements.splice(index, 1);
                        this.elements.unshift(elem);
                    }
                });
                
                this.saveHistory();
            }
            
	            duplicateSelected() {
	                if (this.selectedElements.length === 0) return;
	                
	                const duplicates = [];
	                this.selectedElements.forEach(elem => {
	                    const duplicate = JSON.parse(JSON.stringify(elem, (key, value) => {
	                        if (key === 'imageData') return undefined;
	                        if (key === 'videoData') return undefined;
	                        return value;
	                    }));
	                    const idMap = this.assignNewIdsRecursive(duplicate);
	                    
	                    // Copiar referencias de im√°genes (si aplica)
	                    idMap.forEach((newId, oldId) => {
	                        if (this.loadedImages[oldId]) {
                            this.loadedImages[newId] = this.loadedImages[oldId];
                        }
                    });
                    
                    // Mover ligeramente para evitar overlap
                    this.offsetElement(duplicate, 20, 20);
                    
                    duplicates.push(duplicate);
                });
                
                this.elements.push(...duplicates);
                this.selectedElements = duplicates;
                this.saveHistory();
                this.updatePropertiesPanel();
            }

            async saveSelectionAsGroupedLibrary() {
                if (this.readOnly) return;
                if (!Array.isArray(this.selectedElements) || this.selectedElements.length === 0) {
                    alert('Selecciona uno o m√°s elementos para guardar.');
                    return;
                }

                const selectedClone = JSON.parse(JSON.stringify(this.selectedElements, (key, value) => {
                    if (key === 'imageData' || key === 'videoData') return undefined;
                    return value;
                }));

                if (this.hasImagesInElements(selectedClone)) {
                    const doConvert = confirm(
                        'La selecci√≥n incluye im√°genes/video.\n\n' +
                        '¬øQuieres convertir autom√°ticamente las im√°genes PNG a pol√≠gonos vectoriales para guardar en "agrupados"?'
                    );
                    if (!doConvert) {
                        alert('No se puede guardar en "agrupados" si incluye im√°genes/video. Usa vector puro.');
                        return;
                    }

                    const conversion = await this.convertImagesInElementsToVectorPolygons(selectedClone);
                    if (conversion.converted > 0) {
                        // seguir: selectedClone ya convertido parcialmente
                    }
                    if (this.hasImagesInElements(selectedClone)) {
                        alert(
                            'No se pudo convertir todo a vector puro.\n' +
                            `Convertidos: ${conversion.converted} | Fallidos: ${conversion.failed}\n` +
                            'Tip: usa "Autoajustar PNG" y luego "Convertir PNG a vector" sobre cada imagen.'
                        );
                        return;
                    }
                }

                const defaultName =
                    this.selectedElements.length === 1
                        ? (String(this.selectedElements[0].name || '').trim() || 'agrupado')
                        : `agrupado-${Date.now()}`;
                const nameInput = prompt('Nombre del agrupado:', defaultName);
                if (nameInput === null) return;
                const name = String(nameInput || '').trim() || defaultName;

                const payload = {
                    name,
                    elements: selectedClone,
                    camera: { x: 0, y: 0, zoom: 1 },
                    folder: 'grouped',
                    tags: ['grouped', 'quick-save']
                };

                let response;
                let data;
                try {
                    response = await fetch('/api/publish-grouped', {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    data = await response.json();
                } catch (error) {
                    alert(`Error de red al guardar agrupado: ${error}`);
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const msg = (data && data.error) ? data.error : `HTTP ${response.status}`;
                    alert(`No se pudo guardar agrupado: ${msg}`);
                    return;
                }

                this.updateStatusBar();
                alert(`Guardado en biblioteca/agrupados:\nID: ${data.id}`);
            }
            
            showContextMenu(x, y) {
                const menu = document.getElementById('context-menu');
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';

                // Mostrar/ocultar items seg√∫n el tipo seleccionado.
                const sel = (this.selectedElements && this.selectedElements.length === 1) ? this.selectedElements[0] : null;
                const canCrop = sel && (sel.type === 'image' || sel.type === 'video');
                const canImageOps = sel && sel.type === 'image';
                const cropItem = document.getElementById('ctx-crop');
                if (cropItem) cropItem.style.display = canCrop ? 'block' : 'none';
                const trimItem = document.getElementById('ctx-auto-trim-image');
                if (trimItem) trimItem.style.display = canImageOps ? 'block' : 'none';
                const vectorizeItem = document.getElementById('ctx-vectorize-image');
                if (vectorizeItem) vectorizeItem.style.display = canImageOps ? 'block' : 'none';
                const saveGroupedItem = document.getElementById('ctx-save-grouped');
                if (saveGroupedItem) saveGroupedItem.style.display = (this.selectedElements && this.selectedElements.length > 0) ? 'block' : 'none';

                menu.classList.add('show');
            }
            
            hideContextMenu() {
                document.getElementById('context-menu').classList.remove('show');
            }

            changeLineWidth() {
                if (this.readOnly) return;
                if (!this.selectedElements || this.selectedElements.length === 0) return;

                const current = this.getElementLineWidth(this.selectedElements[0]);
                const newWidth = prompt('Nuevo ancho de l√≠nea (1-20):', String(current));
                if (newWidth === null) return;

                const width = Math.max(1, Math.min(20, Number.parseInt(String(newWidth), 10) || current));
                this.selectedElements.forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;
                    if (!this.elementSupportsLineWidth(elem)) return;
                    elem.lineWidth = width;
                });
                this.updatePropertiesPanel();
            }

	            cropSelectedElement() {
	                if (this.readOnly) return;
	                if (!this.selectedElements || this.selectedElements.length !== 1) return;
	                const elem = this.selectedElements[0];
	                if (!elem || typeof elem !== 'object') return;
	                if (elem.type !== 'image' && elem.type !== 'video') return;

                const cur = (elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) ? elem.crop : null;
                const defX = cur && Number.isFinite(cur.x) ? cur.x : 0;
                const defY = cur && Number.isFinite(cur.y) ? cur.y : 0;
                const defW = cur && Number.isFinite(cur.w) ? cur.w : 1;
                const defH = cur && Number.isFinite(cur.h) ? cur.h : 1;
                const def = [
                    Math.round(defX * 100),
                    Math.round(defY * 100),
                    Math.round(defW * 100),
                    Math.round(defH * 100)
                ].join(',');

                const raw = prompt(
                    'Recorte (x,y,w,h) en % (0-100). Ej: 0,0,100,100\n' +
                    'Tip: deja vac√≠o para resetear.',
                    def
                );
                if (raw === null) return;
                const s = String(raw || '').trim();
                if (!s) {
                    delete elem.crop;
                    this.saveHistory();
                    this.updatePropertiesPanel();
                    return;
                }

                const parts = s.split(/[,\s]+/).filter(Boolean);
                if (parts.length !== 4) {
                    alert('Formato inv√°lido. Usa 4 n√∫meros: x,y,w,h');
                    return;
                }
                const nums = parts.map((p) => Number.parseFloat(String(p)));
                if (nums.some((n) => !Number.isFinite(n))) {
                    alert('Valores inv√°lidos. Usa n√∫meros (ej: 0,0,100,100).');
                    return;
                }

                let [x, y, w, h] = nums;
                const looksLikeRatio = x >= 0 && x <= 1 && y >= 0 && y <= 1 && w >= 0 && w <= 1 && h >= 0 && h <= 1;
                if (!looksLikeRatio) {
                    x /= 100; y /= 100; w /= 100; h /= 100;
                }

                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                w = Math.max(0, Math.min(1, w));
                h = Math.max(0, Math.min(1, h));

                // Mantener el recorte dentro del rango [0..1]
                if (x + w > 1) w = Math.max(0, 1 - x);
                if (y + h > 1) h = Math.max(0, 1 - y);

                if (w <= 0 || h <= 0) {
                    alert('Recorte inv√°lido (w/h <= 0).');
                    return;
                }

	                elem.crop = { x, y, w, h };
	                this.saveHistory();
	                this.updatePropertiesPanel();
	            }

            async getRenderableImageForElement(elem) {
                if (!elem || typeof elem !== 'object' || elem.type !== 'image') return null;

                const isHtmlImage = (v) =>
                    v && typeof HTMLImageElement !== 'undefined' && v instanceof HTMLImageElement;

                let img = elem.imageData;
                if (img && !isHtmlImage(img)) {
                    img = null;
                    try { delete elem.imageData; } catch {}
                }

                if (!img && this.loadedImages[elem.id] && isHtmlImage(this.loadedImages[elem.id])) {
                    img = this.loadedImages[elem.id];
                }

                if (img && img.complete) {
                    elem.imageData = img;
                    this.loadedImages[elem.id] = img;
                    return img;
                }

                if (!elem.imageSrc || typeof elem.imageSrc !== 'string') return null;

                img = await new Promise((resolve) => {
                    try {
                        const i = new Image();
                        i.onload = () => resolve(i);
                        i.onerror = () => resolve(null);
                        i.src = elem.imageSrc;
                    } catch {
                        resolve(null);
                    }
                });

                if (img) {
                    elem.imageData = img;
                    this.loadedImages[elem.id] = img;
                }
                return img;
            }

            getImageRenderMetrics(elem, img) {
                const sw = Math.max(1, Number(img && (img.naturalWidth || img.width)) || 1);
                const sh = Math.max(1, Number(img && (img.naturalHeight || img.height)) || 1);
                const crop = (elem && elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) ? elem.crop : null;
                let sx = 0;
                let sy = 0;
                let sww = sw;
                let shh = sh;

                if (crop && Number.isFinite(crop.x) && Number.isFinite(crop.y) &&
                    Number.isFinite(crop.w) && Number.isFinite(crop.h) &&
                    crop.w > 0 && crop.h > 0) {
                    sx = Math.max(0, Math.min(sw, crop.x * sw));
                    sy = Math.max(0, Math.min(sh, crop.y * sh));
                    sww = Math.max(1, Math.min(sw - sx, crop.w * sw));
                    shh = Math.max(1, Math.min(sh - sy, crop.h * sh));
                }

                return { sw, sh, sx, sy, sww, shh };
            }

            buildAlphaContourFromImageElement(elem, options) {
                if (!elem || typeof elem !== 'object' || elem.type !== 'image') return null;
                const opts = options && typeof options === 'object' ? options : {};
                const alphaThreshold = Number.isFinite(opts.alphaThreshold) ? Number(opts.alphaThreshold) : 20;
                const maxTraceSize = Number.isFinite(opts.maxTraceSize) ? Number(opts.maxTraceSize) : 420;
                const rowStep = Math.max(1, Number.isFinite(opts.rowStep) ? Number(opts.rowStep) : 2);
                const maxPoints = Math.max(20, Number.isFinite(opts.maxPoints) ? Number(opts.maxPoints) : 220);

                const img = this.loadedImages[elem.id] || elem.imageData;
                if (!img) return null;

                const m = this.getImageRenderMetrics(elem, img);
                const scale = Math.min(1, maxTraceSize / Math.max(m.sww, m.shh));
                const tw = Math.max(1, Math.round(m.sww * scale));
                const th = Math.max(1, Math.round(m.shh * scale));

                const cv = document.createElement('canvas');
                cv.width = tw;
                cv.height = th;
                const cx = cv.getContext('2d', { willReadFrequently: true });
                if (!cx) return null;
                cx.clearRect(0, 0, tw, th);
                cx.drawImage(img, m.sx, m.sy, m.sww, m.shh, 0, 0, tw, th);

                let data;
                try {
                    data = cx.getImageData(0, 0, tw, th).data;
                } catch {
                    return null;
                }

                const alphaAt = (x, y) => data[((y * tw + x) * 4) + 3];

                let minX = tw, minY = th, maxX = -1, maxY = -1;
                const leftPts = [];
                const rightPts = [];

                for (let y = 0; y < th; y += rowStep) {
                    let left = -1;
                    let right = -1;
                    for (let x = 0; x < tw; x++) {
                        if (alphaAt(x, y) > alphaThreshold) {
                            left = x;
                            break;
                        }
                    }
                    if (left < 0) continue;
                    for (let x = tw - 1; x >= 0; x--) {
                        if (alphaAt(x, y) > alphaThreshold) {
                            right = x;
                            break;
                        }
                    }
                    if (right < left) right = left;

                    minX = Math.min(minX, left);
                    maxX = Math.max(maxX, right);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);

                    leftPts.push({ x: left, y });
                    rightPts.push({ x: right, y });
                }

                if (maxX < minX || maxY < minY || leftPts.length < 2) return null;

                let contour = leftPts.concat(rightPts.slice().reverse());
                if (contour.length > maxPoints) {
                    const skip = Math.ceil(contour.length / maxPoints);
                    contour = contour.filter((_, i) => i % skip === 0);
                }

                if (contour.length < 3) return null;

                const relMinX = minX / tw;
                const relMinY = minY / th;
                const relMaxX = (maxX + 1) / tw;
                const relMaxY = (maxY + 1) / th;

                const worldPts = contour.map((p) => ({
                    x: elem.x + (p.x / tw) * elem.width,
                    y: elem.y + (p.y / th) * elem.height
                }));

                return {
                    worldPoints: worldPts,
                    relBounds: {
                        x: relMinX,
                        y: relMinY,
                        w: Math.max(0, relMaxX - relMinX),
                        h: Math.max(0, relMaxY - relMinY)
                    },
                    metrics: m
                };
            }

            async autoTrimSelectedImageToAlpha() {
                if (this.readOnly) return;
                if (!this.selectedElements || this.selectedElements.length !== 1) return;
                const elem = this.selectedElements[0];
                if (!elem || elem.type !== 'image') return;
                if (elem.locked) return;

                const img = await this.getRenderableImageForElement(elem);
                if (!img) {
                    alert('No se pudo cargar la imagen para autoajuste.');
                    return;
                }

                const traced = this.buildAlphaContourFromImageElement(elem, { maxTraceSize: 420, rowStep: 2 });
                if (!traced || !traced.relBounds || traced.relBounds.w <= 0 || traced.relBounds.h <= 0) {
                    alert('No se detect√≥ contorno alfa √∫til para autoajuste.');
                    return;
                }

                const m = traced.metrics;
                const rb = traced.relBounds;

                const newSx = m.sx + rb.x * m.sww;
                const newSy = m.sy + rb.y * m.shh;
                const newSww = Math.max(1, rb.w * m.sww);
                const newShh = Math.max(1, rb.h * m.shh);

                const oldX = Number(elem.x) || 0;
                const oldY = Number(elem.y) || 0;
                const oldW = Number(elem.width) || 1;
                const oldH = Number(elem.height) || 1;
                const newX = oldX + rb.x * oldW;
                const newY = oldY + rb.y * oldH;
                const newW = Math.max(1, rb.w * oldW);
                const newH = Math.max(1, rb.h * oldH);

                elem.x = newX;
                elem.y = newY;
                elem.width = newW;
                elem.height = newH;
                elem.crop = {
                    x: Math.max(0, Math.min(1, newSx / m.sw)),
                    y: Math.max(0, Math.min(1, newSy / m.sh)),
                    w: Math.max(0.0001, Math.min(1, newSww / m.sw)),
                    h: Math.max(0.0001, Math.min(1, newShh / m.sh))
                };

                this.normalizeBoxElementInPlace(elem);
                this.saveHistory();
                this.updatePropertiesPanel();
            }

            async convertSelectedImageToVectorPolygon() {
                if (this.readOnly) return;
                if (!this.selectedElements || this.selectedElements.length !== 1) return;
                const elem = this.selectedElements[0];
                if (!elem || elem.type !== 'image') return;
                if (elem.locked) return;

                const img = await this.getRenderableImageForElement(elem);
                if (!img) {
                    alert('No se pudo cargar la imagen para vectorizar.');
                    return;
                }

                const traced = this.buildAlphaContourFromImageElement(elem, { maxTraceSize: 460, rowStep: 2, maxPoints: 260 });
                if (!traced || !Array.isArray(traced.worldPoints) || traced.worldPoints.length < 3) {
                    alert('No se pudo extraer contorno vectorial del PNG.');
                    return;
                }

                const idx = this.elements.indexOf(elem);
                if (idx < 0) return;

                const poly = this.buildVectorPolygonFromImageElement(elem, traced);

                this.elements[idx] = poly;
                this.selectedElements = [poly];
                this.saveHistory();
                this.updatePropertiesPanel();
                alert('PNG convertido a pol√≠gono vectorial. Ahora s√≠ se puede guardar en Agrupados.');
            }

            buildVectorPolygonFromImageElement(elem, traced) {
                return {
                    id: elem.id,
                    type: 'polygon',
                    points: traced.worldPoints,
                    lineWidth: 2,
                    fillColor: 'transparent',
                    strokeColor: this.isTransparentColor(elem.strokeColor) ? '#e94560' : elem.strokeColor,
                    locked: false,
                    active: elem.active !== false,
                    connectionStatus: elem.connectionStatus || 'none',
                    name: (String(elem.name || '').replace(/\.[a-z0-9]+$/i, '') || 'vectorizado') + '-vector',
                    closed: true
                };
            }

            async convertImagesInElementsToVectorPolygons(elements) {
                const stats = { converted: 0, failed: 0 };
                const walk = async (arr) => {
                    if (!Array.isArray(arr)) return;
                    for (let i = 0; i < arr.length; i++) {
                        const elem = arr[i];
                        if (!elem || typeof elem !== 'object') continue;
                        if (elem.type === 'group' && Array.isArray(elem.elements)) {
                            await walk(elem.elements);
                            continue;
                        }
                        if (elem.type !== 'image') continue;

                        const img = await this.getRenderableImageForElement(elem);
                        if (!img) {
                            stats.failed += 1;
                            continue;
                        }
                        const traced = this.buildAlphaContourFromImageElement(elem, { maxTraceSize: 460, rowStep: 2, maxPoints: 260 });
                        if (!traced || !Array.isArray(traced.worldPoints) || traced.worldPoints.length < 3) {
                            stats.failed += 1;
                            continue;
                        }

                        arr[i] = this.buildVectorPolygonFromImageElement(elem, traced);
                        stats.converted += 1;
                    }
                };

                await walk(elements);
                return stats;
            }

	            // ==================== ROTAR / VOLTEAR (ESPEJO) ====================

	            getElementCenterPoint(elem) {
	                if (!elem || typeof elem !== 'object') return { x: 0, y: 0 };

	                if (elem.type === 'group' && Array.isArray(elem.elements)) {
	                    const b = this.ensureGroupBounds(elem);
	                    if (b) return { x: (b.x1 + b.x2) / 2, y: (b.y1 + b.y2) / 2 };
	                    return { x: 0, y: 0 };
	                }

	                if (elem.type === 'line') {
	                    const x1 = Number(elem.x);
	                    const y1 = Number(elem.y);
	                    const x2 = Number(elem.endX);
	                    const y2 = Number(elem.endY);
	                    if (Number.isFinite(x1) && Number.isFinite(y1) && Number.isFinite(x2) && Number.isFinite(y2)) {
	                        return { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
	                    }
	                    return { x: 0, y: 0 };
	                }

                    if (elem.type === 'mover') {
                        return {
                            x: Number.isFinite(elem.x) ? elem.x : 0,
                            y: Number.isFinite(elem.y) ? elem.y : 0
                        };
                    }

	                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
	                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	                    elem.points.forEach((p) => {
	                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
	                        minX = Math.min(minX, p.x);
	                        minY = Math.min(minY, p.y);
	                        maxX = Math.max(maxX, p.x);
	                        maxY = Math.max(maxY, p.y);
	                    });
	                    if (Number.isFinite(minX)) return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
	                    return { x: 0, y: 0 };
	                }

	                if (Number.isFinite(elem.x) && Number.isFinite(elem.y) && Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
	                    return { x: elem.x + elem.width / 2, y: elem.y + elem.height / 2 };
	                }

	                if (Number.isFinite(elem.x) && Number.isFinite(elem.y)) {
	                    return { x: elem.x, y: elem.y };
	                }

	                return { x: 0, y: 0 };
	            }

	            rotatePointAround(px, py, cx, cy, angleRad) {
	                const dx = px - cx;
	                const dy = py - cy;
	                const cos = Math.cos(angleRad);
	                const sin = Math.sin(angleRad);
	                return {
	                    x: cx + (dx * cos - dy * sin),
	                    y: cy + (dx * sin + dy * cos)
	                };
	            }

	            rotateElementAroundPoint(elem, deltaDeg, pivot) {
	                if (!elem || typeof elem !== 'object') return;
	                if (!pivot || !Number.isFinite(pivot.x) || !Number.isFinite(pivot.y)) return;
	                const delta = Number(deltaDeg) || 0;
	                if (!delta) return;

	                const angle = (delta * Math.PI) / 180;

	                if (elem.type === 'group' && Array.isArray(elem.elements)) {
	                    elem.elements.forEach((child) => this.rotateElementAroundPoint(child, delta, pivot));
	                    this.ensureGroupBounds(elem);
	                    return;
	                }

	                if (elem.type === 'line') {
	                    const p1 = this.rotatePointAround(Number(elem.x) || 0, Number(elem.y) || 0, pivot.x, pivot.y, angle);
	                    const p2 = this.rotatePointAround(Number(elem.endX) || 0, Number(elem.endY) || 0, pivot.x, pivot.y, angle);
	                    elem.x = p1.x;
	                    elem.y = p1.y;
	                    elem.endX = p2.x;
	                    elem.endY = p2.y;
	                    return;
	                }

	                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
	                    elem.points.forEach((p) => {
	                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
	                        const np = this.rotatePointAround(p.x, p.y, pivot.x, pivot.y, angle);
	                        p.x = np.x;
	                        p.y = np.y;
	                    });
	                    return;
	                }

	                // Elementos con caja (x,y,width,height): rotaci√≥n por propiedad + mover el centro alrededor del pivote.
	                if (Number.isFinite(elem.x) && Number.isFinite(elem.y) && Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
	                    const cx = elem.x + elem.width / 2;
	                    const cy = elem.y + elem.height / 2;
	                    const nc = this.rotatePointAround(cx, cy, pivot.x, pivot.y, angle);
	                    elem.x = nc.x - elem.width / 2;
	                    elem.y = nc.y - elem.height / 2;

	                    if (elem.type === 'image' || elem.type === 'video' || elem.type === 'rectangle' || elem.type === 'circle') {
	                        const prev = Number(elem.rotation);
	                        const base = Number.isFinite(prev) ? prev : 0;
	                        elem.rotation = base + delta;
	                    }

	                    this.normalizeBoxElementInPlace(elem);
	                }
	            }

	            flipElementXAroundAxis(elem, axisX) {
	                if (!elem || typeof elem !== 'object') return;
	                const ax = Number(axisX);
	                if (!Number.isFinite(ax)) return;

	                if (elem.type === 'group' && Array.isArray(elem.elements)) {
	                    elem.elements.forEach((child) => this.flipElementXAroundAxis(child, ax));
	                    this.ensureGroupBounds(elem);
	                    return;
	                }

	                if (elem.type === 'line') {
	                    elem.x = (2 * ax) - (Number(elem.x) || 0);
	                    elem.endX = (2 * ax) - (Number(elem.endX) || 0);
	                    return;
	                }

	                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
	                    elem.points.forEach((p) => {
	                        if (!p || !Number.isFinite(p.x)) return;
	                        p.x = (2 * ax) - p.x;
	                    });
	                    return;
	                }

	                if (Number.isFinite(elem.x) && Number.isFinite(elem.y) && Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
	                    const cx = elem.x + elem.width / 2;
	                    const ncx = (2 * ax) - cx;
	                    elem.x = ncx - elem.width / 2;

	                    if (elem.type === 'image' || elem.type === 'video' || elem.type === 'rectangle' || elem.type === 'circle') {
	                        elem.flipX = !(elem.flipX === true);
	                    }

	                    this.normalizeBoxElementInPlace(elem);
	                }
	            }

	            rotateSelectedElements(deltaDeg) {
	                if (this.readOnly) return;
	                if (!this.selectedElements || this.selectedElements.length === 0) return;
	                const delta = Number(deltaDeg) || 0;
	                if (!delta) return;

	                this.selectedElements.forEach((elem) => {
	                    if (!elem || typeof elem !== 'object') return;
	                    if (elem.locked) return;

	                    const pivot = this.getElementCenterPoint(elem);
	                    this.rotateElementAroundPoint(elem, delta, pivot);
	                });

	                this.saveHistory();
	                this.updatePropertiesPanel();
	                this.updateStatusBar();
	                this.refreshLayersPanel();
	            }

	            flipSelectedElementsX() {
	                if (this.readOnly) return;
	                if (!this.selectedElements || this.selectedElements.length === 0) return;

	                this.selectedElements.forEach((elem) => {
	                    if (!elem || typeof elem !== 'object') return;
	                    if (elem.locked) return;

	                    const pivot = this.getElementCenterPoint(elem);
	                    this.flipElementXAroundAxis(elem, pivot.x);
	                });

	                this.saveHistory();
	                this.updatePropertiesPanel();
	                this.updateStatusBar();
	                this.refreshLayersPanel();
	            }
	            
	            // ==================== REDIMENSIONAMIENTO ====================
            
            getResizeHandles(elem) {
                if (elem.type === 'group' || elem.locked) return [];
                
                const handles = [];
                const handleSize = 8 / this.camera.zoom;
                
                if (elem.type === 'mover') {
                    const state = this.resolveMoverState(elem, false);
                    const w = Math.max(12, Math.abs(Number(elem.width) || 44));
                    const h = Math.max(12, Math.abs(Number(elem.height) || 28));
                    const x = state.x - (w / 2);
                    const y = state.y - (h / 2);
                    handles.push(
                        { x, y, position: 'nw' },
                        { x: x + (w / 2), y, position: 'n' },
                        { x: x + w, y, position: 'ne' },
                        { x: x + w, y: y + (h / 2), position: 'e' },
                        { x: x + w, y: y + h, position: 'se' },
                        { x: x + (w / 2), y: y + h, position: 's' },
                        { x, y: y + h, position: 'sw' },
                        { x, y: y + (h / 2), position: 'w' }
                    );
                } else if (elem.type === 'rectangle' || elem.type === 'circle' || elem.type === 'image' || elem.type === 'video' || elem.type === 'portal') {
                    // 8 handles: esquinas y puntos medios
                    handles.push(
                        { x: elem.x, y: elem.y, position: 'nw' },
                        { x: elem.x + elem.width / 2, y: elem.y, position: 'n' },
                        { x: elem.x + elem.width, y: elem.y, position: 'ne' },
                        { x: elem.x + elem.width, y: elem.y + elem.height / 2, position: 'e' },
                        { x: elem.x + elem.width, y: elem.y + elem.height, position: 'se' },
                        { x: elem.x + elem.width / 2, y: elem.y + elem.height, position: 's' },
                        { x: elem.x, y: elem.y + elem.height, position: 'sw' },
                        { x: elem.x, y: elem.y + elem.height / 2, position: 'w' }
                    );
                } else if (elem.type === 'line') {
                    // 2 handles: inicio y fin
                    handles.push(
                        { x: elem.x, y: elem.y, position: 'start' },
                        { x: elem.endX, y: elem.endY, position: 'end' }
                    );
                } else if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
                    // Handles de bounding box (para escalar) + por punto (para deformar el contorno)
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    elem.points.forEach((p) => {
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY)) {
                        handles.push(
                            { x: minX, y: minY, position: 'nw' },
                            { x: elem.points.length ? (minX + maxX) / 2 : minX, y: minY, position: 'n' },
                            { x: maxX, y: minY, position: 'ne' },
                            { x: maxX, y: (minY + maxY) / 2, position: 'e' },
                            { x: maxX, y: maxY, position: 'se' },
                            { x: (minX + maxX) / 2, y: maxY, position: 's' },
                            { x: minX, y: maxY, position: 'sw' },
                            { x: minX, y: (minY + maxY) / 2, position: 'w' }
                        );
                    }

                    const maxHandles = 80;
                    const len = elem.points.length;
                    const step = Math.max(1, Math.ceil(len / maxHandles));
                    for (let i = 0; i < len; i += step) {
                        const p = elem.points[i];
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
                        handles.push({ x: p.x, y: p.y, position: `p:${i}` });
                    }
                    // Asegurar que el √∫ltimo punto tambi√©n tenga handle (si se decim√≥).
                    if (step > 1 && len > 1) {
                        const lastIndex = len - 1;
                        const last = elem.points[lastIndex];
                        if (last && Number.isFinite(last.x) && Number.isFinite(last.y)) {
                            handles.push({ x: last.x, y: last.y, position: `p:${lastIndex}` });
                        }
                    }
                }
                
                return handles;
            }
            
            getResizeHandleAt(x, y) {
                for (const elem of this.selectedElements) {
                    const handles = this.getResizeHandles(elem);
                    const handleSize = 8 / this.camera.zoom;
                    
                    for (const handle of handles) {
                        const dist = Math.sqrt(Math.pow(x - handle.x, 2) + Math.pow(y - handle.y, 2));
                        if (dist < handleSize) {
                            return { element: elem, handle: handle.position };
                        }
                    }
                }
                return null;
            }
            
            resizeElement(elem, handle, worldPos) {
                if ((elem.type === 'path' || elem.type === 'polygon') &&
                    typeof handle === 'string' && handle.startsWith('p:') &&
                    Array.isArray(elem.points)) {
                    const idx = Number.parseInt(handle.slice(2), 10);
                    if (Number.isFinite(idx) && elem.points[idx]) {
                        elem.points[idx].x = worldPos.x;
                        elem.points[idx].y = worldPos.y;
                        if (elem.type === 'polygon') elem.closed = true;
                    }
                    return;
                }

                if ((elem.type === 'path' || elem.type === 'polygon') &&
                    typeof handle === 'string' &&
                    Array.isArray(elem.points) &&
                    elem.points.length > 0) {
                    const h = handle;
                    const isBoxHandle =
                        h === 'nw' || h === 'n' || h === 'ne' ||
                        h === 'e' || h === 'se' || h === 's' ||
                        h === 'sw' || h === 'w';
                    if (isBoxHandle) {
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        elem.points.forEach((p) => {
                            if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                            maxX = Math.max(maxX, p.x);
                            maxY = Math.max(maxY, p.y);
                        });
                        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
                            return;
                        }

                        const oldWidth = maxX - minX;
                        const oldHeight = maxY - minY;

                        let newMinX = minX, newMinY = minY, newMaxX = maxX, newMaxY = maxY;
                        switch (h) {
                            case 'se':
                                newMaxX = worldPos.x;
                                newMaxY = worldPos.y;
                                break;
                            case 'nw':
                                newMinX = worldPos.x;
                                newMinY = worldPos.y;
                                break;
                            case 'ne':
                                newMaxX = worldPos.x;
                                newMinY = worldPos.y;
                                break;
                            case 'sw':
                                newMinX = worldPos.x;
                                newMaxY = worldPos.y;
                                break;
                            case 'e':
                                newMaxX = worldPos.x;
                                break;
                            case 'w':
                                newMinX = worldPos.x;
                                break;
                            case 's':
                                newMaxY = worldPos.y;
                                break;
                            case 'n':
                                newMinY = worldPos.y;
                                break;
                        }

                        const newWidth = newMaxX - newMinX;
                        const newHeight = newMaxY - newMinY;

                        const invOldW = oldWidth !== 0 ? 1 / oldWidth : 0;
                        const invOldH = oldHeight !== 0 ? 1 / oldHeight : 0;

                        elem.points.forEach((p) => {
                            if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                            const relX = oldWidth !== 0 ? (p.x - minX) * invOldW : 0;
                            const relY = oldHeight !== 0 ? (p.y - minY) * invOldH : 0;
                            p.x = newMinX + relX * newWidth;
                            p.y = newMinY + relY * newHeight;
                        });

                        if (elem.type === 'polygon') elem.closed = true;
                        return;
                    }
                }

                if (elem.type === 'mover') {
                    const state = this.resolveMoverState(elem, false);
                    const baseW = Math.max(12, Math.abs(Number(elem.width) || 44));
                    const baseH = Math.max(12, Math.abs(Number(elem.height) || 28));
                    const left = state.x - (baseW / 2);
                    const top = state.y - (baseH / 2);
                    const originalRight = left + baseW;
                    const originalBottom = top + baseH;
                    let w = baseW;
                    let h = baseH;

                    switch(handle) {
                        case 'nw':
                            w = originalRight - worldPos.x;
                            h = originalBottom - worldPos.y;
                            break;
                        case 'n':
                            h = originalBottom - worldPos.y;
                            break;
                        case 'ne':
                            w = worldPos.x - left;
                            h = originalBottom - worldPos.y;
                            break;
                        case 'e':
                            w = worldPos.x - left;
                            break;
                        case 'se':
                            w = worldPos.x - left;
                            h = worldPos.y - top;
                            break;
                        case 's':
                            h = worldPos.y - top;
                            break;
                        case 'sw':
                            w = originalRight - worldPos.x;
                            h = worldPos.y - top;
                            break;
                        case 'w':
                            w = originalRight - worldPos.x;
                            break;
                    }

                    elem.width = Math.max(12, Math.abs(w));
                    elem.height = Math.max(12, Math.abs(h));
                } else if (elem.type === 'rectangle' || elem.type === 'circle' || elem.type === 'portal') {
                    const originalRight = elem.x + elem.width;
                    const originalBottom = elem.y + elem.height;
                    
                    switch(handle) {
                        case 'nw':
                            elem.width = originalRight - worldPos.x;
                            elem.height = originalBottom - worldPos.y;
                            elem.x = worldPos.x;
                            elem.y = worldPos.y;
                            break;
                        case 'n':
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                        case 'ne':
                            elem.width = worldPos.x - elem.x;
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                        case 'e':
                            elem.width = worldPos.x - elem.x;
                            break;
                        case 'se':
                            elem.width = worldPos.x - elem.x;
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 's':
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 'sw':
                            elem.width = originalRight - worldPos.x;
                            elem.height = worldPos.y - elem.y;
                            elem.x = worldPos.x;
                            break;
                        case 'w':
                            elem.width = originalRight - worldPos.x;
                            elem.x = worldPos.x;
                            break;
                    }
                } else if (elem.type === 'image' || elem.type === 'video') {
                    // Redimensionar imagen/video manteniendo proporci√≥n (en esquinas)
                    const originalRight = elem.x + elem.width;
                    const originalBottom = elem.y + elem.height;
                    const ow = Number(elem.originalWidth) || 1;
                    const oh = Number(elem.originalHeight) || 1;
                    const aspectRatio = oh / ow;
                    
                    switch(handle) {
                        case 'se':
                            const newWidth = worldPos.x - elem.x;
                            elem.width = newWidth;
                            elem.height = newWidth * aspectRatio;
                            break;
                        case 'nw':
                            const nwWidth = originalRight - worldPos.x;
                            elem.width = nwWidth;
                            elem.height = nwWidth * aspectRatio;
                            elem.x = worldPos.x;
                            elem.y = originalBottom - elem.height;
                            break;
                        case 'ne':
                            const neWidth = worldPos.x - elem.x;
                            elem.width = neWidth;
                            elem.height = neWidth * aspectRatio;
                            elem.y = originalBottom - elem.height;
                            break;
                        case 'sw':
                            const swWidth = originalRight - worldPos.x;
                            elem.width = swWidth;
                            elem.height = swWidth * aspectRatio;
                            elem.x = worldPos.x;
                            break;
                        // Para puntos medios, redimensionar libre
                        case 'e':
                            elem.width = worldPos.x - elem.x;
                            break;
                        case 'w':
                            elem.width = originalRight - worldPos.x;
                            elem.x = worldPos.x;
                            break;
                        case 's':
                            elem.height = worldPos.y - elem.y;
                            break;
                        case 'n':
                            elem.height = originalBottom - worldPos.y;
                            elem.y = worldPos.y;
                            break;
                    }
                } else if (elem.type === 'line') {
                    if (handle === 'start') {
                        elem.x = worldPos.x;
                        elem.y = worldPos.y;
                    } else if (handle === 'end') {
                        elem.endX = worldPos.x;
                        elem.endY = worldPos.y;
                    }
                }
            }

            normalizeBoxElementInPlace(elem) {
                if (!elem || typeof elem !== 'object') return;
                const t = elem.type ? String(elem.type) : '';
                if (t !== 'rectangle' && t !== 'circle' && t !== 'image' && t !== 'video' && t !== 'group') return;

                if (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) ||
                    !Number.isFinite(elem.width) || !Number.isFinite(elem.height)) {
                    return;
                }

                // Evitar cajas "invertidas" (width/height negativos) que rompen selecci√≥n/handles.
                if (elem.width < 0) {
                    elem.x = elem.x + elem.width;
                    elem.width = Math.abs(elem.width);
                }
                if (elem.height < 0) {
                    elem.y = elem.y + elem.height;
                    elem.height = Math.abs(elem.height);
                }
            }
            
            getResizeCursor(handle) {
                const cursors = {
                    'nw': 'nw-resize',
                    'n': 'n-resize',
                    'ne': 'ne-resize',
                    'e': 'e-resize',
                    'se': 'se-resize',
                    's': 's-resize',
                    'sw': 'sw-resize',
                    'w': 'w-resize',
                    'start': 'move',
                    'end': 'move'
                };
                if (typeof handle === 'string' && handle.startsWith('p:')) return 'move';
                return cursors[handle] || 'default';
            }

            // ==================== FORMAS (POL√çGONOS) ====================

            getNormalizedBoxFromDrag(x1, y1, x2, y2) {
                const left = Math.min(x1, x2);
                const right = Math.max(x1, x2);
                const top = Math.min(y1, y2);
                const bottom = Math.max(y1, y2);
                const width = right - left;
                const height = bottom - top;
                const cx = (left + right) / 2;
                const cy = (top + bottom) / 2;
                const size = Math.min(width, height);
                return { left, right, top, bottom, width, height, cx, cy, size };
            }

            buildShapePoints(shapeTypeRaw, x1, y1, x2, y2) {
                const st = String(shapeTypeRaw || '').trim().toLowerCase() || 'triangle';
                const b = this.getNormalizedBoxFromDrag(x1, y1, x2, y2);

                const left = b.left;
                const right = b.right;
                const top = b.top;
                const bottom = b.bottom;
                const cx = b.cx;
                const cy = b.cy;
                const w = b.width;
                const h = b.height;

                const outer = Math.max(0, b.size / 2);

                if (st === 'triangle') {
                    return [
                        { x: cx, y: top },
                        { x: right, y: bottom },
                        { x: left, y: bottom }
                    ];
                }

                if (st === 'trapezoid') {
                    const inset = Math.min(w * 0.28, w / 2);
                    return [
                        { x: left + inset, y: top },
                        { x: right - inset, y: top },
                        { x: right, y: bottom },
                        { x: left, y: bottom }
                    ];
                }

                if (st === 'diamond') {
                    return [
                        { x: cx, y: top },
                        { x: right, y: cy },
                        { x: cx, y: bottom },
                        { x: left, y: cy }
                    ];
                }

                if (st.startsWith('star')) {
                    const n = Number.parseInt(st.slice(4), 10);
                    const spikes = Number.isFinite(n) ? Math.min(Math.max(n, 5), 12) : 5;
                    const inner = outer * 0.48;
                    const pts = [];
                    for (let i = 0; i < spikes * 2; i++) {
                        const angle = -Math.PI / 2 + (i * Math.PI) / spikes;
                        const r = (i % 2 === 0) ? outer : inner;
                        pts.push({ x: cx + r * Math.cos(angle), y: cy + r * Math.sin(angle) });
                    }
                    return pts;
                }

                if (st === 'gear') {
                    const teeth = 12;
                    const inner = outer * 0.78;
                    const step = (Math.PI * 2) / teeth;
                    const pts = [];
                    for (let i = 0; i < teeth; i++) {
                        const base = -Math.PI / 2 + i * step;
                        // 4 puntos por diente (aspecto de engrane simple)
                        pts.push({ x: cx + outer * Math.cos(base + step * 0.15), y: cy + outer * Math.sin(base + step * 0.15) });
                        pts.push({ x: cx + outer * Math.cos(base + step * 0.35), y: cy + outer * Math.sin(base + step * 0.35) });
                        pts.push({ x: cx + inner * Math.cos(base + step * 0.60), y: cy + inner * Math.sin(base + step * 0.60) });
                        pts.push({ x: cx + inner * Math.cos(base + step * 0.95), y: cy + inner * Math.sin(base + step * 0.95) });
                    }
                    return pts;
                }

                // Fallback: rect√°ngulo como pol√≠gono.
                return [
                    { x: left, y: top },
                    { x: right, y: top },
                    { x: right, y: bottom },
                    { x: left, y: bottom }
                ];
            }
            
            // ==================== CREACI√ìN DE ELEMENTOS ====================
            
	            createElementAt(x, y) {
	                const baseElement = {
	                    id: Date.now() + Math.random(),
	                    x: x,
	                    y: y,
                    name: '',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    lineWidth: 2,
                    locked: false,
                    active: true,
                    connectionStatus: 'none'
                };
                
                if (this.tool === 'rectangle') {
                    return {
                        ...baseElement,
                        type: 'rectangle',
                        width: 0,
                        height: 0
                    };
                } else if (this.tool === 'circle') {
                    return {
                        ...baseElement,
                        type: 'circle',
                        width: 0,
                        height: 0
                    };
                } else if (this.tool === 'shape') {
                    const shapeType = this.shapeType || 'triangle';
                    return {
                        ...baseElement,
                        type: 'polygon',
                        points: this.buildShapePoints(shapeType, x, y, x, y),
                        strokeColor: baseElement.strokeColor,
                        fillColor: baseElement.fillColor,
                        lineWidth: 3,
                        closed: true,
                        shapeType
                    };
	                } else if (this.tool === 'line') {
	                    return {
	                        ...baseElement,
	                        type: 'line',
	                        endX: x,
	                        endY: y,
	                        lineWidth: 3,
	                        animColor: '#4caf50',
	                        flowDirection: 'right',
	                        animOffset: 0,
	                        controlPoints: [] // Para curvas editables
	                    };
                    } else if (this.tool === 'route') {
                        return {
                            ...baseElement,
                            type: 'line',
                            endX: x,
                            endY: y,
                            lineWidth: 5,
                            routeRole: true,
                            routeCircular: false,
                            routeCurve: 'line',
                            routeArcSide: 'left',
                            routeArcDegrees: 120,
                            name: `Ruta ${Date.now()}`,
                            animColor: '#00d4ff',
                            flowDirection: 'right',
                            animOffset: 0,
                            controlPoints: []
                        };
                    } else if (this.tool === 'mover-metro' || this.tool === 'mover-male' || this.tool === 'mover-female') {
                        const kind = this.tool === 'mover-metro'
                            ? 'metro'
                            : (this.tool === 'mover-male' ? 'male' : 'female');
                        const nearest = this.findNearestRouteForPoint(x, y);
                        const routeId = nearest ? String(nearest.id) : '';
                        return {
                            ...baseElement,
                            type: 'mover',
                            moverKind: kind,
                            width: 44,
                            height: 28,
                            flowDirection: 'right',
                            speed: 40,
                            routeMode: 'loop',
                            autoConnectRoute: true,
                            progress: 0,
                            routeId,
                            name: kind === 'metro' ? 'Metro' : (kind === 'male' ? 'Hombre' : 'Mujer'),
                            fillColor: kind === 'female' ? '#f472b6' : (kind === 'male' ? '#3b82f6' : '#93c5fd'),
                            strokeColor: '#0b1027'
                        };
                    } else if (this.tool === 'portal-in' || this.tool === 'portal-out') {
                        const portalKind = this.tool === 'portal-in' ? 'import' : 'export';
                        return {
                            ...baseElement,
                            type: 'portal',
                            width: 36,
                            height: 36,
                            portalKind,
                            portalKey: 'A1',
                            fillColor: portalKind === 'import' ? '#22d3ee' : '#a78bfa',
                            strokeColor: '#0b1027',
                            lineWidth: 3
                        };
	                }
	            }

	            createControlPointAt(x, y) {
	                const order = this.getNextControlPointOrder(this.elements);
	                const size = 36; // tama√±o en "mundo" (se escala con zoom)
	                const half = size / 2;

	                return {
	                    id: Date.now() + Math.random(),
	                    type: 'circle',
	                    x: x - half,
	                    y: y - half,
	                    width: size,
	                    height: size,
	                    name: '',
	                    fillColor: 'transparent',
	                    strokeColor: '#00d4ff',
	                    lineWidth: 3,
	                    locked: false,
	                    active: true,
	                    connectionStatus: 'none',
	                    meta: {
	                        controlPoint: true,
	                        order,
	                        slide: {
	                            title: `Punto ${String(order)}`,
	                            text: '',
	                            imageUrl: '',
	                            videoUrl: ''
	                        }
	                    }
	                };
	            }

            convertSelectedToPolygon() {
                if (this.readOnly) return;
                if (this.selectedElements.length !== 1) return;

                const elem = this.selectedElements[0];
                if (!elem || typeof elem !== 'object') return;
                if (elem.locked) return;
                if (elem.type === 'image') {
                    this.convertSelectedImageToVectorPolygon();
                    return;
                }
                if (!(elem.type === 'rectangle' || elem.type === 'circle')) return;

                const idx = this.elements.indexOf(elem);
                if (idx < 0) return;

                let points = [];

                if (elem.type === 'rectangle' || elem.type === 'portal') {
                    const x1 = Number(elem.x);
                    const y1 = Number(elem.y);
                    const x2 = Number(elem.x + elem.width);
                    const y2 = Number(elem.y + elem.height);
                    const left = Math.min(x1, x2);
                    const right = Math.max(x1, x2);
                    const top = Math.min(y1, y2);
                    const bottom = Math.max(y1, y2);
                    points = [
                        { x: left, y: top },
                        { x: right, y: top },
                        { x: right, y: bottom },
                        { x: left, y: bottom }
                    ];
                } else if (elem.type === 'circle') {
                    const cx = Number(elem.x) + Number(elem.width) / 2;
                    const cy = Number(elem.y) + Number(elem.height) / 2;
                    const rx = Math.abs(Number(elem.width) / 2);
                    const ry = Math.abs(Number(elem.height) / 2);
                    const segments = 24;
                    for (let i = 0; i < segments; i++) {
                        const a = (Math.PI * 2 * i) / segments;
                        points.push({ x: cx + rx * Math.cos(a), y: cy + ry * Math.sin(a) });
                    }
                }

	                const poly = {
	                    id: elem.id,
	                    type: 'polygon',
	                    points,
	                    lineWidth: 3,
	                    fillColor: elem.fillColor,
	                    strokeColor: elem.strokeColor,
	                    locked: false,
	                    active: elem.active,
	                    connectionStatus: elem.connectionStatus || 'none',
	                    name: elem.name || '',
	                    closed: true
	                };

	                const fg = this.normalizeFillGradientSpec(elem.fillGradient);
	                if (fg) poly.fillGradient = fg;

	                this.elements[idx] = poly;
	                this.selectedElements = [poly];
	                this.saveHistory();
	                this.updatePropertiesPanel();
            }
            
            getElementAt(x, y) {
                // Buscar de atr√°s hacia adelante (√∫ltimo dibujado primero)
                for (let i = this.elements.length - 1; i >= 0; i--) {
                    const elem = this.elements[i];
                    
                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        const b = this.ensureGroupBounds(elem);
                        if (b && x >= b.x1 && x <= b.x2 && y >= b.y1 && y <= b.y2) {
                            return elem;
                        }
                    }

	                    if (elem.type === 'image' || elem.type === 'video' || elem.type === 'rectangle' || elem.type === 'portal') {
	                        if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
	                            typeof elem.width === 'number' && typeof elem.height === 'number') {
	                            const p = this.transformPointToElementBoxLocal(elem, x, y);
	                            const tx = p.x;
	                            const ty = p.y;
	                            const x1 = Math.min(elem.x, elem.x + elem.width);
	                            const x2 = Math.max(elem.x, elem.x + elem.width);
	                            const y1 = Math.min(elem.y, elem.y + elem.height);
	                            const y2 = Math.max(elem.y, elem.y + elem.height);
	                            if (tx >= x1 && tx <= x2 && ty >= y1 && ty <= y2) {
	                                return elem;
	                            }
	                        }
	                    } else if (elem.type === 'circle') {
	                        const p = this.transformPointToElementBoxLocal(elem, x, y);
	                        const tx = p.x;
	                        const ty = p.y;
	                        const centerX = elem.x + elem.width / 2;
	                        const centerY = elem.y + elem.height / 2;
	                        const radiusX = Math.abs(elem.width / 2);
	                        const radiusY = Math.abs(elem.height / 2);
	                        
	                        const normalized = Math.pow((tx - centerX) / radiusX, 2) + 
	                                         Math.pow((ty - centerY) / radiusY, 2);
	                        
	                        if (normalized <= 1) {
	                            return elem;
	                        }
                    } else if (elem.type === 'line') {
                        const curve = this.getRouteCurve(elem);
                        if (curve !== 'line') {
                            const pts = this.getRoutePoints(elem);
                            for (let j = 1; j < pts.length; j++) {
                                const p1 = pts[j - 1];
                                const p2 = pts[j];
                                const dist = this.distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                                if (dist < 10 / this.camera.zoom) return elem;
                            }
                        } else {
                            // Detecci√≥n simple de l√≠nea (con margen)
                            const dist = this.distanceToLineSegment(x, y, elem.x, elem.y, elem.endX, elem.endY);
                            if (dist < 10 / this.camera.zoom) {
                                return elem;
                            }
                        }
                    } else if (elem.type === 'mover') {
                        const state = this.resolveMoverState(elem, false);
                        const hw = (Math.abs(Number(elem.width) || 44) / 2) + (6 / this.camera.zoom);
                        const hh = (Math.abs(Number(elem.height) || 28) / 2) + (6 / this.camera.zoom);
                        if (x >= state.x - hw && x <= state.x + hw && y >= state.y - hh && y <= state.y + hh) {
                            return elem;
                        }
                    } else if ((elem.type === 'path' || elem.type === 'polygon') && elem.points) {
                        // Para pol√≠gonos cerrados, verificar si el punto est√° dentro
                        if (elem.type === 'polygon' && elem.closed) {
                            if (this.pointInPolygon(x, y, elem.points)) {
                                return elem;
                            }
                        }
                        
                        // Detecci√≥n de path (verificar distancia a cada segmento)
                        for (let j = 0; j < elem.points.length - 1; j++) {
                            const p1 = elem.points[j];
                            const p2 = elem.points[j + 1];
                            const dist = this.distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (dist < 10 / this.camera.zoom) {
                                return elem;
                            }
                        }
                    }
                }
                return null;
            }
            
            pointInPolygon(x, y, points) {
                // Ray casting algorithm
                let inside = false;
                for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                    const xi = points[i].x, yi = points[i].y;
                    const xj = points[j].x, yj = points[j].y;
                    
                    const intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            
            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // ==================== RENDERIZADO ====================
            
            render() {
                // Limpiar canvas
                if (this.backgroundColor) {
                    this.ctx.fillStyle = this.backgroundColor;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    // Fondo transparente (tipo sticker)
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Aplicar transformaci√≥n de c√°mara
                this.ctx.save();
                this.ctx.translate(this.camera.x, this.camera.y);
                this.ctx.scale(this.camera.zoom, this.camera.zoom);
                
                // Dibujar grid (opcional)
                if (this.showGrid) {
                    this.drawGrid();
                }

                // Animar elementos "montados" a rutas (except movers dedicados).
                this.updateRouteFollowersInPlace();
                
                // Dibujar elementos
                this.elements.forEach(elem => this.drawElement(elem));
                
                // Dibujar path temporal
                if (this.drawingPath) {
                    this.ctx.strokeStyle = this.drawingPath.strokeColor;
                    this.ctx.lineWidth = this.drawingPath.lineWidth / this.camera.zoom;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.drawingPath.points[0].x, this.drawingPath.points[0].y);
                    
                    for (let i = 1; i < this.drawingPath.points.length; i++) {
                        this.ctx.lineTo(this.drawingPath.points[i].x, this.drawingPath.points[i].y);
                    }
                    
                    this.ctx.stroke();
                    
                    // Dibujar punto inicial grande si estamos cerca para cerrar
                    if (this.drawingPath.nearStart) {
                        this.ctx.fillStyle = '#4caf50';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            this.drawingPath.points[0].x, 
                            this.drawingPath.points[0].y, 
                            10 / this.camera.zoom, 
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.fill();
                        
                        // Preview del pol√≠gono cerrado
                        this.ctx.globalAlpha = 0.3;
                        this.ctx.fillStyle = '#0f3460';
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.drawingPath.points[0].x, this.drawingPath.points[0].y);
                        for (let i = 1; i < this.drawingPath.points.length; i++) {
                            this.ctx.lineTo(this.drawingPath.points[i].x, this.drawingPath.points[i].y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;
                    } else {
                        // Punto inicial normal
                        this.ctx.fillStyle = '#e94560';
                        this.ctx.beginPath();
                        this.ctx.arc(
                            this.drawingPath.points[0].x, 
                            this.drawingPath.points[0].y, 
                            6 / this.camera.zoom, 
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                }
                
                // Dibujar elemento temporal
                if (this.tempElement) {
                    this.ctx.globalAlpha = 0.5;
                    this.drawElement(this.tempElement);
                    this.ctx.globalAlpha = 1;
                }
                
                const showSelection = !this.readOnly || this.viewerMode === 'deck';
                if (showSelection) {
                    // Dibujar selecciones (en deck tambi√©n, para resaltar puntos de control)
                    this.selectedElements.forEach(elem => this.drawSelection(elem));
                }

                if (this.selectionBox && !this.readOnly) {
                    const s = this.selectionBox.start;
                    const e = this.selectionBox.end;
                    const x1 = Math.min(s.x, e.x);
                    const y1 = Math.min(s.y, e.y);
                    const w = Math.abs(e.x - s.x);
                    const h = Math.abs(e.y - s.y);

                    this.ctx.save();
                    this.ctx.shadowColor = 'transparent';
                    this.ctx.shadowBlur = 0;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 0;
                    this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.85)';
                    this.ctx.fillStyle = 'rgba(0, 212, 255, 0.10)';
                    this.ctx.lineWidth = 1 / this.camera.zoom;
                    this.ctx.setLineDash([6 / this.camera.zoom, 6 / this.camera.zoom]);
                    this.ctx.strokeRect(x1, y1, w, h);
                    this.ctx.fillRect(x1, y1, w, h);
                    this.ctx.setLineDash([]);
                    this.ctx.restore();
                }

                if (!this.readOnly) {
                    // Dibujar handles de redimensionamiento
                    this.selectedElements.forEach(elem => this.drawResizeHandles(elem));
                    
                    // Dibujar hover
                    if (this.hoveredElement && !this.selectedElements.includes(this.hoveredElement)) {
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2 / this.camera.zoom;
                        this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                        this.drawElementOutline(this.hoveredElement);
                        this.ctx.setLineDash([]);
                    }
                } else if (this.viewerMode === 'deck') {
                    // Hover suave solo para puntos de control (modo informativo)
                    if (this.hoveredElement &&
                        !this.selectedElements.includes(this.hoveredElement) &&
                        this.isControlPoint(this.hoveredElement)) {
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2 / this.camera.zoom;
                        this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                        this.drawElementOutline(this.hoveredElement);
                        this.ctx.setLineDash([]);
                    }
                }
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const gridSize = 50;
                const startX = Math.floor(-this.camera.x / this.camera.zoom / gridSize) * gridSize;
                const startY = Math.floor(-this.camera.y / this.camera.zoom / gridSize) * gridSize;
                const endX = startX + (this.canvas.width / this.camera.zoom) + gridSize;
                const endY = startY + (this.canvas.height / this.camera.zoom) + gridSize;
                
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1 / this.camera.zoom;
                
                for (let x = startX; x < endX; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, startY);
                    this.ctx.lineTo(x, endY);
                    this.ctx.stroke();
                }
                
                for (let y = startY; y < endY; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, y);
                    this.ctx.lineTo(endX, y);
                    this.ctx.stroke();
                }
            }

            isRouteElement(elem) {
                if (!elem || typeof elem !== 'object') return false;
                const t = String(elem.type || '');
                if (!(t === 'line' || t === 'path' || t === 'polygon')) return false;
                if (elem.routeRole === true) return true;
                const n = String(elem.name || '').toLowerCase();
                return n.includes('ruta') || n.includes('via');
            }

            getRouteCurve(elem) {
                if (!elem || typeof elem !== 'object') return 'line';
                if (elem.routeCircular === true) return 'circle';
                const c = String(elem.routeCurve || 'line').toLowerCase();
                if (c === 'circle' || c === 'semi' || c === 'quarter' || c === 'custom') return c;
                return 'line';
            }

            getRouteArcDegrees(elem) {
                const raw = Number(elem && elem.routeArcDegrees);
                if (!Number.isFinite(raw)) return 120;
                return Math.max(5, Math.min(355, raw));
            }

            buildArcPointsFromChord(x1, y1, x2, y2, fraction, side) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const chord = Math.sqrt(dx * dx + dy * dy);
                if (!(chord > 0)) return [{ x: x1, y: y1 }, { x: x2, y: y2 }];

                const theta = Math.max(0.0001, Math.min((Math.PI * 2) - 0.0001, (Math.PI * 2) * fraction));
                const r = chord / (2 * Math.sin(theta / 2));
                const half = chord / 2;
                const h = Math.sqrt(Math.max(0, (r * r) - (half * half)));
                const mx = (x1 + x2) / 2;
                const my = (y1 + y2) / 2;
                const nxL = -dy / chord;
                const nyL = dx / chord;
                const sign = String(side || 'left') === 'right' ? -1 : 1;
                const cx = mx + (nxL * h * sign);
                const cy = my + (nyL * h * sign);

                const a0 = Math.atan2(y1 - cy, x1 - cx);
                const candA = a0 + theta;
                const candB = a0 - theta;
                const exA = cx + r * Math.cos(candA);
                const eyA = cy + r * Math.sin(candA);
                const exB = cx + r * Math.cos(candB);
                const eyB = cy + r * Math.sin(candB);
                const dA = Math.sqrt(Math.pow(exA - x2, 2) + Math.pow(eyA - y2, 2));
                const dB = Math.sqrt(Math.pow(exB - x2, 2) + Math.pow(eyB - y2, 2));
                const dir = dA <= dB ? 1 : -1;

                const steps = Math.max(8, Math.round(72 * fraction));
                const pts = [];
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const a = a0 + (dir * theta * t);
                    pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
                }
                return pts;
            }

            getRoutePoints(elem) {
                if (!elem || typeof elem !== 'object') return [];
                if (elem.type === 'line') {
                    if (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) || !Number.isFinite(elem.endX) || !Number.isFinite(elem.endY)) return [];
                    const curve = this.getRouteCurve(elem);
                    if (curve === 'circle') {
                        const cx = (elem.x + elem.endX) / 2;
                        const cy = (elem.y + elem.endY) / 2;
                        const radius = Math.max(2, Math.sqrt(Math.pow(elem.endX - elem.x, 2) + Math.pow(elem.endY - elem.y, 2)) / 2);
                        const segments = 72;
                        const pts = [];
                        for (let i = 0; i <= segments; i++) {
                            const a = (Math.PI * 2 * i) / segments;
                            pts.push({ x: cx + radius * Math.cos(a), y: cy + radius * Math.sin(a) });
                        }
                        return pts;
                    }
                    if (curve === 'semi') {
                        return this.buildArcPointsFromChord(
                            elem.x, elem.y, elem.endX, elem.endY, 0.5, elem.routeArcSide || 'left'
                        );
                    }
                    if (curve === 'quarter') {
                        return this.buildArcPointsFromChord(
                            elem.x, elem.y, elem.endX, elem.endY, 0.25, elem.routeArcSide || 'left'
                        );
                    }
                    if (curve === 'custom') {
                        const deg = this.getRouteArcDegrees(elem);
                        return this.buildArcPointsFromChord(
                            elem.x, elem.y, elem.endX, elem.endY, deg / 360, elem.routeArcSide || 'left'
                        );
                    }
                    return [{ x: elem.x, y: elem.y }, { x: elem.endX, y: elem.endY }];
                }
                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                    const pts = elem.points.filter((p) => p && Number.isFinite(p.x) && Number.isFinite(p.y));
                    if (!pts.length) return [];
                    if (elem.type === 'polygon' && elem.closed) {
                        pts.push({ x: pts[0].x, y: pts[0].y });
                    }
                    return pts;
                }
                return [];
            }

            getPolylineLength(points) {
                if (!Array.isArray(points) || points.length < 2) return 0;
                let total = 0;
                for (let i = 1; i < points.length; i++) {
                    const dx = points[i].x - points[i - 1].x;
                    const dy = points[i].y - points[i - 1].y;
                    total += Math.sqrt(dx * dx + dy * dy);
                }
                return total;
            }

            getPointOnPolyline(points, t) {
                if (!Array.isArray(points) || points.length === 0) return null;
                if (points.length === 1) return { x: points[0].x, y: points[0].y, angle: 0 };
                const clamped = Math.max(0, Math.min(1, Number(t) || 0));
                const total = this.getPolylineLength(points);
                if (total <= 0) return { x: points[0].x, y: points[0].y, angle: 0 };
                const target = clamped * total;
                let acc = 0;
                for (let i = 1; i < points.length; i++) {
                    const p0 = points[i - 1];
                    const p1 = points[i];
                    const dx = p1.x - p0.x;
                    const dy = p1.y - p0.y;
                    const seg = Math.sqrt(dx * dx + dy * dy);
                    if (seg <= 0) continue;
                    if (acc + seg >= target || i === points.length - 1) {
                        const local = Math.max(0, Math.min(1, (target - acc) / seg));
                        return {
                            x: p0.x + dx * local,
                            y: p0.y + dy * local,
                            angle: Math.atan2(dy, dx)
                        };
                    }
                    acc += seg;
                }
                const last = points[points.length - 1];
                const prev = points[points.length - 2];
                return { x: last.x, y: last.y, angle: Math.atan2(last.y - prev.y, last.x - prev.x) };
            }

            getRouteElementById(routeIdRaw) {
                const routeId = String(routeIdRaw || '');
                if (!routeId) return null;
                return this.elements.find((elem) => this.isRouteElement(elem) && String(elem.id) === routeId) || null;
            }

            findNearestRouteForPoint(x, y) {
                let best = null;
                let bestDist = Infinity;
                (this.elements || []).forEach((elem) => {
                    if (!this.isRouteElement(elem)) return;
                    const pts = this.getRoutePoints(elem);
                    if (pts.length < 2) return;
                    for (let i = 1; i < pts.length; i++) {
                        const d = this.distanceToLineSegment(x, y, pts[i - 1].x, pts[i - 1].y, pts[i].x, pts[i].y);
                        if (d < bestDist) {
                            bestDist = d;
                            best = elem;
                        }
                    }
                });
                return best;
            }

            getRouteEndpoints(routeElem) {
                const pts = this.getRoutePoints(routeElem);
                if (!pts || pts.length < 2) return null;
                return { start: pts[0], end: pts[pts.length - 1] };
            }

            findConnectedRoute(currentRoute, useEndPoint) {
                const from = this.getRouteEndpoints(currentRoute);
                if (!from) return null;
                const pivot = useEndPoint ? from.end : from.start;
                const threshold = 28;
                let best = null;
                let bestDist = Infinity;
                (this.elements || []).forEach((candidate) => {
                    if (!this.isRouteElement(candidate)) return;
                    if (!candidate || String(candidate.id) === String(currentRoute.id)) return;
                    const ep = this.getRouteEndpoints(candidate);
                    if (!ep) return;

                    const dStart = Math.sqrt(Math.pow(ep.start.x - pivot.x, 2) + Math.pow(ep.start.y - pivot.y, 2));
                    const dEnd = Math.sqrt(Math.pow(ep.end.x - pivot.x, 2) + Math.pow(ep.end.y - pivot.y, 2));
                    const d = Math.min(dStart, dEnd);
                    if (d > threshold || d >= bestDist) return;

                    bestDist = d;
                    if (dStart <= dEnd) {
                        best = { route: candidate, progress: 0.0001, direction: 'right' };
                    } else {
                        best = { route: candidate, progress: 0.9999, direction: 'left' };
                    }
                });
                return best;
            }

            projectPointToRouteProgress(routeElem, x, y) {
                const pts = this.getRoutePoints(routeElem);
                if (!pts || pts.length < 2) return 0;
                let totalLen = 0;
                const segLens = [];
                for (let i = 1; i < pts.length; i++) {
                    const dx = pts[i].x - pts[i - 1].x;
                    const dy = pts[i].y - pts[i - 1].y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    segLens.push(len);
                    totalLen += len;
                }
                if (totalLen <= 0) return 0;

                let bestDist = Infinity;
                let bestAlong = 0;
                let acc = 0;
                for (let i = 1; i < pts.length; i++) {
                    const p0 = pts[i - 1];
                    const p1 = pts[i];
                    const vx = p1.x - p0.x;
                    const vy = p1.y - p0.y;
                    const lenSq = vx * vx + vy * vy;
                    if (lenSq <= 0) {
                        acc += segLens[i - 1];
                        continue;
                    }
                    const t = Math.max(0, Math.min(1, (((x - p0.x) * vx) + ((y - p0.y) * vy)) / lenSq));
                    const px = p0.x + vx * t;
                    const py = p0.y + vy * t;
                    const d = Math.sqrt(Math.pow(x - px, 2) + Math.pow(y - py, 2));
                    if (d < bestDist) {
                        bestDist = d;
                        bestAlong = acc + (segLens[i - 1] * t);
                    }
                    acc += segLens[i - 1];
                }
                return Math.max(0, Math.min(1, bestAlong / totalLen));
            }

            getPortalCenter(portal) {
                if (!portal || portal.type !== 'portal') return null;
                const x = Number(portal.x);
                const y = Number(portal.y);
                const w = Number(portal.width);
                const h = Number(portal.height);
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return null;
                return { x: x + (w / 2), y: y + (h / 2), r: Math.max(8, Math.min(Math.abs(w), Math.abs(h)) / 2) };
            }

            findPortalAtPoint(x, y, kind) {
                const tKind = String(kind || '');
                let found = null;
                let bestDist = Infinity;
                (this.elements || []).forEach((elem) => {
                    if (!elem || elem.type !== 'portal') return;
                    if (String(elem.portalKind || '') !== tKind) return;
                    const c = this.getPortalCenter(elem);
                    if (!c) return;
                    const d = Math.sqrt(Math.pow(x - c.x, 2) + Math.pow(y - c.y, 2));
                    if (d <= c.r + 8 && d < bestDist) {
                        bestDist = d;
                        found = elem;
                    }
                });
                return found;
            }

            findMatchingExportPortal(importPortal) {
                if (!importPortal || importPortal.type !== 'portal') return null;
                const key = String(importPortal.portalKey || '').trim().toLowerCase();
                if (!key) return null;
                let out = null;
                (this.elements || []).forEach((elem) => {
                    if (!elem || elem.type !== 'portal') return;
                    if (String(elem.portalKind || '') !== 'export') return;
                    if (String(elem.portalKey || '').trim().toLowerCase() !== key) return;
                    out = elem;
                });
                return out;
            }

            applyPortalTeleport(elem, state) {
                if (!elem || !state || !state.routeFound) return state;
                const cd = Number(elem._portalCooldownFrames);
                if (Number.isFinite(cd) && cd > 0) {
                    elem._portalCooldownFrames = cd - 1;
                    return state;
                }

                const pIn = this.findPortalAtPoint(state.x, state.y, 'import');
                if (!pIn) return state;
                const pOut = this.findMatchingExportPortal(pIn);
                if (!pOut) return state;
                const cOut = this.getPortalCenter(pOut);
                if (!cOut) return state;

                const nearest = this.findNearestRouteForPoint(cOut.x, cOut.y);
                if (nearest) {
                    elem.routeId = String(nearest.id);
                    const t = this.projectPointToRouteProgress(nearest, cOut.x, cOut.y);
                    if (elem.type === 'mover') {
                        elem.progress = t;
                    } else {
                        elem.routeProgress = t;
                    }
                }
                elem._portalCooldownFrames = 24;
                return { x: cOut.x, y: cOut.y, angle: state.angle || 0, routeFound: true };
            }

            bindSelectedMoversToNearestRoute() {
                if (!Array.isArray(this.selectedElements) || this.selectedElements.length === 0) return;
                let changed = 0;
                this.selectedElements.forEach((elem) => {
                    if (!elem || typeof elem !== 'object' || elem.locked) return;
                    const canFollow = elem.type === 'mover' || Boolean(elem.followRoute);
                    if (!canFollow) return;
                    const state = this.resolveElementRouteState(elem, false);
                    const nearest = this.findNearestRouteForPoint(state.x, state.y);
                    if (!nearest) return;
                    elem.routeId = String(nearest.id);
                    if (elem.type === 'mover') {
                        elem.progress = Math.max(0, Math.min(1, Number(elem.progress) || 0));
                    } else {
                        elem.routeProgress = Math.max(0, Math.min(1, Number(elem.routeProgress) || 0));
                    }
                    changed++;
                });
                if (changed > 0) {
                    this.saveHistory();
                    this.updatePropertiesPanel();
                    this.updateStatusBar();
                    this.refreshLayersPanel();
                }
            }

            resolveElementRouteState(elem, updateProgress) {
                if (!elem || typeof elem !== 'object') return { x: 0, y: 0, angle: 0, routeFound: false };

                const isMover = elem.type === 'mover';
                const defaultCenter = isMover
                    ? { x: Number.isFinite(elem.x) ? elem.x : 0, y: Number.isFinite(elem.y) ? elem.y : 0 }
                    : this.getElementCenterPoint(elem);
                const enabled = isMover ? true : Boolean(elem.followRoute);
                const routeId = String(elem.routeId || '');
                if (!enabled || !routeId) {
                    return { x: defaultCenter.x, y: defaultCenter.y, angle: 0, routeFound: false };
                }

                let route = this.getRouteElementById(routeId);
                if (!route) return { x: defaultCenter.x, y: defaultCenter.y, angle: 0, routeFound: false };
                let points = this.getRoutePoints(route);
                if (points.length <= 1) return { x: defaultCenter.x, y: defaultCenter.y, angle: 0, routeFound: false };

                const progressKey = isMover ? 'progress' : 'routeProgress';
                const rawProgress = Number(elem[progressKey]);
                let progress = Number.isFinite(rawProgress) ? rawProgress : 0;

                const dirRaw = isMover ? elem.flowDirection : (elem.routeDirection || elem.flowDirection);
                const dir = String(dirRaw || 'right') === 'left' ? -1 : 1;
                if (updateProgress && elem.active !== false) {
                    const rawSpeed = Number(isMover ? elem.speed : (elem.routeSpeed || elem.speed));
                    const speed = Number.isFinite(rawSpeed) ? Math.max(1, Math.min(300, rawSpeed)) : 40;
                    progress += dir * (speed / 12000);
                }
                const autoConnect = Boolean(elem.autoConnectRoute);
                if (autoConnect && (progress > 1 || progress < 0)) {
                    const next = this.findConnectedRoute(route, dir > 0);
                    if (next && next.route) {
                        route = next.route;
                        points = this.getRoutePoints(route);
                        elem.routeId = String(route.id);
                        progress = next.progress;
                        if (isMover) {
                            elem.flowDirection = next.direction;
                        } else {
                            elem.routeDirection = next.direction;
                        }
                    }
                }
                const routeMode = String(elem.routeMode || 'loop');
                if (routeMode === 'stop') {
                    if (progress <= 0) {
                        progress = 0;
                        if (updateProgress) elem.active = false;
                    } else if (progress >= 1) {
                        progress = 1;
                        if (updateProgress) elem.active = false;
                    }
                } else {
                    progress = ((progress % 1) + 1) % 1;
                }
                elem[progressKey] = progress;

                const p = this.getPointOnPolyline(points, progress);
                if (!p) return { x: defaultCenter.x, y: defaultCenter.y, angle: 0, routeFound: false };
                return this.applyPortalTeleport(elem, { x: p.x, y: p.y, angle: p.angle, routeFound: true });
            }

            resolveMoverState(elem, updateProgress) {
                return this.resolveElementRouteState(elem, updateProgress);
            }

            updateRouteFollowersInPlace() {
                this.walkElements(this.elements, (elem) => {
                    if (!elem || typeof elem !== 'object') return true;
                    if (elem.type === 'mover') return true; // mover se dibuja por estado din√°mico

                    if (!elem.followRoute || !elem.routeId) return true;
                    const state = this.resolveElementRouteState(elem, true);
                    if (!state.routeFound) return true;
                    const center = this.getElementCenterPoint(elem);
                    const dx = state.x - center.x;
                    const dy = state.y - center.y;
                    if (Number.isFinite(dx) && Number.isFinite(dy) && (Math.abs(dx) > 0.0001 || Math.abs(dy) > 0.0001)) {
                        this.offsetElement(elem, dx, dy);
                    }
                    return true;
                });
            }

            drawMover(elem) {
                const state = this.resolveMoverState(elem, true);
                const w = Math.max(16, Math.abs(Number(elem.width) || 44));
                const h = Math.max(16, Math.abs(Number(elem.height) || 28));
                const kind = String(elem.moverKind || 'metro');
                const baseColor =
                    kind === 'female' ? '#f472b6' :
                    (kind === 'male' ? '#3b82f6' : '#93c5fd');

                this.ctx.save();
                this.ctx.translate(state.x, state.y);
                this.ctx.rotate(state.angle);
                this.ctx.lineWidth = 2 / this.camera.zoom;
                this.ctx.strokeStyle = '#0b1027';
                this.ctx.fillStyle = baseColor;

                if (kind === 'metro') {
                    this.ctx.beginPath();
                    this.ctx.roundRect(-w / 2, -h / 2, w, h, Math.max(4, h * 0.2));
                    this.ctx.fill();
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#0b1027';
                    this.ctx.fillRect(-w * 0.28, -h * 0.18, w * 0.18, h * 0.3);
                    this.ctx.fillRect(-w * 0.02, -h * 0.18, w * 0.18, h * 0.3);
                    this.ctx.fillRect(w * 0.24, h * 0.18, w * 0.16, h * 0.12);
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(0, -h * 0.28, h * 0.18, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.moveTo(0, -h * 0.08);
                    this.ctx.lineTo(0, h * 0.22);
                    this.ctx.moveTo(0, h * 0.02);
                    this.ctx.lineTo(-w * 0.2, h * 0.08);
                    this.ctx.moveTo(0, h * 0.02);
                    this.ctx.lineTo(w * 0.2, h * 0.08);
                    this.ctx.moveTo(0, h * 0.22);
                    this.ctx.lineTo(-w * 0.18, h * 0.45);
                    this.ctx.moveTo(0, h * 0.22);
                    this.ctx.lineTo(w * 0.18, h * 0.45);
                    this.ctx.stroke();
                }

                if (!state.routeFound) {
                    this.ctx.fillStyle = '#f59e0b';
                    this.ctx.beginPath();
                    this.ctx.arc(0, -h * 0.58, h * 0.12, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.ctx.restore();
            }

	            drawElement(elem) {
	                if (elem.type === 'group' && Array.isArray(elem.elements)) {
	                    // Dibujar elementos dentro del grupo
	                    elem.elements.forEach(child => this.drawElement(child));

                    // Dibujar nombre si existe
                    if (this.shouldRenderElementLabels() && elem.name) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = `${12 / this.camera.zoom}px Arial`;
                        const textX = elem.x || 0;
                        const textY = elem.y || 0;
                        this.ctx.fillText(elem.name, textX, textY - 10 / this.camera.zoom);
                    }

                    // Indicador de bloqueado
	                    if (elem.locked) {
	                        this.ctx.fillStyle = '#ff9800';
	                        this.ctx.font = `${14 / this.camera.zoom}px Arial`;
	                        const lockX = elem.x || 0;
	                        const lockY = elem.y || 0;
	                        this.ctx.fillText('üîí', lockX, lockY);
	                    }

	                    // Badge de L√°mina (si el grupo es punto de informaci√≥n)
	                    if (this.isControlPoint(elem)) {
	                        this.drawControlPointBadgeForElement(elem);
	                    }
	                    return;

	                }

                const useDepthFx =
                    this.depthFx &&
                    this.readOnly &&
                    this.viewerMode &&
                    elem.type !== 'image' &&
                    elem.type !== 'video';

                if (useDepthFx) {
                    this.ctx.save();
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.42)';
                    this.ctx.shadowBlur = 26 / this.camera.zoom;
                    this.ctx.shadowOffsetX = 0;
                    this.ctx.shadowOffsetY = 16 / this.camera.zoom;
                }

	                if (elem.type === 'image') {
	                    // Dibujar imagen
	                    let img = elem.imageData;
	                    const isHtmlImage =
	                        (v) => v && typeof HTMLImageElement !== 'undefined' && v instanceof HTMLImageElement;
	
	                    // Si viene de JSON/undo, puede ser `imageData: {}` (rompe el render). Lo limpiamos.
	                    if (img && !isHtmlImage(img)) {
	                        img = null;
	                        try { delete elem.imageData; } catch {}
	                    }
	                    
	                    // Si no tenemos la imagen en memoria, intentar cargarla
	                    if (!img && this.loadedImages[elem.id]) {
	                        img = this.loadedImages[elem.id];
	                        elem.imageData = img;
                    } else if (!img && elem.imageSrc) {
                        // Cargar imagen desde base64
                        img = new Image();
                        img.onload = () => {
                            this.loadedImages[elem.id] = img;
                            elem.imageData = img;
                        };
                        img.src = elem.imageSrc;
                        return; // Esperar a que cargue
                    }
                    
	                    if (img && img.complete) {
	                        const didTransform = this.applyElementBoxTransformToContext(elem);
	                        this.ctx.globalAlpha = elem.opacity || 1;
	                        const crop = (elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) ? elem.crop : null;
	                        if (crop && Number.isFinite(crop.x) && Number.isFinite(crop.y) &&
	                            Number.isFinite(crop.w) && Number.isFinite(crop.h) &&
	                            crop.w > 0 && crop.h > 0) {
                            const sw = Number(img.naturalWidth) || Number(img.width) || 1;
                            const sh = Number(img.naturalHeight) || Number(img.height) || 1;
                            const sx = Math.max(0, Math.min(sw, crop.x * sw));
                            const sy = Math.max(0, Math.min(sh, crop.y * sh));
                            const sww = Math.max(1, Math.min(sw - sx, crop.w * sw));
                            const shh = Math.max(1, Math.min(sh - sy, crop.h * sh));
                            this.ctx.drawImage(img, sx, sy, sww, shh, elem.x, elem.y, elem.width, elem.height);
                        } else {
                            this.ctx.drawImage(img, elem.x, elem.y, elem.width, elem.height);
                        }
                        this.ctx.globalAlpha = 1;
                        
                        // Borde de selecci√≥n si est√° seleccionado
	                        if (this.selectedElements.includes(elem)) {
	                            this.ctx.strokeStyle = '#e94560';
	                            this.ctx.lineWidth = 2 / this.camera.zoom;
	                            this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
	                        }
	                        this.restoreElementBoxTransform(didTransform);
	                    }
                    
                } else if (elem.type === 'video') {
                    // Dibujar video (HTMLVideoElement) como capa dentro del canvas
                    let vid = elem.videoData;
                    const isHtmlVideo =
                        (v) => v && typeof HTMLVideoElement !== 'undefined' && v instanceof HTMLVideoElement;

                    // Si viene de JSON/undo puede ser `videoData: {}`.
                    if (vid && !isHtmlVideo(vid)) {
                        vid = null;
                        try { delete elem.videoData; } catch {}
                    }

                    if (!vid && this.loadedVideos[elem.id]) {
                        vid = this.loadedVideos[elem.id];
                        elem.videoData = vid;
                    } else if (!vid && elem.videoSrc) {
                        vid = document.createElement('video');
                        vid.src = elem.videoSrc;
                        vid.loop = elem.loop !== false;
                        vid.muted = elem.muted !== false;
                        vid.playsInline = true;
                        vid.preload = 'auto';

                        // Cachear antes para evitar recreaci√≥n por frame.
                        this.loadedVideos[elem.id] = vid;
                        elem.videoData = vid;

                        vid.addEventListener('loadedmetadata', () => {
                            const vw = Number(vid.videoWidth) || 1;
                            const vh = Number(vid.videoHeight) || 1;
                            if (!Number.isFinite(Number(elem.originalWidth)) || Number(elem.originalWidth) <= 0) elem.originalWidth = vw;
                            if (!Number.isFinite(Number(elem.originalHeight)) || Number(elem.originalHeight) <= 0) elem.originalHeight = vh;
                            if (!Number.isFinite(Number(elem.width)) || Number(elem.width) <= 0) elem.width = vw;
                            if (!Number.isFinite(Number(elem.height)) || Number(elem.height) <= 0) elem.height = vh;

                            // Autoplay muted suele estar permitido.
                            if (elem.active !== false && (elem.autoplay !== false)) {
                                const p = vid.play();
                                if (p && typeof p.catch === 'function') p.catch(() => {});
                            }
                        }, { once: true });

                        vid.addEventListener('ended', () => { vid._flowPlayRequested = false; });
                        vid.addEventListener('error', () => {
                            elem.connectionStatus = 'error';
                            vid._flowPlayRequested = false;
                        });

                        try { vid.load(); } catch {}
                    }

	                    if (vid) {
	                        const didTransform = this.applyElementBoxTransformToContext(elem);
	                        const shouldPlay = elem.active !== false;
	                        if (!shouldPlay) {
	                            try { if (!vid.paused) vid.pause(); } catch {}
	                            vid._flowPlayRequested = false;
	                        } else if (vid.paused && !vid._flowPlayRequested && elem.autoplay !== false) {
                            vid._flowPlayRequested = true;
                            const p = vid.play();
                            if (p && typeof p.catch === 'function') {
                                p.catch(() => { vid._flowPlayRequested = false; });
                            }
                        }

                        // Dibujar frame si ya hay data suficiente
                        if (vid.readyState >= 2) { // HAVE_CURRENT_DATA
                            this.ctx.globalAlpha = elem.opacity || 1;
                            const crop = (elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) ? elem.crop : null;
                            if (crop && Number.isFinite(crop.x) && Number.isFinite(crop.y) &&
                                Number.isFinite(crop.w) && Number.isFinite(crop.h) &&
                                crop.w > 0 && crop.h > 0) {
                                const sw = Number(vid.videoWidth) || 1;
                                const sh = Number(vid.videoHeight) || 1;
                                const sx = Math.max(0, Math.min(sw, crop.x * sw));
                                const sy = Math.max(0, Math.min(sh, crop.y * sh));
                                const sww = Math.max(1, Math.min(sw - sx, crop.w * sw));
                                const shh = Math.max(1, Math.min(sh - sy, crop.h * sh));
                                this.ctx.drawImage(vid, sx, sy, sww, shh, elem.x, elem.y, elem.width, elem.height);
                            } else {
                                this.ctx.drawImage(vid, elem.x, elem.y, elem.width, elem.height);
                            }
                            this.ctx.globalAlpha = 1;
                        } else {
                            // Placeholder mientras carga
                            this.ctx.save();
                            this.ctx.globalAlpha = 0.9;
                            this.ctx.fillStyle = 'rgba(15, 52, 96, 0.6)';
                            this.ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
                            this.ctx.strokeStyle = '#e94560';
                            this.ctx.lineWidth = 2 / this.camera.zoom;
                            this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = `${12 / this.camera.zoom}px Arial`;
                            this.ctx.fillText('Video (cargando...)', elem.x + 10 / this.camera.zoom, elem.y + 20 / this.camera.zoom);
                            this.ctx.restore();
                        }

                        // Borde de selecci√≥n si est√° seleccionado
	                        if (this.selectedElements.includes(elem)) {
	                            this.ctx.strokeStyle = '#e94560';
	                            this.ctx.lineWidth = 2 / this.camera.zoom;
	                            this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
	                        }
	                        this.restoreElementBoxTransform(didTransform);
	                    }

		                } else if (elem.type === 'portal') {
                            const didTransform = this.applyElementBoxTransformToContext(elem);
                            const cx = elem.x + (elem.width / 2);
                            const cy = elem.y + (elem.height / 2);
                            const r = Math.max(8, Math.min(Math.abs(elem.width), Math.abs(elem.height)) / 2);
                            const kind = String(elem.portalKind || 'import');
                            const ring = kind === 'import' ? '#22d3ee' : '#a78bfa';

                            this.ctx.save();
                            this.ctx.lineWidth = Math.max(2 / this.camera.zoom, this.getElementLineWidth(elem) / this.camera.zoom);
                            this.ctx.strokeStyle = ring;
                            this.ctx.fillStyle = 'rgba(11,16,39,0.45)';
                            this.ctx.beginPath();
                            this.ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            this.ctx.fill();
                            this.ctx.stroke();

                            this.ctx.strokeStyle = '#ffffff';
                            this.ctx.lineWidth = 2 / this.camera.zoom;
                            this.ctx.beginPath();
                            if (kind === 'import') {
                                this.ctx.moveTo(cx + r * 0.45, cy - r * 0.45);
                                this.ctx.lineTo(cx - r * 0.15, cy);
                                this.ctx.lineTo(cx + r * 0.45, cy + r * 0.45);
                            } else {
                                this.ctx.moveTo(cx - r * 0.45, cy - r * 0.45);
                                this.ctx.lineTo(cx + r * 0.15, cy);
                                this.ctx.lineTo(cx - r * 0.45, cy + r * 0.45);
                            }
                            this.ctx.stroke();
                            this.ctx.restore();
                            this.restoreElementBoxTransform(didTransform);
	                    } else if (elem.type === 'rectangle') {
		                    const didTransform = this.applyElementBoxTransformToContext(elem);
		                    const fillColor = this.normalizeCanvasColor(elem.fillColor);
		                    const strokeColor = this.normalizeCanvasColor(elem.strokeColor);
		                    const doFill = !this.isTransparentColor(fillColor);
		                    const doStroke = !this.isTransparentColor(strokeColor);
		                    const fg = this.normalizeFillGradientSpec(elem.fillGradient);

	                    this.ctx.lineWidth = this.getElementLineWidth(elem) / this.camera.zoom;
	                    if (fg) {
	                        const bounds = { minX: elem.x, minY: elem.y, maxX: elem.x + elem.width, maxY: elem.y + elem.height };
	                        const grad = this.createLinearGradientForBounds(bounds, fg.angle, fg.a, fg.b);
	                        if (grad) {
	                            this.ctx.fillStyle = grad;
	                            this.ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
	                        } else if (doFill) {
	                            this.ctx.fillStyle = fillColor;
	                            this.ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
	                        }
	                    } else if (doFill) {
	                        this.ctx.fillStyle = fillColor;
	                        this.ctx.fillRect(elem.x, elem.y, elem.width, elem.height);
	                    }
	                    if (doStroke) {
	                        this.ctx.strokeStyle = strokeColor;
	                        this.ctx.strokeRect(elem.x, elem.y, elem.width, elem.height);
	                    }
                    
	                    // Indicador de conexi√≥n
	                    this.drawConnectionIndicator(elem, elem.x + elem.width, elem.y);
	                    this.restoreElementBoxTransform(didTransform);
	                    
		                } else if (elem.type === 'circle') {
		                    const didTransform = this.applyElementBoxTransformToContext(elem);
		                    const centerX = elem.x + elem.width / 2;
		                    const centerY = elem.y + elem.height / 2;
		                    const radiusX = Math.abs(elem.width / 2);
		                    const radiusY = Math.abs(elem.height / 2);

	                    const fillColor = this.normalizeCanvasColor(elem.fillColor);
	                    const strokeColor = this.normalizeCanvasColor(elem.strokeColor);
	                    const doFill = !this.isTransparentColor(fillColor);
	                    const doStroke = !this.isTransparentColor(strokeColor);
	                    const fg = this.normalizeFillGradientSpec(elem.fillGradient);
	                    this.ctx.lineWidth = this.getElementLineWidth(elem) / this.camera.zoom;
	                    
	                    this.ctx.beginPath();
	                    this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
	                    if (fg) {
	                        const bounds = { minX: elem.x, minY: elem.y, maxX: elem.x + elem.width, maxY: elem.y + elem.height };
	                        const grad = this.createLinearGradientForBounds(bounds, fg.angle, fg.a, fg.b);
	                        if (grad) {
	                            this.ctx.fillStyle = grad;
	                            this.ctx.fill();
	                        } else if (doFill) {
	                            this.ctx.fillStyle = fillColor;
	                            this.ctx.fill();
	                        }
	                    } else if (doFill) {
	                        this.ctx.fillStyle = fillColor;
	                        this.ctx.fill();
	                    }
	                    if (doStroke) {
	                        this.ctx.strokeStyle = strokeColor;
	                        this.ctx.stroke();
	                    }
                    
	                    // Indicador de conexi√≥n
	                    this.drawConnectionIndicator(elem, centerX + radiusX, centerY);
	                    this.restoreElementBoxTransform(didTransform);
	                    
                } else if (elem.type === 'line') {
                    // Dibujar l√≠nea
                    const strokeColor = this.normalizeCanvasColor(elem.strokeColor);
                    const doStroke = !this.isTransparentColor(strokeColor);
                    const isRoute = this.isRouteElement(elem);
                    const curve = this.getRouteCurve(elem);
                    const isCurvedRoute = Boolean(isRoute && curve !== 'line');
                    this.ctx.strokeStyle = strokeColor;
                    this.ctx.lineWidth = this.getElementLineWidth(elem) / this.camera.zoom;
                    
                    if (doStroke) {
                        if (isCurvedRoute) {
                            const pts = this.getRoutePoints(elem);
                            if (pts.length > 1) {
                                this.ctx.save();
                                this.ctx.lineCap = 'round';
                                this.ctx.lineJoin = 'round';
                                this.ctx.beginPath();
                                this.ctx.moveTo(pts[0].x, pts[0].y);
                                for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
                                this.ctx.stroke();
                                this.ctx.strokeStyle = 'rgba(255,255,255,0.45)';
                                this.ctx.lineWidth = Math.max(1 / this.camera.zoom, this.ctx.lineWidth * 0.35);
                                this.ctx.beginPath();
                                this.ctx.moveTo(pts[0].x, pts[0].y);
                                for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
                                this.ctx.stroke();
                                this.ctx.restore();
                            }
                        } else if (isRoute) {
                            this.ctx.save();
                            this.ctx.lineCap = 'round';
                            this.ctx.lineJoin = 'round';
                            this.ctx.beginPath();
                            this.ctx.moveTo(elem.x, elem.y);
                            this.ctx.lineTo(elem.endX, elem.endY);
                            this.ctx.stroke();

                            this.ctx.strokeStyle = 'rgba(255,255,255,0.45)';
                            this.ctx.lineWidth = Math.max(1 / this.camera.zoom, this.ctx.lineWidth * 0.35);
                            this.ctx.beginPath();
                            this.ctx.moveTo(elem.x, elem.y);
                            this.ctx.lineTo(elem.endX, elem.endY);
                            this.ctx.stroke();
                            this.ctx.restore();
                        } else {
                            this.ctx.beginPath();
                            this.ctx.moveTo(elem.x, elem.y);
                            this.ctx.lineTo(elem.endX, elem.endY);
                            this.ctx.stroke();
                        }
                    }
                    
                    // Animaci√≥n de flujo
                    if (elem.active) {
                        this.drawFlowAnimation(elem);
                    }
                    
                    // Indicador de conexi√≥n
                    if (isCurvedRoute) {
                        const pts = this.getRoutePoints(elem);
                        const mid = pts[Math.floor(pts.length / 2)] || { x: elem.x, y: elem.y };
                        this.drawConnectionIndicator(elem, mid.x, mid.y);
                    } else {
                        this.drawConnectionIndicator(elem, elem.endX, elem.endY);
                    }
                    
	                } else if (elem.type === 'path' || elem.type === 'polygon') {
	                    // Dibujar trazado libre o pol√≠gono cerrado
	                    if (elem.points && elem.points.length > 1) {
	                        const strokeColor = this.normalizeCanvasColor(elem.strokeColor);
	                        const fillColor = this.normalizeCanvasColor(elem.fillColor);
	                        const doStroke = !this.isTransparentColor(strokeColor);
	                        const doFill = !this.isTransparentColor(fillColor);
	                        const fg = this.normalizeFillGradientSpec(elem.fillGradient);

	                        this.ctx.strokeStyle = strokeColor;
	                        this.ctx.lineWidth = this.getElementLineWidth(elem) / this.camera.zoom;
	                        this.ctx.lineCap = 'round';
	                        this.ctx.lineJoin = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(elem.points[0].x, elem.points[0].y);
                        
                        for (let i = 1; i < elem.points.length; i++) {
                            this.ctx.lineTo(elem.points[i].x, elem.points[i].y);
                        }
                        
	                        // Si es pol√≠gono cerrado, cerrar y rellenar
	                        if (elem.type === 'polygon' || elem.closed) {
	                            this.ctx.closePath();
	                            if (fg) {
	                                const bounds = this.getElementBounds(elem);
	                                const grad = bounds ? this.createLinearGradientForBounds(bounds, fg.angle, fg.a, fg.b) : null;
	                                if (grad) {
	                                    this.ctx.fillStyle = grad;
	                                    this.ctx.fill();
	                                } else if (doFill) {
	                                    this.ctx.fillStyle = fillColor;
	                                    this.ctx.fill();
	                                }
	                            } else if (doFill) {
	                                this.ctx.fillStyle = fillColor;
	                                this.ctx.fill();
	                            }
	                        }
	                        
	                        if (doStroke) this.ctx.stroke();
	                    }
	                } else if (elem.type === 'mover') {
                        this.drawMover(elem);
	                }

                // Etiquetas sin sombra (solo el "volumen" del elemento).
	                if (useDepthFx) {
	                    this.ctx.shadowColor = 'transparent';
	                    this.ctx.shadowBlur = 0;
	                    this.ctx.shadowOffsetX = 0;
	                    this.ctx.shadowOffsetY = 0;
	                }

	                // Badge de L√°mina (Punto de Informaci√≥n)
	                if (this.isControlPoint(elem)) {
	                    this.drawControlPointBadgeForElement(elem);
	                }
	                
	                // Dibujar nombre si existe
                if (this.shouldRenderElementLabels() && elem.name && elem.type !== 'image' && elem.type !== 'video') {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = `${12 / this.camera.zoom}px Arial`;
                    const moverState = elem.type === 'mover' ? this.resolveMoverState(elem, false) : null;
                    const textX = moverState ? moverState.x : (elem.x || (elem.points ? elem.points[0].x : 0));
                    const textY = moverState ? moverState.y : (elem.y || (elem.points ? elem.points[0].y : 0));
                    this.ctx.fillText(elem.name, textX, textY - 10 / this.camera.zoom);
                }
                
                // Indicador de bloqueado
                if (elem.locked) {
                    this.ctx.fillStyle = '#ff9800';
                    this.ctx.font = `${14 / this.camera.zoom}px Arial`;
                    const moverState = elem.type === 'mover' ? this.resolveMoverState(elem, false) : null;
                    const lockX = moverState ? moverState.x : (elem.x || (elem.points ? elem.points[0].x : 0));
                    const lockY = moverState ? moverState.y : (elem.y || (elem.points ? elem.points[0].y : 0));
                    this.ctx.fillText('üîí', lockX, lockY);
                }

                if (useDepthFx) {
                    this.ctx.restore();
                }
            }
            
            drawFlowAnimation(elem) {
                const dashLength = 20;
                const gapLength = 10;
                const particleSize = 4;
                
                // Actualizar offset de animaci√≥n
                const rawSpeed = Number(elem.speed);
                const step = Number.isFinite(rawSpeed) ? Math.min(Math.max(Math.abs(rawSpeed), 0.25), 50) : 2;
                if (elem.flowDirection === 'right') {
                    elem.animOffset = (elem.animOffset + step) % (dashLength + gapLength);
                } else {
                    elem.animOffset = (elem.animOffset - step) % (dashLength + gapLength);
                    if (elem.animOffset < 0) elem.animOffset += (dashLength + gapLength);
                }

                if (this.getRouteCurve(elem) !== 'line') {
                    const points = this.getRoutePoints(elem);
                    if (points.length < 2) return;
                    let length = this.getPolylineLength(points);
                    if (length <= 0) return;
                    this.ctx.fillStyle = elem.animColor || '#4caf50';
                    for (let i = elem.animOffset; i < length; i += dashLength + gapLength) {
                        const p = this.getPointOnPolyline(points, i / length);
                        if (!p) continue;
                        this.ctx.beginPath();
                        this.ctx.arc(p.x, p.y, particleSize / this.camera.zoom, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    return;
                }
                
                const dx = elem.endX - elem.x;
                const dy = elem.endY - elem.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return;
                
                const dirX = dx / length;
                const dirY = dy / length;
                
                // Dibujar part√≠culas animadas
                this.ctx.fillStyle = elem.animColor || '#4caf50';
                
                for (let i = elem.animOffset; i < length; i += dashLength + gapLength) {
                    const x = elem.x + dirX * i;
                    const y = elem.y + dirY * i;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, particleSize / this.camera.zoom, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
	            drawConnectionIndicator(elem, x, y) {
	                // En puntos de informaci√≥n, ocultar el indicador si no aplica.
	                if (this.isControlPoint(elem) && String(elem.connectionStatus || 'none') === 'none') {
	                    return;
	                }

	                const size = 12 / this.camera.zoom;
	                
	                let color;
	                switch(elem.connectionStatus) {
                    case 'connected':
                        color = '#4caf50';
                        break;
                    case 'error':
                        color = '#f44336';
                        break;
                    default:
                        color = 'rgba(255, 255, 255, 0.3)';
                }
                
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                if (elem.connectionStatus === 'connected') {
                    this.ctx.shadowBlur = 10 / this.camera.zoom;
                    this.ctx.shadowColor = color;
                    this.ctx.fill();
	                    this.ctx.shadowBlur = 0;
	                }
	            }

	            drawControlPointBadgeForElement(elem) {
	                const n = this.getControlPointOrder(elem);
	                if (!Number.isFinite(Number(n))) return;

	                const zoom = this.camera.zoom || 1;
	                const radius = 11 / zoom;
	                const pad = 12 / zoom;

	                let bx = null;
	                let by = null;

	                if (elem.type === 'circle' && Number.isFinite(elem.x) && Number.isFinite(elem.y) &&
	                    Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
	                    bx = elem.x + elem.width / 2;
	                    by = elem.y + elem.height / 2;
	                } else {
	                    const b = this.getElementBounds(elem);
	                    if (!b) return;
	                    bx = b.minX + pad;
	                    by = b.minY + pad;
	                }

	                this.ctx.save();
	                this.ctx.shadowColor = 'transparent';
	                this.ctx.shadowBlur = 0;
	                this.ctx.shadowOffsetX = 0;
	                this.ctx.shadowOffsetY = 0;

	                this.ctx.beginPath();
	                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.62)';
	                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.85)';
	                this.ctx.lineWidth = 1 / zoom;
	                this.ctx.arc(bx, by, radius, 0, Math.PI * 2);
	                this.ctx.fill();
	                this.ctx.stroke();

	                this.ctx.fillStyle = '#ffffff';
	                this.ctx.font = `800 ${12 / zoom}px Segoe UI, Arial`;
	                this.ctx.textAlign = 'center';
	                this.ctx.textBaseline = 'middle';
	                this.ctx.fillText(String(Math.round(Number(n))), bx, by + (0.5 / zoom));

	                this.ctx.restore();
	            }
	            
	            drawResizeHandles(elem) {
	                if (elem.locked || elem.type === 'group') return;
	                
	                const handles = this.getResizeHandles(elem);
                const handleSize = 8 / this.camera.zoom;
                
                handles.forEach(handle => {
                    // Dibujar cuadrado blanco con borde rojo
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.strokeStyle = '#e94560';
                    this.ctx.lineWidth = 2 / this.camera.zoom;
                    
                    this.ctx.fillRect(
                        handle.x - handleSize / 2,
                        handle.y - handleSize / 2,
                        handleSize,
                        handleSize
                    );
                    
                    this.ctx.strokeRect(
                        handle.x - handleSize / 2,
                        handle.y - handleSize / 2,
                        handleSize,
                        handleSize
                    );
                });
            }
            
            drawSelection(elem) {
                this.ctx.strokeStyle = '#e94560';
                this.ctx.lineWidth = 2 / this.camera.zoom;
                this.ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]);
                
                this.drawElementOutline(elem);
                
                this.ctx.setLineDash([]);
            }
            
            drawElementOutline(elem) {
                if (elem.type === 'rectangle') {
                    this.ctx.strokeRect(elem.x - 5 / this.camera.zoom, 
                                       elem.y - 5 / this.camera.zoom, 
                                       elem.width + 10 / this.camera.zoom, 
                                       elem.height + 10 / this.camera.zoom);
                } else if (elem.type === 'group') {
                    this.ensureGroupBounds(elem);
                    this.ctx.strokeRect(elem.x - 5 / this.camera.zoom, 
                                       elem.y - 5 / this.camera.zoom, 
                                       elem.width + 10 / this.camera.zoom, 
                                       elem.height + 10 / this.camera.zoom);
                } else if (elem.type === 'circle') {
                    const centerX = elem.x + elem.width / 2;
                    const centerY = elem.y + elem.height / 2;
                    const radiusX = Math.abs(elem.width / 2) + 5 / this.camera.zoom;
                    const radiusY = Math.abs(elem.height / 2) + 5 / this.camera.zoom;
                    
                    this.ctx.beginPath();
                    this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else if (elem.type === 'line') {
                    if (this.getRouteCurve(elem) !== 'line') {
                        const pts = this.getRoutePoints(elem);
                        if (pts.length > 1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(pts[0].x, pts[0].y);
                            for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
                            this.ctx.stroke();
                        }
                    } else {
                        this.ctx.beginPath();
                        this.ctx.moveTo(elem.x, elem.y);
                        this.ctx.lineTo(elem.endX, elem.endY);
                        this.ctx.stroke();
                    }
                } else if (elem.type === 'mover') {
                    const state = this.resolveMoverState(elem, false);
                    const w = Math.max(16, Math.abs(Number(elem.width) || 44)) + (10 / this.camera.zoom);
                    const h = Math.max(16, Math.abs(Number(elem.height) || 28)) + (10 / this.camera.zoom);
                    this.ctx.strokeRect(state.x - (w / 2), state.y - (h / 2), w, h);
                } else if ((elem.type === 'path' || elem.type === 'polygon') && elem.points && elem.points.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(elem.points[0].x, elem.points[0].y);
                    for (let i = 1; i < elem.points.length; i++) {
                        this.ctx.lineTo(elem.points[i].x, elem.points[i].y);
                    }
                    this.ctx.stroke();
                }
            }
            
            // ==================== ANIMACI√ìN ====================
            
            startAnimationLoop() {
                const animate = () => {
                    this.render();
                    requestAnimationFrame(animate);
                };
                animate();
            }
            
            // ==================== ACCIONES ====================
            
            groupElements() {
                if (this.selectedElements.length < 2) {
                    alert('Selecciona al menos 2 elementos para agrupar');
                    return;
                }
                
                const group = {
                    id: Date.now() + Math.random(),
                    type: 'group',
                    elements: [...this.selectedElements],
                    locked: false,
                    active: true,
                    connectionStatus: 'none',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    name: 'Grupo'
                };
                
                // Calcular bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                group.elements.forEach(elem => {
                    if (!elem || typeof elem !== 'object') return;

                    if (elem.type === 'line') {
                        minX = Math.min(minX, elem.x, elem.endX);
                        minY = Math.min(minY, elem.y, elem.endY);
                        maxX = Math.max(maxX, elem.x, elem.endX);
                        maxY = Math.max(maxY, elem.y, elem.endY);
                        return;
                    }

                    if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                        elem.points.forEach(p => {
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                            maxX = Math.max(maxX, p.x);
                            maxY = Math.max(maxY, p.y);
                        });
                        return;
                    }

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        const bounds = this.getElementsBounds(elem.elements);
                        if (bounds) {
                            minX = Math.min(minX, bounds.minX);
                            minY = Math.min(minY, bounds.minY);
                            maxX = Math.max(maxX, bounds.maxX);
                            maxY = Math.max(maxY, bounds.maxY);
                        }
                        return;
                    }

                    if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
                        typeof elem.width === 'number' && typeof elem.height === 'number') {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        minX = Math.min(minX, x1);
                        minY = Math.min(minY, y1);
                        maxX = Math.max(maxX, x2);
                        maxY = Math.max(maxY, y2);
                    }
                });
                
                if (!Number.isFinite(minX)) {
                    minX = 0;
                    minY = 0;
                    maxX = 0;
                    maxY = 0;
                }

                group.x = minX;
                group.y = minY;
                group.width = maxX - minX;
                group.height = maxY - minY;
                
                // Remover elementos individuales
                this.selectedElements.forEach(elem => {
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) this.elements.splice(idx, 1);
                });
                
                this.elements.push(group);
                this.selectedElements = [group];
                this.saveHistory();
                this.updatePropertiesPanel();
            }
            
            ungroupElements() {
                const groups = this.selectedElements.filter(e => e.type === 'group');
                
                if (groups.length === 0) {
                    alert('Selecciona un grupo para desagrupar');
                    return;
                }
                
                groups.forEach(group => {
                    const idx = this.elements.indexOf(group);
                    if (idx >= 0) {
                        this.elements.splice(idx, 1);
                        this.elements.push(...group.elements);
                    }
                });
                
                this.selectedElements = [];
                this.saveHistory();
            }
            
            toggleLock() {
                this.selectedElements.forEach(elem => {
                    elem.locked = !elem.locked;
                });
                this.saveHistory();
                this.updatePropertiesPanel();
                this.updateStatusBar();
            }
            
	            copyElements() {
	                if (this.selectedElements.length > 0) {
	                    this.clipboard = JSON.parse(JSON.stringify(this.selectedElements, (key, value) => {
	                        if (key === 'imageData') return undefined;
	                        if (key === 'videoData') return undefined;
	                        return value;
	                    }));
	                }
	            }
            
            pasteElements() {
                if (!this.clipboard) return;
                
                const pasted = JSON.parse(JSON.stringify(this.clipboard));
                
                pasted.forEach(elem => {
                    const idMap = this.assignNewIdsRecursive(elem);
                    
                    // Copiar referencias de im√°genes (si aplica)
                    idMap.forEach((newId, oldId) => {
                        if (this.loadedImages[oldId]) {
                            this.loadedImages[newId] = this.loadedImages[oldId];
                        }
                    });
                    
                    this.offsetElement(elem, 20, 20);
                });
                
                this.elements.push(...pasted);
                this.selectedElements = pasted;
                this.saveHistory();
                this.updatePropertiesPanel();
            }
            
            deleteElements() {
                this.selectedElements.forEach(elem => {
                    const idx = this.elements.indexOf(elem);
                    if (idx >= 0) this.elements.splice(idx, 1);
                });
                
                this.selectedElements = [];
                this.saveHistory();
                this.hidePropertiesPanel();
                this.updateStatusBar();
            }
            
            zoomIn() {
                this.camera.zoom = Math.min(5, this.camera.zoom * 1.2);
                this.updateZoomIndicator();
            }
            
            zoomOut() {
                this.camera.zoom = Math.max(0.1, this.camera.zoom / 1.2);
                this.updateZoomIndicator();
            }
            
            resetZoom() {
                this.camera.zoom = 1;
                this.camera.x = 0;
                this.camera.y = 0;
                this.updateZoomIndicator();
            }
            
            // ==================== HISTORIAL ====================
            
	            saveHistory() {
	                // Importante: quitar campos runtime/no-serializables (ej: imageData) o se rompe undo/guardar.
	                const state = JSON.stringify(this.elements, (key, value) => {
	                    if (key === 'imageData') return undefined;
	                    if (key === 'videoData') return undefined;
	                    return value;
	                });
	                
	                // Eliminar historia futura si estamos en medio
	                if (this.historyIndex < this.history.length - 1) {
	                    this.history = this.history.slice(0, this.historyIndex + 1);
	                }
                
                this.history.push(state);
                this.historyIndex++;
                
                // Limitar historial a 50 estados
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }

                this.refreshLayersPanel();
            }

            scheduleNudgeHistorySave() {
                if (this._nudgeHistoryTimer) {
                    clearTimeout(this._nudgeHistoryTimer);
                }
                this._nudgeHistoryTimer = setTimeout(() => {
                    this._nudgeHistoryTimer = null;
                    this.saveHistory();
                }, 250);
            }
            
	            undo() {
	                if (this.historyIndex > 0) {
	                    this.historyIndex--;
	                    this.elements = JSON.parse(this.history[this.historyIndex]);
	                    // Re-normalizar (quita basura como imageData:{} y repara defaults).
	                    this.normalizeProjectInPlace({ elements: this.elements, camera: this.camera });
	                    this.selectedElements = [];
	                    this.hidePropertiesPanel();
	                    this.updateStatusBar();
	                    this.refreshDeckUI();
	                    this.refreshLayersPanel();
	                }
	            }
            
            // ==================== PERSISTENCIA ====================
            
            showSaveModal() {
                document.getElementById('save-modal').classList.add('show');
                document.getElementById('project-name').focus();
            }
            
            hideSaveModal() {
                document.getElementById('save-modal').classList.remove('show');
            }
            
	            saveProject() {
	                const name = document.getElementById('project-name').value || 'proyecto-sin-nombre';

	                const safeElements = JSON.parse(JSON.stringify(this.elements, (key, value) => {
	                    if (key === 'imageData') return undefined;
	                    if (key === 'videoData') return undefined;
	                    return value;
	                }));
	                const safeCamera = JSON.parse(JSON.stringify(this.camera || { x: 0, y: 0, zoom: 1 }));
	                
	                const projectData = {
	                    name: name,
	                    date: new Date().toISOString(),
	                    elements: safeElements,
	                    camera: safeCamera
	                };
	                
	                // Guardar en localStorage (tolerante a storage bloqueado o datos corruptos)
	                const parsed = safeLocalStorageGetJSON('flow-diagrams', []);
	                const projects = Array.isArray(parsed) ? parsed : [];
	                projects.push(projectData);
	                safeLocalStorageSetJSON('flow-diagrams', projects);
                
                alert(`Proyecto "${name}" guardado exitosamente`);
                this.hideSaveModal();
                document.getElementById('project-name').value = '';
            }

            setupPublishKey() {
                const keyInput = document.getElementById('publish-key');
                if (!keyInput) return;

                const stored = safeLocalStorageGet('flow-diagram-publish-key', '') || '';
                keyInput.value = String(stored);

                keyInput.addEventListener('input', () => {
                    const v = String(keyInput.value || '');
                    if (v) {
                        safeLocalStorageSet('flow-diagram-publish-key', v);
                    } else {
                        safeLocalStorageRemove('flow-diagram-publish-key');
                    }
                });
            }

            getPublishKey() {
                const keyInput = document.getElementById('publish-key');
                const v = keyInput ? String(keyInput.value || '').trim() : '';
                if (v) return v;

                const stored = safeLocalStorageGet('flow-diagram-publish-key', null);
                return stored ? String(stored).trim() : '';
            }

            showPublishModal(intent) {
                const parsed = String(intent || '').toLowerCase();
                this.publishIntent = parsed === 'project' ? 'project' : (parsed === 'sticker' ? 'sticker' : 'vector');

                const modal = document.getElementById('publish-modal');
                const result = document.getElementById('publish-result');
                const btnConfirmVector = document.getElementById('btn-confirm-publish');
                const btnConfirmProject = document.getElementById('btn-confirm-publish-project');
                modal.classList.add('show');
                document.getElementById('publish-name').value = '';
                document.getElementById('publish-folder').value = this.publishIntent === 'sticker' ? 'stickers' : '';
                const keyInput = document.getElementById('publish-key');
                if (keyInput) keyInput.value = safeLocalStorageGet('flow-diagram-publish-key', '') || '';
                const modeHint = document.getElementById('publish-mode-hint');
                if (modeHint) {
                    modeHint.innerHTML =
                        this.publishIntent === 'project'
                            ? '<strong>Seleccionado: Proyecto</strong> (permite im√°genes/fondo; sube assets). <strong>Vector:</strong> sin im√°genes (sticker/biblioteca).'
                            : (this.publishIntent === 'sticker'
                                ? '<strong>Seleccionado: Stiker</strong> (sin im√°genes; carpeta por defecto: <code>stickers</code>). <strong>Proyecto:</strong> permite im√°genes/fondo.'
                                : '<strong>Seleccionado: Vector</strong> (sin im√°genes; sticker/biblioteca). <strong>Proyecto:</strong> permite im√°genes/fondo (sube assets).');
                }
                if (btnConfirmVector) {
                    btnConfirmVector.textContent = this.publishIntent === 'sticker' ? 'Publicar Stiker' : 'Publicar Vector';
                    btnConfirmVector.style.display = 'inline-flex';
                }
                if (btnConfirmProject) {
                    btnConfirmProject.style.display = this.publishIntent === 'project' ? 'inline-flex' : 'none';
                }

                document.getElementById('publish-name').focus();
                result.style.display = 'none';
                result.textContent = '';

                // Reset estado de publicaci√≥n desde archivo
                this.publishFileProject = null;
                this.publishFileName = '';
                this.updatePublishFileUI();

                // Reset "pegar JSON"
                const pasteBox = document.getElementById('publish-paste-box');
                if (pasteBox) pasteBox.style.display = 'none';
                const pasteText = document.getElementById('publish-json-text');
                if (pasteText) pasteText.value = '';
            }

            hidePublishModal() {
                document.getElementById('publish-modal').classList.remove('show');
            }

            updatePublishFileUI(messageOverride) {
                const status = document.getElementById('publish-file-status');
                const btnClear = document.getElementById('btn-clear-publish-file');
                if (!status || !btnClear) return;

                if (messageOverride) {
                    status.textContent = messageOverride;
                    btnClear.style.display = this.publishFileProject ? 'inline-flex' : 'none';
                    return;
                }

                if (this.publishFileProject) {
                    status.textContent = `Fuente: Archivo JSON (${this.publishFileName || 'seleccionado'})`;
                    btnClear.style.display = 'inline-flex';
                } else {
                    status.textContent = 'Fuente: Canvas actual';
                    btnClear.style.display = 'none';
                }
            }

            pickPublishFile() {
                document.getElementById('publish-file-input').click();
            }

            clearPublishFile() {
                this.publishFileProject = null;
                this.publishFileName = '';
                this.updatePublishFileUI();
            }

            onPublishFileSelected(e) {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                this.publishFileName = file.name || '';
                this.updatePublishFileUI('Leyendo archivo...');

                const reader = new FileReader();
                reader.onload = (event) => {
                    let data;
                    try {
                        data = JSON.parse(String(event.target.result || ''));
                    } catch (error) {
                        this.publishFileProject = null;
                        this.updatePublishFileUI('‚ùå JSON inv√°lido (no se pudo parsear).');
                        return;
                    }

                    if (!data || typeof data !== 'object' || !Array.isArray(data.elements)) {
                        this.publishFileProject = null;
                        this.updatePublishFileUI('‚ùå El JSON no parece un proyecto v√°lido (falta "elements").');
                        return;
                    }

                    // Normalizar para aceptar JSON "IA-friendly" (radius/x1/y1/...).
                    this.normalizeProjectInPlace(data);
                    this.publishFileProject = data;
                    this.updatePublishFileUI();

                    // Auto-sugerir nombre si el usuario a√∫n no puso uno.
                    const nameInput = document.getElementById('publish-name');
                    if (nameInput && !String(nameInput.value || '').trim()) {
                        const fromJson = (typeof data.name === 'string' && data.name.trim()) ? data.name.trim() : '';
                        const base = String(this.publishFileName || '').replace(/\.json$/i, '').trim();
                        nameInput.value = fromJson || base || '';
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }

            togglePublishPasteBox() {
                const box = document.getElementById('publish-paste-box');
                if (!box) return;
                box.style.display = box.style.display === 'none' ? 'block' : 'none';
                if (box.style.display !== 'none') {
                    const t = document.getElementById('publish-json-text');
                    if (t) t.focus();
                }
            }

            clearPastedPublishJson() {
                const t = document.getElementById('publish-json-text');
                if (t) t.value = '';
            }

            usePastedPublishJson() {
                const t = document.getElementById('publish-json-text');
                if (!t) return;
                const raw = String(t.value || '').trim();
                if (!raw) {
                    this.updatePublishFileUI('‚ùå Pega un JSON primero.');
                    return;
                }

                let data;
                try {
                    data = JSON.parse(raw);
                } catch (error) {
                    this.publishFileProject = null;
                    this.updatePublishFileUI('‚ùå JSON inv√°lido (no se pudo parsear).');
                    return;
                }

                if (!data || typeof data !== 'object' || !Array.isArray(data.elements)) {
                    this.publishFileProject = null;
                    this.updatePublishFileUI('‚ùå El JSON no parece un proyecto v√°lido (falta "elements").');
                    return;
                }

                this.normalizeProjectInPlace(data);
                this.publishFileProject = data;
                this.publishFileName = 'pegado';
                this.updatePublishFileUI('Fuente: JSON pegado');

                const nameInput = document.getElementById('publish-name');
                if (nameInput && !String(nameInput.value || '').trim()) {
                    const fromJson = (typeof data.name === 'string' && data.name.trim()) ? data.name.trim() : '';
                    nameInput.value = fromJson || '';
                }
            }

            async publishSticker() {
                const result = document.getElementById('publish-result');
                result.style.display = 'block';
                result.textContent = 'Publicando...';

                const sourceElements = this.publishFileProject ? this.publishFileProject.elements : this.elements;
                const sourceCamera = this.publishFileProject
                    ? (this.publishFileProject.camera || { x: 0, y: 0, zoom: 1 })
                    : this.camera;

                // Normalizar por si el proyecto viene de un JSON "friendly".
                if (this.publishFileProject) {
                    this.normalizeProjectInPlace(this.publishFileProject);
                }

                // Este flujo es para "stickers" vectoriales: no permitir im√°genes (ni siquiera dentro de grupos).
                const hasImages = this.hasImagesInElements(sourceElements);

                if (hasImages) {
                    result.textContent = '‚ùå No se puede publicar como sticker: elimina las im√°genes (image/imageSrc) y vuelve a intentar.';
                    return;
                }

                const totalElements = this.countElementsRecursive(sourceElements);
                if (totalElements > 2000) {
                    result.textContent = `‚ùå Proyecto demasiado grande para publicar como sticker (m√°x 2000 elementos, actual: ${totalElements}).`;
                    return;
                }

                const nameInput = (document.getElementById('publish-name').value || '').trim();
                const fileNameBase = String(this.publishFileName || '').replace(/\.json$/i, '').trim();
                const defaultName =
                    (this.publishFileProject && typeof this.publishFileProject.name === 'string' && this.publishFileProject.name.trim())
                        ? this.publishFileProject.name.trim()
                        : '';
                const name = nameInput || defaultName || fileNameBase;
                const folder = (document.getElementById('publish-folder').value || '').trim();

                const payload = {
                    name,
                    folder,
                    elements: sourceElements,
                    camera: sourceCamera,
                    tags: []
                };

                const headers = { 'Content-Type': 'application/json' };
                const publishKey = this.getPublishKey();
                if (publishKey) headers['x-publish-key'] = publishKey;

                let response;
                let data;
                try {
                    response = await fetch('/api/publish', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(payload)
                    });
                    data = await response.json();
                } catch (error) {
                    result.textContent = `‚ùå Error de red al publicar: ${error}`;
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const details = data && data.details ? `\n${JSON.stringify(data.details)}` : '';
                    const err = (data && data.error) || response.status;
                    const hint = err === 'Unauthorized'
                        ? '\nTip: pega tu PUBLISH_KEY en "Llave de publicaci√≥n" y vuelve a intentar.'
                        : '';
                    result.textContent = `‚ùå Error al publicar: ${err}${details}${hint}`;
                    return;
                }

                // Intentar copiar el link de preview autom√°ticamente (si el navegador lo permite)
                try {
                    await navigator.clipboard.writeText(data.previewUrl);
                } catch {
                    // Ignorar: algunos navegadores/browsers bloquean clipboard.
                }

                const previewUrl = String(data.previewUrl || '');
                const stickerUrl = previewUrl ? previewUrl.replace('mode=preview', 'mode=sticker') : '';
                const deckUrl = `${window.location.origin}/?mode=deck&id=${encodeURIComponent(data.id)}`;

                result.innerHTML = `
                    <div><strong>Sticker (transparente):</strong></div>
                    <input type="text" readonly value="${stickerUrl}">
                    <div style="margin-top: 10px;"><strong>Preview (studio):</strong></div>
                    <input type="text" readonly value="${previewUrl}">
                    <div style="margin-top: 10px;"><strong>Deck (modo l√°mina):</strong></div>
                    <input type="text" readonly value="${deckUrl}">
                    <div style="margin-top: 10px;"><strong>JSON:</strong></div>
                    <input type="text" readonly value="${data.jsonUrl}">
                    <div style="margin-top: 10px;">Tip: el link de preview se intent√≥ copiar al portapapeles.</div>
                `;
            }

            async publishProject() {
                const result = document.getElementById('publish-result');
                result.style.display = 'block';
                result.textContent = 'Publicando proyecto...';

                const sourceElements = this.publishFileProject ? this.publishFileProject.elements : this.elements;
                const sourceCamera = this.publishFileProject
                    ? (this.publishFileProject.camera || { x: 0, y: 0, zoom: 1 })
                    : this.camera;

                // Normalizar por si el proyecto viene de un JSON "friendly".
                if (this.publishFileProject) {
                    this.normalizeProjectInPlace(this.publishFileProject);
                }

                const totalElements = this.countElementsRecursive(sourceElements);
                if (totalElements > 2000) {
                    result.textContent = `‚ùå Proyecto demasiado grande para publicar (m√°x 2000 elementos, actual: ${totalElements}).`;
                    return;
                }

                const nameInput = (document.getElementById('publish-name').value || '').trim();
                const fileNameBase = String(this.publishFileName || '').replace(/\.json$/i, '').trim();
                const defaultName =
                    (this.publishFileProject && typeof this.publishFileProject.name === 'string' && this.publishFileProject.name.trim())
                        ? this.publishFileProject.name.trim()
                        : '';
                const name = nameInput || defaultName || fileNameBase;
                const folder = (document.getElementById('publish-folder').value || '').trim();

                const payload = {
                    name,
                    folder,
                    elements: sourceElements,
                    camera: sourceCamera,
                    tags: []
                };

                // Quitar "imageData" (no se puede serializar de forma util).
                let bodyText;
                try {
                    bodyText = JSON.stringify(payload, (key, value) => {
                        if (key === 'imageData') return undefined;
                        return value;
                    });
                } catch (error) {
                    result.textContent = `‚ùå No se pudo serializar el proyecto: ${error}`;
                    return;
                }

                // Anti-abuso/limite practico (Vercel Functions).
                if (bodyText.length > 6_000_000) {
                    result.textContent = '‚ùå Proyecto demasiado grande para publicar como "Proyecto" (reduce el tama√±o de las im√°genes).';
                    return;
                }

                const headers = { 'Content-Type': 'application/json' };
                const publishKey = this.getPublishKey();
                if (publishKey) headers['x-publish-key'] = publishKey;

                let response;
                let data;
                try {
                    response = await fetch('/api/publish-project', {
                        method: 'POST',
                        headers,
                        body: bodyText
                    });
                    data = await response.json();
                } catch (error) {
                    result.textContent = `‚ùå Error de red al publicar: ${error}`;
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const details = data && data.details ? `\n${JSON.stringify(data.details)}` : '';
                    const err = (data && data.error) || response.status;
                    const hint = err === 'Unauthorized'
                        ? '\nTip: pega tu PUBLISH_KEY en "Llave de publicaci√≥n" y vuelve a intentar.'
                        : '';
                    result.textContent = `‚ùå Error al publicar proyecto: ${err}${details}${hint}`;
                    return;
                }

                // Intentar copiar el link de preview automaticamente.
                try {
                    await navigator.clipboard.writeText(data.previewUrl);
                } catch {
                    // Ignorar.
                }

                const previewUrl = String(data.previewUrl || '');
                const stickerUrl = previewUrl ? previewUrl.replace('mode=preview', 'mode=sticker') : '';
                const deckUrl = `${window.location.origin}/?mode=deck&id=${encodeURIComponent(data.id)}`;
                const editorUrl = String(data.editorUrl || `${window.location.origin}/?id=${encodeURIComponent(data.id)}`);

                result.innerHTML = `
                    <div><strong>Preview (studio):</strong></div>
                    <input type="text" readonly value="${previewUrl}">
                    <div style="margin-top: 10px;"><strong>Sticker (transparente):</strong></div>
                    <input type="text" readonly value="${stickerUrl}">
                    <div style="margin-top: 10px;"><strong>Deck (modo l√°mina):</strong></div>
                    <input type="text" readonly value="${deckUrl}">
                    <div style="margin-top: 10px;"><strong>Editor (abre en modo edici√≥n):</strong></div>
                    <input type="text" readonly value="${editorUrl}">
                    <div style="margin-top: 10px;"><strong>JSON:</strong></div>
                    <input type="text" readonly value="${data.jsonUrl}">
                    <div style="margin-top: 10px;">Tip: el link de preview se intent√≥ copiar al portapapeles.</div>
                `;
            }

            setLibraryMode(modeRaw) {
                const raw = String(modeRaw || '').toLowerCase();
                const mode = raw === 'grouped' ? 'grouped' : (raw === 'stkers' ? 'stkers' : 'library');
                this.libraryMode = mode;

                const bLib = document.getElementById('btn-library-mode-library');
                const bGrp = document.getElementById('btn-library-mode-grouped');
                const bStk = document.getElementById('btn-library-mode-stkers');
                if (bLib) bLib.classList.toggle('active', mode === 'library');
                if (bGrp) bGrp.classList.toggle('active', mode === 'grouped');
                if (bStk) bStk.classList.toggle('active', mode === 'stkers');

                const input = document.getElementById('library-prefix');
                if (input) {
                    if (mode === 'grouped' && (!String(input.value || '').trim() || String(input.value || '').trim() === 'grouped')) {
                        input.value = 'grouped';
                    } else if (mode === 'stkers' && (!String(input.value || '').trim() || String(input.value || '').trim() === 'stkers' || String(input.value || '').trim() === 'stickers')) {
                        input.value = 'stickers';
                    } else if (mode === 'library' && ['grouped', 'stkers', 'stickers'].includes(String(input.value || '').trim())) {
                        input.value = '';
                    }
                }
            }

            showLibraryModal(modeRaw) {
                const modal = document.getElementById('library-modal');
                modal.classList.add('show');

                const input = document.getElementById('library-prefix');
                const mode = String(modeRaw || '').toLowerCase();
                const nextMode = mode === 'grouped' ? 'grouped' : (mode === 'stkers' ? 'stkers' : this.libraryMode);
                this.setLibraryMode(nextMode);
                input.value = this.libraryMode === 'grouped'
                    ? (this.libraryPrefix || 'grouped')
                    : (this.libraryMode === 'stkers'
                        ? ((this.libraryPrefix && this.libraryPrefix !== 'grouped') ? this.libraryPrefix : 'stickers')
                        : (['grouped', 'stkers', 'stickers'].includes(this.libraryPrefix) ? '' : (this.libraryPrefix || '')));
                input.focus();

                const uploadStatus = document.getElementById('library-upload-status');
                if (uploadStatus) uploadStatus.textContent = '';

                this.refreshLibrary();
            }

            hideLibraryModal() {
                document.getElementById('library-modal').classList.remove('show');
            }

            libraryNavigateUp() {
                const input = document.getElementById('library-prefix');
                const current = (input.value || '')
                    .trim()
                    .replace(/^\/+/, '')
                    .replace(/\/+$/, '');

                if (!current) return;

                const parts = current.split('/').filter(Boolean);
                parts.pop();
                input.value = parts.join('/');
                this.refreshLibrary();
            }

            async refreshLibrary() {
                const input = document.getElementById('library-prefix');
                let prefix = (input.value || '')
                    .trim()
                    .replace(/^\/+/, '')
                    .replace(/\/+$/, '');
                if (this.libraryMode === 'grouped' && !prefix) {
                    prefix = 'grouped';
                    if (input) input.value = prefix;
                } else if (this.libraryMode === 'stkers' && !prefix) {
                    prefix = 'stickers';
                    if (input) input.value = prefix;
                }

                this.libraryPrefix = prefix;

                const status = document.getElementById('library-status');
                const listEl = document.getElementById('library-list');
                status.textContent = 'Cargando biblioteca...';
                listEl.innerHTML = '';

                let response;
                let data;
                try {
                    response = await fetch(`/api/library?scope=library&prefix=${encodeURIComponent(prefix)}&mode=folded&limit=200`);
                    data = await response.json();
                } catch (error) {
                    status.textContent = `‚ùå Error de red: ${error}`;
                    return;
                }

                if (!response.ok || !data || !data.ok) {
                    const err = (data && data.error) || response.status;
                    const hint = err === 'BlobListFailed'
                        ? ' (Tip: configura BLOB_READ_WRITE_TOKEN en Vercel: Storage ‚Üí Blob)'
                        : '';
                    status.textContent = `‚ùå Error al listar biblioteca: ${err}${hint}`;
                    return;
                }

                const currentPrefix = (data.prefix || '').replace(/\/+$/, '');
                const modeLabel = this.libraryMode === 'grouped'
                    ? 'Agrupados'
                    : (this.libraryMode === 'stkers' ? 'Stkers' : 'Biblioteca');
                status.textContent = `${modeLabel} ¬∑ ${currentPrefix ? `Carpeta: /${currentPrefix}` : 'Carpeta: /'}`;

                const folders = Array.isArray(data.folders) ? data.folders.slice() : [];
                const blobs = Array.isArray(data.blobs) ? data.blobs.slice() : [];

                folders.sort((a, b) => String(a).localeCompare(String(b)));
                blobs.sort((a, b) => String(a.pathname).localeCompare(String(b.pathname)));
                let previewFrameCount = 0;
                const previewFrameLimit = this.libraryMode === 'stkers' ? 28 : 18;
                const thumbMode = this.libraryMode === 'grouped' ? 'preview' : 'sticker';

                const addRow = ({ name, type, path, id, actions }) => {
                    const row = document.createElement('div');
                    row.className = 'library-row';
                    row.dataset.type = type;
                    if (path) row.dataset.path = path;
                    if (id) row.dataset.id = id;

                    const left = document.createElement('div');
                    left.className = 'library-left';

                    const thumb = document.createElement('div');
                    thumb.className = 'library-thumb';
                    if (type === 'folder') {
                        thumb.textContent = 'üìÅ';
                    } else if (type === 'sticker' && id) {
                        if (previewFrameCount < previewFrameLimit) {
                            try {
                                const frame = document.createElement('iframe');
                                frame.setAttribute('loading', previewFrameCount < 8 ? 'eager' : 'lazy');
                                frame.setAttribute('title', `preview-${id}`);
                                frame.src = `${window.location.origin}/?mode=${thumbMode}&id=${encodeURIComponent(id)}`;
                                thumb.appendChild(frame);
                                previewFrameCount += 1;
                            } catch {
                                thumb.textContent = this.libraryMode === 'stkers' ? 'üéûÔ∏è' : '‚ú®';
                            }
                        } else {
                            thumb.textContent = this.libraryMode === 'stkers' ? 'üéûÔ∏è' : '‚ú®';
                        }
                    } else {
                        thumb.textContent = '‚ú®';
                    }

                    const nameEl = document.createElement('div');
                    nameEl.className = 'library-name';
                    nameEl.textContent = name;

                    const actionsEl = document.createElement('div');
                    actionsEl.className = 'library-actions';

                    actions.forEach(({ label, action }) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn small';
                        btn.textContent = label;
                        btn.dataset.action = action;
                        actionsEl.appendChild(btn);
                    });

                    left.appendChild(thumb);
                    left.appendChild(nameEl);
                    row.appendChild(left);
                    row.appendChild(actionsEl);
                    listEl.appendChild(row);
                };

                const displayName = (fullPath) => {
                    const p = String(fullPath || '').replace(/\/+$/, '');
                    if (!currentPrefix) return p;
                    if (p === currentPrefix) return p.split('/').pop() || p;
                    if (p.startsWith(currentPrefix + '/')) {
                        return p.slice(currentPrefix.length + 1) || p;
                    }
                    return p;
                };

                folders.forEach((folderPath) => {
                    const clean = String(folderPath || '').replace(/\/+$/, '');
                    if (!clean) return;
                    addRow({
                        name: `üìÅ ${displayName(clean)}`,
                        type: 'folder',
                        path: clean,
                        actions: [{ label: 'Abrir', action: 'open-folder' }],
                    });
                });

                blobs.forEach((blob) => {
                    if (!blob || !blob.pathname) return;
                    const stickerId = String(blob.pathname);
                    addRow({
                        name: `‚ú® ${displayName(stickerId)}`,
                        type: 'sticker',
                        id: stickerId,
                        actions: [
                            { label: 'Insertar', action: 'insert' },
                            { label: 'Ver', action: 'preview' },
                        ],
                    });
                });

                if (folders.length === 0 && blobs.length === 0) {
                    status.textContent += ' (vac√≠o)';
                }
            }

            onLibraryClick(e) {
                const btn = e.target.closest('button[data-action]');
                if (!btn) return;

                const row = btn.closest('.library-row');
                if (!row) return;

                const action = btn.dataset.action;
                const type = row.dataset.type;

                if (action === 'open-folder' && type === 'folder') {
                    const path = row.dataset.path || '';
                    document.getElementById('library-prefix').value = path;
                    this.refreshLibrary();
                    return;
                }

                if (action === 'preview' && type === 'sticker') {
                    const id = row.dataset.id;
                    if (!id) return;
                    const url = `${window.location.origin}/?mode=sticker&id=${encodeURIComponent(id)}`;
                    window.open(url, '_blank', 'noopener');
                    return;
                }

                if (action === 'insert' && type === 'sticker') {
                    const id = row.dataset.id;
                    if (!id) return;
                    this.insertStickerById(id);
                }
            }

            pickLibraryUploadFile() {
                const input = document.getElementById('library-upload-input');
                if (!input) return;
                input.value = '';
                input.click();
            }

            onLibraryUploadSelected(e) {
                const file = e.target.files && e.target.files[0];
                if (!file) return;

                const uploadStatus = document.getElementById('library-upload-status');
                if (uploadStatus) uploadStatus.textContent = 'Leyendo archivo...';

                const reader = new FileReader();
                reader.onload = async (event) => {
                    let data;
                    try {
                        data = JSON.parse(String(event.target.result || ''));
                    } catch (error) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå JSON inv√°lido (no se pudo parsear).';
                        return;
                    }

                    if (!data || typeof data !== 'object' || !Array.isArray(data.elements)) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå El JSON no parece un proyecto v√°lido (falta "elements").';
                        return;
                    }

                    // Normalizar para aceptar JSON "IA-friendly".
                    this.normalizeProjectInPlace(data);
                    const elements = data.elements || [];
                    const camera = (data.camera && typeof data.camera === 'object')
                        ? data.camera
                        : { x: 0, y: 0, zoom: 1 };

                    // Rechazar im√°genes: la biblioteca est√° pensada para stickers vectoriales/animados.
                    if (this.hasImagesInElements(elements)) {
                        if (uploadStatus) uploadStatus.textContent = '‚ùå Este JSON contiene im√°genes (image/imageSrc). Elimina im√°genes para publicarlo como sticker.';
                        return;
                    }

                    const total = this.countElementsRecursive(elements);
                    if (total > 2000) {
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Proyecto demasiado grande (m√°x 2000 elementos, actual: ${total}).`;
                        return;
                    }

                    const baseName = String(file.name || '').replace(/\.json$/i, '').trim();
                    const jsonName = (typeof data.name === 'string' && data.name.trim()) ? data.name.trim() : '';
                    const name = jsonName || baseName || 'sticker';

                    const prefixInput = document.getElementById('library-prefix');
                    const folder = (prefixInput ? String(prefixInput.value || '') : '')
                        .trim()
                        .replace(/^\/+/, '')
                        .replace(/\/+$/, '');

                    const payload = {
                        name,
                        folder,
                        elements,
                        camera,
                        tags: []
                    };

                    if (uploadStatus) uploadStatus.textContent = 'Subiendo a biblioteca...';

                    const headers = { 'Content-Type': 'application/json' };
                    const publishKey = this.getPublishKey();
                    if (publishKey) headers['x-publish-key'] = publishKey;

                    let response;
                    let resJson;
                    try {
                        response = await fetch('/api/publish', {
                            method: 'POST',
                            headers,
                            body: JSON.stringify(payload)
                        });
                        resJson = await response.json();
                    } catch (error) {
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Error de red al publicar: ${error}`;
                        return;
                    }

                    if (!response.ok || !resJson || !resJson.ok) {
                        const err = (resJson && resJson.error) || response.status;
                        const hint =
                            err === 'Unauthorized'
                                ? '\nTip: pega tu PUBLISH_KEY en "Publicar" (modal) y vuelve a intentar.'
                                : (err === 'BlobWriteFailed'
                                    ? '\nTip: configura BLOB_READ_WRITE_TOKEN en Vercel (Storage ‚Üí Blob).'
                                    : '');
                        if (uploadStatus) uploadStatus.textContent = `‚ùå Error al publicar: ${err}${hint}`;
                        return;
                    }

                    const stickerUrl = String(resJson.previewUrl || '').replace('mode=preview', 'mode=sticker');
                    const deckUrl = `${window.location.origin}/?mode=deck&id=${encodeURIComponent(resJson.id)}`;

                    // Intentar copiar el link sticker autom√°ticamente.
                    try {
                        if (stickerUrl) await navigator.clipboard.writeText(stickerUrl);
                    } catch {
                        // Ignorar
                    }

                    if (uploadStatus) {
                        uploadStatus.textContent =
                            `‚úÖ Publicado\n` +
                            `ID: ${resJson.id}\n` +
                            `Sticker: ${stickerUrl || resJson.previewUrl}\n` +
                            `Deck: ${deckUrl}\n` +
                            `JSON: ${resJson.jsonUrl}`;
                    }

                    this.refreshLibrary();
                };
                reader.readAsText(file);

                // Permitir re-seleccionar el mismo archivo.
                e.target.value = '';
            }

            walkElements(elements, visitor) {
                const stack = Array.isArray(elements) ? elements.slice() : [];
                while (stack.length) {
                    const elem = stack.pop();
                    if (!elem || typeof elem !== 'object') continue;

                    // Si el visitor devuelve false, detenemos el recorrido.
                    if (visitor(elem) === false) return;

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        for (let i = elem.elements.length - 1; i >= 0; i--) {
                            stack.push(elem.elements[i]);
                        }
                    }
                }
            }

            ensureElementMeta(elem) {
                if (!elem || typeof elem !== 'object') return {};
                if (!elem.meta || typeof elem.meta !== 'object' || Array.isArray(elem.meta)) {
                    elem.meta = {};
                }
                return elem.meta;
            }

            hasImagesInElements(elements) {
                let found = false;
                this.walkElements(elements, (elem) => {
                    if (elem.type === 'image' ||
                        elem.type === 'video' ||
                        typeof elem.imageSrc === 'string' ||
                        elem.imageData != null ||
                        typeof elem.videoSrc === 'string' ||
                        elem.videoData != null) {
                        found = true;
                        return false;
                    }
                    return true;
                });
                return found;
            }

            normalizeProjectInPlace(project) {
                if (!project || typeof project !== 'object') return;
                if (!Array.isArray(project.elements)) project.elements = [];

                const normalizeElement = (elem) => {
                    if (!elem || typeof elem !== 'object') return;

                    // Compat IA: { color } -> fillColor/strokeColor
                    if (typeof elem.color === 'string') {
                        if (typeof elem.fillColor !== 'string' &&
                            (elem.type === 'rectangle' || elem.type === 'circle' || elem.type === 'polygon')) {
                            elem.fillColor = elem.color;
                        }
                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = elem.color;
                    }

                    // Compat IA: { isAnim } -> { active }
                    if (typeof elem.isAnim === 'boolean' && typeof elem.active !== 'boolean') {
                        elem.active = elem.isAnim;
                    }

                    // Compat IA: circle con radius y (x,y) como centro.
                    if (elem.type === 'circle' && typeof elem.radius === 'number' &&
                        (!Number.isFinite(elem.width) || !Number.isFinite(elem.height))) {
                        const r = elem.radius;
                        const cx = Number.isFinite(elem.x) ? elem.x : 0;
                        const cy = Number.isFinite(elem.y) ? elem.y : 0;
                        elem.x = cx - r;
                        elem.y = cy - r;
                        elem.width = r * 2;
                        elem.height = r * 2;
                        delete elem.radius;
                    }

                    // Compat IA: line con x1/y1/x2/y2.
                    if (elem.type === 'line' && Number.isFinite(elem.x1) && Number.isFinite(elem.y1) &&
                        Number.isFinite(elem.x2) && Number.isFinite(elem.y2) &&
                        (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) ||
                         !Number.isFinite(elem.endX) || !Number.isFinite(elem.endY))) {
                        elem.x = elem.x1;
                        elem.y = elem.y1;
                        elem.endX = elem.x2;
                        elem.endY = elem.y2;
                        delete elem.x1;
                        delete elem.y1;
                        delete elem.x2;
                        delete elem.y2;
                    }

                    // Defaults m√≠nimos para el engine.
                    if (elem.type === 'line') {
                        if (!Number.isFinite(elem.x)) elem.x = 0;
                        if (!Number.isFinite(elem.y)) elem.y = 0;
                        if (!Number.isFinite(elem.endX)) elem.endX = elem.x;
                        if (!Number.isFinite(elem.endY)) elem.endY = elem.y;
                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = '#e94560';
                        if (typeof elem.animColor !== 'string') elem.animColor = '#4caf50';
                        if (typeof elem.flowDirection !== 'string') elem.flowDirection = 'right';
                        if (!Number.isFinite(elem.animOffset)) elem.animOffset = 0;
                        if (!Array.isArray(elem.controlPoints)) elem.controlPoints = [];
                        if (typeof elem.routeRole !== 'boolean') elem.routeRole = false;
                        if (typeof elem.routeCircular !== 'boolean') elem.routeCircular = false;
                        if (typeof elem.routeCurve !== 'string') elem.routeCurve = (elem.routeCircular ? 'circle' : 'line');
                        if (typeof elem.routeArcSide !== 'string') elem.routeArcSide = 'left';
                        if (!Number.isFinite(elem.routeArcDegrees)) elem.routeArcDegrees = 120;
                        if (typeof elem.routeMode !== 'string') elem.routeMode = 'loop';
                    } else if (elem.type === 'rectangle' || elem.type === 'circle') {
                        if (!Number.isFinite(elem.x)) elem.x = 0;
                        if (!Number.isFinite(elem.y)) elem.y = 0;
                        if (!Number.isFinite(elem.width)) elem.width = 0;
                        if (!Number.isFinite(elem.height)) elem.height = 0;
                        if (typeof elem.fillColor !== 'string') elem.fillColor = '#0f3460';
                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = '#e94560';
		                    } else if (elem.type === 'image') {
		                        if (!Number.isFinite(elem.x)) elem.x = 0;
		                        if (!Number.isFinite(elem.y)) elem.y = 0;
		                        if (!Number.isFinite(elem.width)) elem.width = 0;
		                        if (!Number.isFinite(elem.height)) elem.height = 0;
		                        if (!Number.isFinite(elem.originalWidth)) elem.originalWidth = Math.abs(elem.width) || 1;
		                        if (!Number.isFinite(elem.originalHeight)) elem.originalHeight = Math.abs(elem.height) || 1;
		                        if (typeof elem.fillColor !== 'string') elem.fillColor = 'transparent';
		                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = 'transparent';
		
		                        // No serializable: siempre eliminar (se re-hidrata desde imageSrc/cache).
		                        if (elem.imageData != null) {
		                            try { delete elem.imageData; } catch {}
		                        }

		                        // Normalizar crop (0..1)
		                        if (elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) {
		                            const c = elem.crop;
		                            const x = Number(c.x);
		                            const y = Number(c.y);
		                            const w = Number(c.w);
		                            const h = Number(c.h);
		                            if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
		                                c.x = Math.max(0, Math.min(1, x));
		                                c.y = Math.max(0, Math.min(1, y));
		                                c.w = Math.max(0, Math.min(1, w));
		                                c.h = Math.max(0, Math.min(1, h));
		                                if (c.x + c.w > 1) c.w = Math.max(0, 1 - c.x);
		                                if (c.y + c.h > 1) c.h = Math.max(0, 1 - c.y);
		                                if (!(c.w > 0 && c.h > 0)) delete elem.crop;
		                            } else {
		                                delete elem.crop;
		                            }
		                        } else if (elem.crop != null) {
		                            delete elem.crop;
		                        }
		                    } else if (elem.type === 'video') {
		                        if (!Number.isFinite(elem.x)) elem.x = 0;
		                        if (!Number.isFinite(elem.y)) elem.y = 0;
		                        if (!Number.isFinite(elem.width)) elem.width = 640;
		                        if (!Number.isFinite(elem.height)) elem.height = 360;
		                        if (!Number.isFinite(elem.originalWidth)) elem.originalWidth = Math.abs(elem.width) || 1;
		                        if (!Number.isFinite(elem.originalHeight)) elem.originalHeight = Math.abs(elem.height) || 1;
		                        if (typeof elem.videoSrc !== 'string') elem.videoSrc = '';
		                        if (typeof elem.loop !== 'boolean') elem.loop = true;
		                        if (typeof elem.muted !== 'boolean') elem.muted = true;
		                        if (typeof elem.autoplay !== 'boolean') elem.autoplay = true;
		                        if (typeof elem.fillColor !== 'string') elem.fillColor = 'transparent';
		                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = 'transparent';

		                        // No serializable: siempre eliminar (se re-hidrata desde videoSrc/cache).
		                        if (elem.videoData != null) {
		                            try { delete elem.videoData; } catch {}
		                        }

		                        // Normalizar crop (0..1)
		                        if (elem.crop && typeof elem.crop === 'object' && !Array.isArray(elem.crop)) {
		                            const c = elem.crop;
		                            const x = Number(c.x);
		                            const y = Number(c.y);
		                            const w = Number(c.w);
		                            const h = Number(c.h);
		                            if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
		                                c.x = Math.max(0, Math.min(1, x));
		                                c.y = Math.max(0, Math.min(1, y));
		                                c.w = Math.max(0, Math.min(1, w));
		                                c.h = Math.max(0, Math.min(1, h));
		                                if (c.x + c.w > 1) c.w = Math.max(0, 1 - c.x);
		                                if (c.y + c.h > 1) c.h = Math.max(0, 1 - c.y);
		                                if (!(c.w > 0 && c.h > 0)) delete elem.crop;
		                            } else {
		                                delete elem.crop;
		                            }
		                        } else if (elem.crop != null) {
		                            delete elem.crop;
		                        }
		                    } else if (elem.type === 'polygon' || elem.type === 'path') {
		                        if (typeof elem.strokeColor !== 'string') elem.strokeColor = '#e94560';
		                        if (typeof elem.fillColor !== 'string') elem.fillColor = '#0f3460';
		                        if (!Number.isFinite(elem.lineWidth)) elem.lineWidth = 3;
                                // Compat PNG-TO-JSON: aceptar puntos como [x,y] adem√°s de {x,y}
                                if (Array.isArray(elem.points)) {
                                    elem.points = elem.points
                                        .map((p) => {
                                            if (Array.isArray(p) && p.length >= 2) {
                                                const x = Number(p[0]);
                                                const y = Number(p[1]);
                                                if (Number.isFinite(x) && Number.isFinite(y)) return { x, y };
                                                return null;
                                            }
                                            if (p && typeof p === 'object') {
                                                const x = Number(
                                                    Number.isFinite(p.x) ? p.x :
                                                    (Number.isFinite(p[0]) ? p[0] : NaN)
                                                );
                                                const y = Number(
                                                    Number.isFinite(p.y) ? p.y :
                                                    (Number.isFinite(p[1]) ? p[1] : NaN)
                                                );
                                                if (Number.isFinite(x) && Number.isFinite(y)) return { x, y };
                                            }
                                            return null;
                                        })
                                        .filter(Boolean);
                                } else {
                                    elem.points = [];
                                }
                                if (typeof elem.routeRole !== 'boolean') elem.routeRole = false;
                            } else if (elem.type === 'mover') {
                                    if (!Number.isFinite(elem.x)) elem.x = 0;
                                    if (!Number.isFinite(elem.y)) elem.y = 0;
                                    if (!Number.isFinite(elem.width)) elem.width = 44;
                                    if (!Number.isFinite(elem.height)) elem.height = 28;
                                    if (typeof elem.routeId !== 'string') elem.routeId = '';
                                    if (typeof elem.moverKind !== 'string') elem.moverKind = 'metro';
                                    if (!Number.isFinite(elem.progress)) elem.progress = 0;
                                    if (typeof elem.flowDirection !== 'string') elem.flowDirection = 'right';
                                    if (!Number.isFinite(elem.speed)) elem.speed = 40;
                                    if (typeof elem.routeMode !== 'string') elem.routeMode = 'loop';
                                    if (typeof elem.fillColor !== 'string') {
                                        elem.fillColor = elem.moverKind === 'female' ? '#f472b6' : (elem.moverKind === 'male' ? '#3b82f6' : '#93c5fd');
                                    }
                                    if (typeof elem.strokeColor !== 'string') elem.strokeColor = '#0b1027';
                                } else if (elem.type === 'portal') {
                                    if (!Number.isFinite(elem.x)) elem.x = 0;
                                    if (!Number.isFinite(elem.y)) elem.y = 0;
                                    if (!Number.isFinite(elem.width)) elem.width = 36;
                                    if (!Number.isFinite(elem.height)) elem.height = 36;
                                    if (typeof elem.portalKind !== 'string') elem.portalKind = 'import';
                                    if (typeof elem.portalKey !== 'string') elem.portalKey = 'A1';
                                    if (typeof elem.fillColor !== 'string') elem.fillColor = (elem.portalKind === 'export') ? '#a78bfa' : '#22d3ee';
                                    if (typeof elem.strokeColor !== 'string') elem.strokeColor = '#0b1027';
			                    }

	                    // Normalizar degradado de relleno (si existe).
	                    if (this.elementSupportsFillGradient(elem)) {
	                        const fg = this.normalizeFillGradientSpec(elem.fillGradient);
	                        if (fg) {
	                            elem.fillGradient = fg;
	                        } else if (elem.fillGradient != null) {
	                            try { delete elem.fillGradient; } catch {}
	                        }
	                    } else if (elem.fillGradient != null) {
	                        try { delete elem.fillGradient; } catch {}
	                    }

	                    if (typeof elem.name !== 'string') elem.name = '';
	                    if (typeof elem.locked !== 'boolean') elem.locked = false;
	                    if (typeof elem.active !== 'boolean') elem.active = true;
	                    if (typeof elem.connectionStatus !== 'string') elem.connectionStatus = 'none';
                    if (typeof elem.followRoute !== 'boolean') elem.followRoute = false;
                    if (typeof elem.routeId !== 'string') elem.routeId = '';
                    if (!Number.isFinite(elem.routeSpeed)) elem.routeSpeed = 40;
                    if (typeof elem.routeDirection !== 'string') elem.routeDirection = 'right';
                    if (!Number.isFinite(elem.routeProgress)) elem.routeProgress = 0;
                    if (typeof elem.routeMode !== 'string') elem.routeMode = 'loop';
                    if (typeof elem.autoConnectRoute !== 'boolean') elem.autoConnectRoute = false;

                    this.normalizeBoxElementInPlace(elem);
                };

                this.walkElements(project.elements, (elem) => {
                    normalizeElement(elem);
                    return true;
                });

                if (!project.camera || typeof project.camera !== 'object') {
                    project.camera = { x: 0, y: 0, zoom: 1 };
                } else {
                    const cam = project.camera;
                    if (!Number.isFinite(cam.x)) cam.x = 0;
                    if (!Number.isFinite(cam.y)) cam.y = 0;
                    if (!Number.isFinite(cam.zoom)) cam.zoom = 1;
                }

	                if (typeof project.name !== 'string') project.name = '';
	                if (typeof project.date !== 'string') project.date = new Date().toISOString();

	                // Puntos de Informaci√≥n (L√°mina): asegurar orden 1..n si hay CPs sin orden.
	                this.ensureControlPointOrders(project.elements);
	            }

            countElementsRecursive(elements) {
                let count = 0;
                this.walkElements(elements, () => {
                    count++;
                    return true;
                });
                return count;
            }

            // ==================== DECK (L√ÅMINA) ====================

            refreshDeckUI() {
                if (this.viewerMode !== 'deck') return;
                this.updateDeckControlPointsUI();
                this.updateDeckNavUI();
                this.applyDeckStateFromUrl();
                this.updateDeckShareStatus();
            }

	            isControlPoint(elem) {
	                if (!elem || typeof elem !== 'object') return false;
	                const meta = (elem.meta && typeof elem.meta === 'object') ? elem.meta : null;

                if (elem.type === 'controlPoint' || elem.type === 'poi') return true;
                if (elem.controlPoint === true || elem.isControlPoint === true) return true;
                if (meta && (meta.controlPoint === true || meta.isControlPoint === true)) return true;

                const slide = (meta && meta.slide && typeof meta.slide === 'object')
                    ? meta.slide
                    : (elem.slide && typeof elem.slide === 'object' ? elem.slide : null);

                if (slide) return true;

                if (typeof elem.slideImageUrl === 'string' || typeof elem.slideText === 'string' || typeof elem.slideTitle === 'string') {
                    return true;
                }
                if (meta && (typeof meta.slideImageUrl === 'string' || typeof meta.slideText === 'string' || typeof meta.slideTitle === 'string')) {
                    return true;
                }

	                return false;
	            }

	            getControlPointOrder(elem) {
	                if (!elem || typeof elem !== 'object') return null;
	                const meta = (elem.meta && typeof elem.meta === 'object' && !Array.isArray(elem.meta)) ? elem.meta : null;

	                const raw =
	                    (meta && (meta.order ?? meta.cpOrder ?? meta.slideOrder)) ??
	                    (elem.order ?? elem.cpOrder ?? elem.slideOrder);

	                const n = Number.parseInt(String(raw ?? ''), 10);
	                if (Number.isFinite(n) && n > 0) return n;
	                return null;
	            }

	            getNextControlPointOrder(elements) {
	                let max = 0;
	                this.walkElements(elements || this.elements, (elem) => {
	                    if (!this.isControlPoint(elem)) return true;
	                    const o = this.getControlPointOrder(elem);
	                    if (Number.isFinite(o)) max = Math.max(max, o);
	                    return true;
	                });
	                return max + 1;
	            }

	            ensureControlPointOrders(elements) {
	                const cps = [];
	                this.walkElements(elements || this.elements, (elem) => {
	                    if (this.isControlPoint(elem)) cps.push(elem);
	                    return true;
	                });

	                let max = 0;
	                cps.forEach((cp) => {
	                    const o = this.getControlPointOrder(cp);
	                    if (Number.isFinite(o)) max = Math.max(max, o);
	                });

	                let next = max + 1;
	                let changed = false;
	                cps.forEach((cp) => {
	                    const o = this.getControlPointOrder(cp);
	                    if (Number.isFinite(o) && o > 0) return;
	                    const meta = this.ensureElementMeta(cp);
	                    meta.order = next++;
	                    changed = true;
	                });

	                return changed;
	            }

	            goToDeckControlPoint(delta) {
	                if (this.viewerMode !== 'deck') return;
	                const step = delta < 0 ? -1 : 1;

	                const cps = this.collectControlPoints();
	                if (!cps.length) return;

	                let idx = 0;
	                if (this.activeControlPointId != null) {
	                    const cur = String(this.activeControlPointId);
	                    const found = cps.findIndex((cp) => cp && cp.id != null && String(cp.id) === cur);
	                    idx = found >= 0 ? found : 0;
	                }

	                const next = Math.max(0, Math.min(cps.length - 1, idx + step));
	                if (next === idx) return;
	                this.setActiveControlPoint(cps[next], { focus: true, updateUrl: true });
	            }

	            collectControlPoints() {
	                const cps = [];
	                const seen = new Set();

                this.walkElements(this.elements, (elem) => {
                    if (!this.isControlPoint(elem)) return true;
                    const id = elem.id != null ? String(elem.id) : '';
                    if (id && seen.has(id)) return true;
                    if (id) seen.add(id);
                    cps.push(elem);
                    return true;
                });

	                cps.sort((a, b) => {
	                    const aOrder = this.getControlPointOrder(a);
	                    const bOrder = this.getControlPointOrder(b);
	                    if (aOrder != null && bOrder != null && aOrder !== bOrder) return aOrder - bOrder;
	                    if (aOrder != null && bOrder == null) return -1;
	                    if (aOrder == null && bOrder != null) return 1;
	                    const aLabel = this.getControlPointLabel(a);
	                    const bLabel = this.getControlPointLabel(b);
	                    const byLabel = String(aLabel).localeCompare(String(bLabel));
	                    if (byLabel !== 0) return byLabel;
	                    return String(a && a.id).localeCompare(String(b && b.id));
	                });

                return cps;
            }

            getControlPointLabel(elem) {
                if (!elem || typeof elem !== 'object') return 'Punto';
                const meta = (elem.meta && typeof elem.meta === 'object') ? elem.meta : null;

                const slide = (meta && meta.slide && typeof meta.slide === 'object')
                    ? meta.slide
                    : (elem.slide && typeof elem.slide === 'object' ? elem.slide : null);

                const label =
                    (slide && (slide.title || slide.name)) ||
                    (meta && meta.slideTitle) ||
                    elem.slideTitle ||
                    (meta && meta.title) ||
                    elem.title ||
                    elem.name ||
                    '';

                const trimmed = String(label || '').trim();
                if (trimmed) return trimmed;
                return elem.id != null ? `CP ${String(elem.id)}` : 'Punto';
            }

	            updateDeckControlPointsUI() {
	                if (this.viewerMode !== 'deck') return;
	                
	                const listEl = document.getElementById('deck-control-points');
	                if (!listEl) return;

	                this.ensureControlPointOrders(this.elements);
	                const cps = this.collectControlPoints();
	                listEl.innerHTML = '';

	                if (cps.length === 0) {
	                    const empty = document.createElement('div');
	                    empty.style.color = 'rgba(11, 16, 32, 0.65)';
	                    empty.style.fontSize = '13px';
	                    empty.textContent = '(No hay puntos de control en este dise√±o)';
	                    listEl.appendChild(empty);
	                    return;
	                }

		                cps.forEach((elem) => {
		                    const btn = document.createElement('button');
		                    btn.type = 'button';
		                    btn.className = 'deck-cp';
	                    btn.dataset.cpId = elem.id != null ? String(elem.id) : '';
	                    if (this.activeControlPointId != null && String(this.activeControlPointId) === String(elem.id)) {
	                        btn.classList.add('active');
	                    }

	                    const badge = document.createElement('span');
	                    badge.className = 'deck-cp-badge';
	                    const order = this.getControlPointOrder(elem);
	                    badge.textContent = order != null ? String(order) : '';

	                    const name = document.createElement('span');
	                    name.className = 'deck-cp-name';
	                    name.textContent = this.getControlPointLabel(elem);

	                    const id = document.createElement('span');
	                    id.className = 'deck-cp-id';
	                    id.textContent = elem.id != null ? String(elem.id) : '';

	                    btn.appendChild(badge);
	                    btn.appendChild(name);
	                    btn.appendChild(id);
		                    listEl.appendChild(btn);
		                });
		            }

		            updateDeckNavUI() {
		                if (this.viewerMode !== 'deck') return;

		                const navPanel = document.getElementById('deck-nav');
		                if (!navPanel || !navPanel.classList.contains('show')) return;

		                const listEl = document.getElementById('deck-nav-list');
		                const countEl = document.getElementById('deck-nav-count');
		                if (!listEl) return;

		                this.ensureControlPointOrders(this.elements);
		                const cps = this.collectControlPoints();

		                if (countEl) {
		                    countEl.textContent = cps.length ? `${cps.length}` : '0';
		                }

		                listEl.innerHTML = '';

		                if (cps.length === 0) {
		                    const empty = document.createElement('div');
		                    empty.style.color = 'rgba(11, 16, 32, 0.65)';
		                    empty.style.fontSize = '13px';
		                    empty.textContent = '(No hay diapositivas)';
		                    listEl.appendChild(empty);
		                    return;
		                }

		                cps.forEach((elem) => {
		                    const btn = document.createElement('button');
		                    btn.type = 'button';
		                    btn.className = 'deck-nav-item';
		                    btn.dataset.cpId = elem.id != null ? String(elem.id) : '';
		                    if (this.activeControlPointId != null && String(this.activeControlPointId) === String(elem.id)) {
		                        btn.classList.add('active');
		                    }

		                    const badge = document.createElement('span');
		                    badge.className = 'deck-nav-badge';
		                    const order = this.getControlPointOrder(elem);
		                    badge.textContent = order != null ? String(order) : '';

		                    const main = document.createElement('span');
		                    main.className = 'deck-nav-main';

		                    const name = document.createElement('span');
		                    name.className = 'deck-nav-name';
		                    name.textContent = this.getControlPointLabel(elem);

		                    const meta = document.createElement('span');
		                    meta.className = 'deck-nav-meta';
		                    const info = this.extractSlideInfo(elem);
		                    const hasImage = Boolean(String(info.imageUrl || '').trim());
		                    const hasVideo = Boolean(String(info.videoUrl || '').trim());
		                    const hasText = Boolean(String(info.text || '').trim());

		                    const addPill = (label) => {
		                        const pill = document.createElement('span');
		                        pill.className = 'deck-nav-pill';
		                        pill.textContent = label;
		                        meta.appendChild(pill);
		                    };

		                    if (hasImage) addPill('üñºÔ∏è Imagen');
		                    if (hasVideo) addPill('üé• Video');
		                    if (hasText) addPill('üìù Info');
		                    if (!hasImage && !hasVideo && !hasText) addPill('Sin contenido');

			                    main.appendChild(name);
			                    main.appendChild(meta);

			                    const thumb = document.createElement('span');
			                    thumb.className = 'deck-nav-thumb';
			                    if (hasImage) {
			                        const img = document.createElement('img');
			                        img.alt = '';
			                        img.loading = 'lazy';
			                        img.decoding = 'async';
			                        img.referrerPolicy = 'no-referrer';
			                        img.src = String(info.imageUrl || '').trim();
			                        thumb.appendChild(img);
			                    } else if (hasVideo) {
			                        thumb.textContent = '‚ñ∂';
			                    } else if (hasText) {
			                        thumb.textContent = 'üìù';
			                    } else {
			                        thumb.textContent = '‚Äî';
			                    }

			                    btn.appendChild(badge);
			                    btn.appendChild(main);
			                    btn.appendChild(thumb);
			                    listEl.appendChild(btn);
			                });
			            }

	            onDeckControlPointClick(e) {
	                if (this.viewerMode !== 'deck') return;

                const btn = e.target.closest('button[data-cp-id]');
                if (!btn) return;

                const id = btn.dataset.cpId;
                if (!id) return;

                const elem = this.findElementByIdRecursive(id);
                if (!elem) return;
                this.setActiveControlPoint(elem, { focus: true, updateUrl: true });
            }

            findElementByIdRecursive(id) {
                if (id == null) return null;
                const needle = String(id);
                let found = null;
                this.walkElements(this.elements, (elem) => {
                    if (elem && elem.id != null && String(elem.id) === needle) {
                        found = elem;
                        return false;
                    }
                    return true;
                });
                return found;
            }

            applyDeckStateFromUrl() {
                if (this.viewerMode !== 'deck') return;

                const urlParams = new URLSearchParams(window.location.search);
                const cp = urlParams.get('cp');

                if (cp) {
                    if (this.activeControlPointId != null && String(this.activeControlPointId) === String(cp)) {
                        return;
                    }
                    const elem = this.findElementByIdRecursive(cp);
                    if (elem) {
                        this.setActiveControlPoint(elem, { focus: false, updateUrl: false });
                        return;
                    }
                }

                if (this.activeControlPointId != null) {
                    const existing = this.findElementByIdRecursive(this.activeControlPointId);
                    if (existing) return;
                }

                const cps = this.collectControlPoints();
                if (cps.length > 0) {
                    this.setActiveControlPoint(cps[0], { focus: false, updateUrl: true });
                } else {
                    this.updateDeckSlideUI(null);
                }
            }

            setActiveControlPoint(elem, options) {
                if (!elem || typeof elem !== 'object') return;
                if (elem.id == null) return;

                const opts = options && typeof options === 'object' ? options : {};
                const focus = opts.focus !== false;
                const updateUrl = opts.updateUrl !== false;

                this.activeControlPointId = String(elem.id);
                this.selectedElements = [elem];

                if (focus) {
                    this.focusCameraOnElement(elem);
                }

	                this.updateDeckSlideUI(elem);
	                this.updateDeckControlPointsUI();
	                this.updateDeckNavUI();

	                if (updateUrl) {
	                    this.updateDeckUrlParam('cp', String(elem.id));
	                }

                this.updateDeckShareStatus();
            }

            updateDeckUrlParam(key, value) {
                try {
                    const url = new URL(window.location.href);
                    if (value == null || value === '') {
                        url.searchParams.delete(key);
                    } else {
                        url.searchParams.set(key, String(value));
                    }
                    history.replaceState(null, '', url.toString());
                } catch {
                    // Ignorar
                }
            }

	            extractSlideInfo(elem) {
	                const meta = (elem && elem.meta && typeof elem.meta === 'object') ? elem.meta : {};
	                const slideObj = (meta.slide && typeof meta.slide === 'object')
	                    ? meta.slide
	                    : (elem && elem.slide && typeof elem.slide === 'object' ? elem.slide : {});

                const titleRaw =
                    slideObj.title ||
                    slideObj.name ||
                    meta.slideTitle ||
                    (elem && elem.slideTitle) ||
                    meta.title ||
                    (elem && elem.title) ||
                    (elem && elem.name) ||
                    '';

                const imageUrl =
                    slideObj.imageUrl ||
                    slideObj.image ||
                    meta.slideImageUrl ||
                    (elem && elem.slideImageUrl) ||
                    '';

	                const textRaw =
	                    slideObj.text ||
	                    meta.slideText ||
	                    (elem && elem.slideText) ||
	                    meta.description ||
	                    (elem && elem.description) ||
	                    '';

	                const videoUrl =
	                    slideObj.videoUrl ||
	                    slideObj.video ||
	                    meta.slideVideoUrl ||
	                    (elem && elem.slideVideoUrl) ||
	                    '';

	                const title = String(titleRaw || '').trim() || 'Punto de control';
	                const text = String(textRaw || '').trim();

	                return {
	                    title,
	                    imageUrl: String(imageUrl || '').trim(),
	                    videoUrl: String(videoUrl || '').trim(),
	                    text
	                };
	            }

		            toYouTubeEmbedUrl(rawUrl) {
		                const s = String(rawUrl || '').trim();
		                if (!s) return '';

		                // Soporta: youtu.be/ID, youtube.com/watch?v=ID, /embed/ID, /shorts/ID
		                const m = s.match(/(?:youtube\.com\/(?:watch\?v=|embed\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{6,})/i);
		                if (!m) return '';
		                const id = m[1];
		                return `https://www.youtube.com/embed/${encodeURIComponent(id)}`;
		            }

	            updateDeckSlideUI(elem) {
	                if (this.viewerMode !== 'deck') return;

	                const titleEl = document.getElementById('deck-slide-title');
	                const imgEl = document.getElementById('deck-slide-image');
	                const iframeEl = document.getElementById('deck-slide-iframe');
	                const videoEl = document.getElementById('deck-slide-video');
	                const textEl = document.getElementById('deck-slide-text');
	                const mediaWrap = imgEl ? imgEl.closest('.deck-slide-media') : null;
	                const infoWrap = textEl ? textEl.closest('.deck-slide-info') : null;
	                const countEl = document.getElementById('deck-slide-count');
	                const prevBtn = document.getElementById('btn-deck-prev');
	                const nextBtn = document.getElementById('btn-deck-next');

	                if (!titleEl || !imgEl || !iframeEl || !videoEl || !textEl) return;

	                const cps = this.collectControlPoints();
	                const total = cps.length;
	                const idx = elem && elem.id != null
	                    ? cps.findIndex((cp) => cp && cp.id != null && String(cp.id) === String(elem.id))
	                    : -1;

	                if (countEl && total > 0 && idx >= 0) {
	                    countEl.textContent = `${idx + 1} / ${total}`;
	                } else if (countEl) {
	                    countEl.textContent = '';
	                }
	                if (prevBtn) prevBtn.disabled = !(idx > 0);
	                if (nextBtn) nextBtn.disabled = !(idx >= 0 && idx < total - 1);

	                const resetMedia = () => {
	                    imgEl.removeAttribute('src');
	                    imgEl.style.display = 'none';

	                    try { videoEl.pause(); } catch {}
	                    videoEl.removeAttribute('src');
	                    videoEl.style.display = 'none';
	                    try { videoEl.load(); } catch {}

	                    iframeEl.removeAttribute('src');
	                    iframeEl.style.display = 'none';

	                    if (mediaWrap) mediaWrap.style.display = 'none';
	                };

	                if (!elem) {
	                    titleEl.textContent = '';
	                    textEl.textContent = '';
	                    if (infoWrap) infoWrap.style.display = 'none';
	                    resetMedia();
	                    return;
	                }

	                const info = this.extractSlideInfo(elem);
	                titleEl.textContent = info.title;
	                textEl.textContent = info.text || '';
	                if (infoWrap) infoWrap.style.display = String(info.text || '').trim() ? 'block' : 'none';

	                resetMedia();

	                const rawVideo = String(info.videoUrl || '').trim();
	                if (rawVideo) {
	                    const yt = this.toYouTubeEmbedUrl(rawVideo);
	                    if (yt) {
	                        iframeEl.src = yt;
	                        iframeEl.style.display = 'block';
	                        if (mediaWrap) mediaWrap.style.display = 'block';
	                        return;
	                    }

	                    videoEl.src = rawVideo;
	                    videoEl.style.display = 'block';
	                    if (mediaWrap) mediaWrap.style.display = 'block';
	                    return;
	                }

	                if (info.imageUrl) {
	                    imgEl.src = info.imageUrl;
	                    imgEl.style.display = 'block';
	                    if (mediaWrap) mediaWrap.style.display = 'block';
	                }
	            }

            getElementBounds(elem) {
                if (!elem || typeof elem !== 'object') return null;

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    if (Number.isFinite(elem.x) && Number.isFinite(elem.y) &&
                        Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        return { minX: x1, minY: y1, maxX: x2, maxY: y2 };
                    }
                    return this.getElementsBounds(elem.elements);
                }

                if (elem.type === 'line') {
                    const pts = this.getRoutePoints(elem);
                    if (!pts.length) return null;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    pts.forEach((p) => {
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (elem.type === 'mover') {
                    const state = this.resolveMoverState(elem, false);
                    const w = Math.max(16, Math.abs(Number(elem.width) || 44));
                    const h = Math.max(16, Math.abs(Number(elem.height) || 28));
                    return {
                        minX: state.x - (w / 2),
                        minY: state.y - (h / 2),
                        maxX: state.x + (w / 2),
                        maxY: state.y + (h / 2)
                    };
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
                    let minX = Infinity;
                    let minY = Infinity;
                    let maxX = -Infinity;
                    let maxY = -Infinity;
                    elem.points.forEach((p) => {
                        if (!p) return;
                        if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (Number.isFinite(elem.x) && Number.isFinite(elem.y)) {
                    if (Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
                        const x1 = Math.min(elem.x, elem.x + elem.width);
                        const x2 = Math.max(elem.x, elem.x + elem.width);
                        const y1 = Math.min(elem.y, elem.y + elem.height);
                        const y2 = Math.max(elem.y, elem.y + elem.height);
                        return { minX: x1, minY: y1, maxX: x2, maxY: y2 };
                    }
                    return { minX: elem.x, minY: elem.y, maxX: elem.x, maxY: elem.y };
                }

                return null;
            }

            focusCameraOnElement(elem) {
                const bounds = this.getElementBounds(elem);
                if (!bounds) return;

                const centerX = (bounds.minX + bounds.maxX) / 2;
                const centerY = (bounds.minY + bounds.maxY) / 2;

                const screen = this.worldToScreen(centerX, centerY);
                this.camera.x += (this.canvas.width / 2) - screen.x;
                this.camera.y += (this.canvas.height / 2) - screen.y;
            }

            getDeckShareUrl() {
                try {
                    return window.location.href;
                } catch {
                    return '';
                }
            }

            updateDeckShareStatus() {
                if (this.viewerMode !== 'deck') return;
                const statusEl = document.getElementById('deck-share-status');
                if (!statusEl) return;

                const url = this.getDeckShareUrl();
                if (!url) {
                    statusEl.textContent = '‚ö†Ô∏è No se pudo generar link.';
                    return;
                }

                try {
                    const parsed = new URL(url);
                    const dataParam = parsed.searchParams.get('data') || '';
                    const hasId = Boolean(parsed.searchParams.get('id'));
                    if (!hasId && dataParam && dataParam.length > 1500) {
                        statusEl.textContent = 'Tip: publica el proyecto para obtener un link corto (usa "Publicar").';
                        return;
                    }
                } catch {
                    // ignorar
                }

                statusEl.textContent = `Link actual: ${url}`;
            }

            async copyDeckLink() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                const statusEl = document.getElementById('deck-share-status');
                if (!url) {
                    if (statusEl) statusEl.textContent = '‚ö†Ô∏è No hay link para copiar.';
                    return;
                }

                try {
                    await navigator.clipboard.writeText(url);
                    if (statusEl) statusEl.textContent = '‚úÖ Link copiado al portapapeles.';
                } catch {
                    if (statusEl) statusEl.textContent = `Copia manual: ${url}`;
                }
            }

            async shareDeckNative() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                if (!url) return;

                const titleEl = document.getElementById('deck-slide-title');
                const title = titleEl && titleEl.textContent ? titleEl.textContent : 'L√°mina';

                if (navigator.share) {
                    try {
                        await navigator.share({ title, text: title, url });
                        return;
                    } catch {
                        // si el usuario cancela, no hacemos nada
                        return;
                    }
                }

                await this.copyDeckLink();
            }

            shareDeckToWhatsApp() {
                if (this.viewerMode !== 'deck') return;
                const url = this.getDeckShareUrl();
                if (!url) return;

                const titleEl = document.getElementById('deck-slide-title');
                const title = titleEl && titleEl.textContent ? titleEl.textContent : 'L√°mina';
                const text = `${title}\n${url}`;
                const waUrl = `https://wa.me/?text=${encodeURIComponent(text)}`;
                window.open(waUrl, '_blank', 'noopener');
            }

            sanitizeSubmoltName(input) {
                const s = String(input || '').trim().toLowerCase();
                if (!s) return 'general';
                if (!/^[a-z0-9_-]{1,40}$/.test(s)) return 'general';
                return s;
            }

            getMoltbookSubmoltFromUrlOrDefault() {
                try {
                    const params = new URLSearchParams(window.location.search);
                    return this.sanitizeSubmoltName(params.get('submolt') || params.get('molt') || 'general');
                } catch {
                    return 'general';
                }
            }

            async shareDeckToMoltbook() {
                if (this.viewerMode !== 'deck') return;

                const statusEl = document.getElementById('deck-share-status');
                const url = this.getDeckShareUrl();
                if (!url) {
                    if (statusEl) statusEl.textContent = '‚ö†Ô∏è No hay link para publicar.';
                    return;
                }

                const titleEl = document.getElementById('deck-slide-title');
                const title = titleEl && titleEl.textContent ? titleEl.textContent : 'L√°mina';
                const submolt = this.getMoltbookSubmoltFromUrlOrDefault();

                const headers = { 'content-type': 'application/json' };
                const publishKey = this.getPublishKey();
                if (publishKey) headers['x-publish-key'] = publishKey;

                if (statusEl) statusEl.textContent = `ü¶û Publicando en Moltbook (m/${submolt})...`;

                let res;
                let data;
                try {
                    res = await fetch('/api/moltbook-post', {
                        method: 'POST',
                        headers,
                        body: JSON.stringify({
                            submolt,
                            title: `üó∫Ô∏è ${title}`,
                            url
                        })
                    });
                    data = await res.json();
                } catch (err) {
                    if (statusEl) statusEl.textContent = `‚ùå Error de red al publicar en Moltbook: ${String(err)}`;
                    return;
                }

                if (!res.ok || !data || data.ok !== true) {
                    const hint =
                        (data && data.moltbook && data.moltbook.hint) ||
                        (data && data.moltbook && data.moltbook.error) ||
                        (data && data.error) ||
                        `HTTP ${res.status}`;

                    if (String(data && data.error) === 'Unauthorized' && !publishKey) {
                        if (statusEl) {
                            statusEl.textContent =
                                '‚ùå Unauthorized. Tip: abre el editor normal, pega tu PUBLISH_KEY en "Publicar", y vuelve a intentar (se guarda en este navegador).';
                        }
                        return;
                    }

                    if (statusEl) statusEl.textContent = `‚ùå Moltbook error: ${hint}`;
                    return;
                }

                if (statusEl) statusEl.textContent = '‚úÖ Publicado en Moltbook.';
            }

            setupDeckResizer() {
                if (this._deckResizerSetup) return;
                this._deckResizerSetup = true;

                const handle = document.getElementById('deck-resize-handle');
                if (!handle) return;

                handle.addEventListener('pointerdown', (e) => {
                    if (this.viewerMode !== 'deck') return;
                    this._deckResizing = true;
                    try {
                        handle.setPointerCapture(e.pointerId);
                    } catch {
                        // Ignorar
                    }
                    e.preventDefault();
                });

                handle.addEventListener('pointermove', (e) => {
                    if (!this._deckResizing) return;
                    if (this.viewerMode !== 'deck') return;

                    if (this.deckLayout === 'vertical') {
                        const minH = 220;
                        const maxH = Math.floor(window.innerHeight * 0.8);
                        const newH = Math.max(minH, Math.min(maxH, Math.floor(window.innerHeight - e.clientY)));
                        safeLocalStorageSet('deck-panel-height', String(newH));
                    } else {
                        const minW = 280;
                        const maxW = Math.floor(window.innerWidth * 0.7);
                        const newW = Math.max(minW, Math.min(maxW, Math.floor(window.innerWidth - e.clientX)));
                        safeLocalStorageSet('deck-panel-width', String(newW));
                    }

                    this.applyDeckSizing();
                    this.resizeCanvas();
                });

                const stop = (e) => {
                    if (!this._deckResizing) return;
                    this._deckResizing = false;
                    try {
                        handle.releasePointerCapture(e.pointerId);
                    } catch {
                        // Ignorar
                    }
                };

                handle.addEventListener('pointerup', stop);
                handle.addEventListener('pointercancel', stop);
            }

            setDeckLayout(layout) {
                this.deckLayout = layout === 'vertical' ? 'vertical' : 'horizontal';
                document.body.classList.add('deck-mode');
                document.body.classList.toggle('deck-horizontal', this.deckLayout === 'horizontal');
                document.body.classList.toggle('deck-vertical', this.deckLayout === 'vertical');
            }

            applyDeckSizing() {
                if (this.viewerMode !== 'deck') return;

                const deckPanel = document.getElementById('deck-panel');
                const deckNav = document.getElementById('deck-nav');
                const container = document.getElementById('canvas-container');
                if (!deckPanel || !container) return;

                const gutter = Math.max(10, Math.min(24, Math.floor(Math.min(window.innerWidth, window.innerHeight) * 0.02)));

                // Reset base styles del canvas en modo deck.
                container.style.position = 'fixed';
                container.style.background = 'transparent';
                container.style.width = '';
                container.style.height = '';
                container.style.maxWidth = '';
                container.style.maxHeight = '';

                if (this.deckLayout === 'vertical') {
                    if (deckNav) deckNav.classList.remove('show');
                    const minH = 220;
                    const maxH = Math.floor(window.innerHeight * 0.8);
                    const stored = Number(safeLocalStorageGet('deck-panel-height', '') || '');
                    const desired = Number.isFinite(stored) && stored > 0 ? stored : 380;
                    const panelH = Math.max(minH, Math.min(maxH, Math.floor(desired)));

                    deckPanel.style.top = 'auto';
                    deckPanel.style.left = '0';
                    deckPanel.style.right = '0';
                    deckPanel.style.bottom = '0';
                    deckPanel.style.width = '100vw';
                    deckPanel.style.height = `${panelH}px`;

                    // El canvas ocupa el area superior completa (sin forzar "cuadrado" que deja huecos).
                    container.style.left = `${gutter}px`;
                    container.style.top = `${gutter}px`;
                    container.style.right = `${gutter}px`;
                    container.style.bottom = `${panelH + gutter}px`;
                } else {
                    const minW = 280;
                    const maxW = Math.floor(window.innerWidth * 0.7);
                    const stored = Number(safeLocalStorageGet('deck-panel-width', '') || '');
                    const desired = Number.isFinite(stored) && stored > 0 ? stored : 420;
                    const panelW = Math.max(minW, Math.min(maxW, Math.floor(desired)));

                    deckPanel.style.top = '0';
                    deckPanel.style.left = 'auto';
                    deckPanel.style.right = '0';
                    deckPanel.style.bottom = '0';
                    deckPanel.style.width = `${panelW}px`;
                    deckPanel.style.height = '100vh';

                    // Columna intermedia (navegaci√≥n de diapositivas).
                    let navW = 300;
                    // Si el viewport es estrecho, reducir/ocultar la columna.
                    const availableForNav = Math.max(0, window.innerWidth - panelW - 420);
                    navW = Math.max(0, Math.min(navW, availableForNav));

                    const navShown = Boolean(deckNav && navW >= 220);
                    if (deckNav) {
                        if (navShown) {
                            deckNav.classList.add('show');
                            deckNav.style.top = '0';
                            deckNav.style.left = 'auto';
                            deckNav.style.right = `${panelW}px`;
                            deckNav.style.bottom = '0';
                            deckNav.style.width = `${navW}px`;
                            deckNav.style.height = '100vh';
                        } else {
                            deckNav.classList.remove('show');
                        }
                    }

                    const rightInset = panelW + (navShown ? navW : 0);

                    // Canvas ocupa el espacio restante, con un borde "sheet" (gutter).
                    container.style.left = `${gutter}px`;
                    container.style.top = `${gutter}px`;
                    container.style.bottom = `${gutter}px`;
                    container.style.right = `${rightInset + gutter}px`;
                }
            }

            applyViewerBackground(defaultBg) {
                const urlParams = new URLSearchParams(window.location.search);
                const raw = String(urlParams.get('bg') || '').trim().toLowerCase();

                let bg = raw || String(defaultBg || '').trim().toLowerCase();
                if (!bg) bg = 'transparent';

                if (bg === 'none' || bg === '0' || bg === 'clear') bg = 'transparent';
                if (bg === '3d' || bg === 'dark') bg = 'studio';

                document.documentElement.classList.remove('viewer-bg-transparent', 'viewer-bg-studio');
                document.body.classList.remove('viewer-bg-transparent', 'viewer-bg-studio');

                if (bg === 'studio') {
                    document.body.classList.add('viewer-bg-studio');
                } else {
                    document.documentElement.classList.add('viewer-bg-transparent');
                    document.body.classList.add('viewer-bg-transparent');
                }
            }

            getViewerFxEnabled(defaultOn) {
                const urlParams = new URLSearchParams(window.location.search);
                const raw = String(urlParams.get('fx') || urlParams.get('depth') || '').trim().toLowerCase();

                if (raw === '0' || raw === 'false' || raw === 'no' || raw === 'off') return false;
                if (raw === '1' || raw === 'true' || raw === 'yes' || raw === 'on') return true;

                return Boolean(defaultOn);
            }

            getViewerLabelsEnabled(defaultOn) {
                const urlParams = new URLSearchParams(window.location.search);
                const raw = String(urlParams.get('labels') || '').trim().toLowerCase();

                if (raw === '0' || raw === 'false' || raw === 'no' || raw === 'off') return false;
                if (raw === '1' || raw === 'true' || raw === 'yes' || raw === 'on') return true;

                return Boolean(defaultOn);
            }

            shouldRenderElementLabels() {
                if (!this.readOnly) return true;
                return Boolean(this.viewerShowLabels);
            }

	            shouldAutoFitForViewer() {
	                const urlParams = new URLSearchParams(window.location.search);
	                const mode = String(urlParams.get('mode') || '').toLowerCase();
	                const fitParam = String(urlParams.get('fit') || '').toLowerCase();

	                if (fitParam === '0' || fitParam === 'false' || fitParam === 'no') return false;
	                if (fitParam === '1' || fitParam === 'true' || fitParam === 'yes') return true;

	                // Default: solo auto-fit en modos visor si la c√°mara parece "default".
	                if (!(mode === 'preview' || mode === 'sticker' || mode === 'deck')) return false;

	                // En modo deck, el auto-fit por defecto evita "huecos" cuando la c√°mara qued√≥ guardada en una posici√≥n rara.
	                if (mode === 'deck') return true;

	                const cam = this.camera || {};
	                const x = Number(cam.x);
	                const y = Number(cam.y);
	                const z = Number(cam.zoom);
	                const isDefault =
	                    Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z) &&
                    Math.abs(x) < 1e-6 && Math.abs(y) < 1e-6 && Math.abs(z - 1) < 1e-6;

                return isDefault;
            }

            autoFitCameraToElements(paddingPx) {
                const bounds = this.getElementsBounds(this.elements);
                if (!bounds) return false;

                const pad = Number.isFinite(Number(paddingPx)) ? Number(paddingPx) : 48;

                const cw = this.canvas.width;
                const ch = this.canvas.height;
                if (!Number.isFinite(cw) || !Number.isFinite(ch) || cw <= 0 || ch <= 0) return false;

                const bw = Math.max(1, bounds.maxX - bounds.minX);
                const bh = Math.max(1, bounds.maxY - bounds.minY);

                const zoom = Math.min(cw / (bw + pad * 2), ch / (bh + pad * 2));
                const clamped = Math.max(0.05, Math.min(5, zoom));

                const cx = (bounds.minX + bounds.maxX) / 2;
                const cy = (bounds.minY + bounds.maxY) / 2;

                this.camera.zoom = clamped;
                this.camera.x = cw / 2 - cx * clamped;
                this.camera.y = ch / 2 - cy * clamped;
                this.updateZoomIndicator();
                return true;
            }

            maybeAutoFitViewerCamera() {
                if (!this.shouldAutoFitForViewer()) return;

                const urlParams = new URLSearchParams(window.location.search);
                const pad = Number.parseInt(String(urlParams.get('pad') || ''), 10);
                const padding = Number.isFinite(pad) ? Math.min(Math.max(pad, 0), 500) : 64;

                this.autoFitCameraToElements(padding);
            }

            applyStickerMode(modeVariant) {
                this.setLayersPanelOpen(false, { persist: false });

                // Ocultar deck
                const deckPanel = document.getElementById('deck-panel');
                if (deckPanel) deckPanel.classList.remove('show');
	                const deckNav = document.getElementById('deck-nav');
	                if (deckNav) deckNav.classList.remove('show');
	                document.body.classList.remove('deck-mode', 'deck-horizontal', 'deck-vertical');

                // Ocultar UI
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('properties-panel').style.display = 'none';
                document.getElementById('status-bar').style.display = 'none';
                document.getElementById('zoom-indicator').style.display = 'none';
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('close-path-hint').style.display = 'none';

                // Ajustar canvas al 100% de la pantalla
                const container = document.getElementById('canvas-container');
                container.style.top = '0';
                container.style.bottom = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.width = '';
                container.style.height = '';
                container.style.background = 'transparent';

                const urlParams = new URLSearchParams(window.location.search);
                const requested = String(modeVariant || urlParams.get('mode') || 'sticker').toLowerCase();
                const defaultBg = requested === 'preview' ? 'studio' : 'transparent';
                this.applyViewerBackground(defaultBg);
                this.depthFx = this.getViewerFxEnabled(true);
                this.viewerShowLabels = this.getViewerLabelsEnabled(false);

                // Deshabilitar interacciones de edici√≥n (solo navegaci√≥n)
                this.viewerMode = 'sticker';
                this.readOnly = true;
                this.tool = 'select';
                this.showGrid = false;
                this.backgroundColor = null;
                this.selectedElements = [];
                this.canvas.style.cursor = 'grab';

                // Recalcular tama√±o del canvas con el layout nuevo
                this.resizeCanvas();
                this.maybeAutoFitViewerCamera();
            }

            applyDeckMode() {
                this.setLayersPanelOpen(false, { persist: false });

                // Ocultar UI de edici√≥n
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('properties-panel').style.display = 'none';
                document.getElementById('status-bar').style.display = 'none';
                document.getElementById('zoom-indicator').style.display = 'none';
                document.getElementById('context-menu').style.display = 'none';
                document.getElementById('close-path-hint').style.display = 'none';

	                // Mostrar panel deck
	                const deckPanel = document.getElementById('deck-panel');
	                if (deckPanel) deckPanel.classList.add('show');
	                const deckNav = document.getElementById('deck-nav');
	                if (deckNav) deckNav.classList.add('show');

                this.applyViewerBackground('studio');
                this.depthFx = this.getViewerFxEnabled(true);
                this.viewerShowLabels = this.getViewerLabelsEnabled(false);

                this.viewerMode = 'deck';
                this.readOnly = true;
                this.tool = 'select';
                this.showGrid = false;
                this.backgroundColor = null;
                this.selectedElements = [];
                this.canvas.style.cursor = 'grab';

                // Layout horizontal/vertical (por query o responsive)
                const urlParams = new URLSearchParams(window.location.search);
                const rawLayout = String(urlParams.get('layout') || '').toLowerCase();
                const layout =
                    rawLayout === 'vertical' || rawLayout === 'v'
                        ? 'vertical'
                        : rawLayout === 'horizontal' || rawLayout === 'h'
                            ? 'horizontal'
                            : (window.innerWidth < 900 ? 'vertical' : 'horizontal');

                this.setDeckLayout(layout);
                this.applyDeckSizing();
                this.resizeCanvas();
                this.maybeAutoFitViewerCamera();

                // UI info (lista + diapositiva + link)
                this.refreshDeckUI();

                console.log('üß© MODO DECK ACTIVADO: L√°mina informativa (sticker + panel)');
            }

            applyViewerModeFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const mode = urlParams.get('mode');

                if (mode === 'deck') {
                    this.applyDeckMode();
                    return;
                }

                if (mode === 'preview' || mode === 'sticker') {
                    this.applyStickerMode(mode);
                }
            }

            flattenGroupElements(elements) {
                const out = [];
                (elements || []).forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;
                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        out.push(...this.flattenGroupElements(elem.elements));
                    } else {
                        out.push(elem);
                    }
                });
                return out;
            }

            getElementsBounds(elements) {
                let minX = Infinity;
                let minY = Infinity;
                let maxX = -Infinity;
                let maxY = -Infinity;

                const addPoint = (x, y) => {
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                };

                (elements || []).forEach((elem) => {
                    if (!elem || typeof elem !== 'object') return;

                    if (elem.type === 'group' && Array.isArray(elem.elements)) {
                        const bounds = this.getElementsBounds(elem.elements);
                        if (bounds) {
                            addPoint(bounds.minX, bounds.minY);
                            addPoint(bounds.maxX, bounds.maxY);
                        } else if (typeof elem.x === 'number' && typeof elem.y === 'number' &&
                                   typeof elem.width === 'number' && typeof elem.height === 'number') {
                            addPoint(elem.x, elem.y);
                            addPoint(elem.x + elem.width, elem.y + elem.height);
                        }
                        return;
                    }

                    if (elem.type === 'line') {
                        addPoint(elem.x, elem.y);
                        addPoint(elem.endX, elem.endY);
                        return;
                    }

                    if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                        elem.points.forEach((p) => addPoint(p.x, p.y));
                        return;
                    }

                    if (typeof elem.x === 'number' && typeof elem.y === 'number') {
                        if (typeof elem.width === 'number' && typeof elem.height === 'number') {
                            addPoint(elem.x, elem.y);
                            addPoint(elem.x + elem.width, elem.y + elem.height);
                        } else {
                            addPoint(elem.x, elem.y);
                        }
                    }
                });

                if (!Number.isFinite(minX)) return null;
                return { minX, minY, maxX, maxY };
            }

            ensureGroupBounds(group) {
                if (!group || typeof group !== 'object') return null;
                if (group.type !== 'group' || !Array.isArray(group.elements)) return null;

                let x = Number(group.x);
                let y = Number(group.y);
                let w = Number(group.width);
                let h = Number(group.height);
                const hasBox =
                    Number.isFinite(x) && Number.isFinite(y) &&
                    Number.isFinite(w) && Number.isFinite(h);

                if (!hasBox) {
                    const bounds = this.getElementsBounds(group.elements);
                    if (bounds) {
                        group.x = bounds.minX;
                        group.y = bounds.minY;
                        group.width = bounds.maxX - bounds.minX;
                        group.height = bounds.maxY - bounds.minY;
                        x = group.x;
                        y = group.y;
                        w = group.width;
                        h = group.height;
                    } else {
                        group.x = 0;
                        group.y = 0;
                        group.width = 0;
                        group.height = 0;
                        x = 0;
                        y = 0;
                        w = 0;
                        h = 0;
                    }
                }

                if (w < 0) {
                    x = x + w;
                    w = Math.abs(w);
                }
                if (h < 0) {
                    y = y + h;
                    h = Math.abs(h);
                }

                group.x = x;
                group.y = y;
                group.width = w;
                group.height = h;

                return { x1: x, y1: y, x2: x + w, y2: y + h };
            }

            getElementBounds(elem) {
                if (!elem || typeof elem !== 'object') return null;

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    const b = this.ensureGroupBounds(elem);
                    if (!b) return null;
                    return { minX: b.x1, minY: b.y1, maxX: b.x2, maxY: b.y2 };
                }

                if (elem.type === 'line') {
                    if (!Number.isFinite(elem.x) || !Number.isFinite(elem.y) || !Number.isFinite(elem.endX) || !Number.isFinite(elem.endY)) return null;
                    const pts = this.getRoutePoints(elem);
                    if (!pts.length) return null;
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    pts.forEach((p) => {
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (elem.type === 'mover') {
                    const state = this.resolveMoverState(elem, false);
                    const w = Math.max(16, Math.abs(Number(elem.width) || 44));
                    const h = Math.max(16, Math.abs(Number(elem.height) || 28));
                    return {
                        minX: state.x - (w / 2),
                        minY: state.y - (h / 2),
                        maxX: state.x + (w / 2),
                        maxY: state.y + (h / 2)
                    };
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points) && elem.points.length) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    elem.points.forEach((p) => {
                        if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return;
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    if (!Number.isFinite(minX)) return null;
                    return { minX, minY, maxX, maxY };
                }

                if (Number.isFinite(elem.x) && Number.isFinite(elem.y) && Number.isFinite(elem.width) && Number.isFinite(elem.height)) {
                    const x1 = Math.min(elem.x, elem.x + elem.width);
                    const x2 = Math.max(elem.x, elem.x + elem.width);
                    const y1 = Math.min(elem.y, elem.y + elem.height);
                    const y2 = Math.max(elem.y, elem.y + elem.height);
                    return { minX: x1, minY: y1, maxX: x2, maxY: y2 };
                }

                if (Number.isFinite(elem.x) && Number.isFinite(elem.y)) {
                    return { minX: elem.x, minY: elem.y, maxX: elem.x, maxY: elem.y };
                }

                return null;
            }

            updateBoxSelectionFromMarquee(options) {
                const opts = options && typeof options === 'object' ? options : {};
                if (!this.selectionBox) return;

                const s = this.selectionBox.start;
                const e = this.selectionBox.end;

                const x1 = Math.min(s.x, e.x);
                const y1 = Math.min(s.y, e.y);
                const x2 = Math.max(s.x, e.x);
                const y2 = Math.max(s.y, e.y);

                const inside = [];
                (this.elements || []).forEach((elem) => {
                    const b = this.getElementBounds(elem);
                    if (!b) return;
                    // Selecci√≥n por contenci√≥n (encuadrar): el elemento debe quedar dentro del marco.
                    const contained =
                        b.minX >= x1 && b.maxX <= x2 &&
                        b.minY >= y1 && b.maxY <= y2;
                    if (contained) inside.push(elem);
                });

                let next = inside;
                if (this.selectionBox.additive) {
                    const out = [];
                    const seen = new Set();
                    (this.selectionBox.base || []).forEach((el) => {
                        if (!el || typeof el !== 'object') return;
                        const id = String(el.id);
                        if (seen.has(id)) return;
                        seen.add(id);
                        out.push(el);
                    });
                    inside.forEach((el) => {
                        if (!el || typeof el !== 'object') return;
                        const id = String(el.id);
                        if (seen.has(id)) return;
                        seen.add(id);
                        out.push(el);
                    });
                    next = out;
                }

                this.selectedElements = next;
                this.updateLayersSelectionHighlight();
                this.updateStatusBar();

                if (opts.finalize) {
                    // Nada extra por ahora: el panel se decide fuera.
                }
            }

            offsetElement(elem, dx, dy) {
                if (!elem || typeof elem !== 'object') return;

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    if (typeof elem.x === 'number') elem.x += dx;
                    if (typeof elem.y === 'number') elem.y += dy;
                    elem.elements.forEach((child) => this.offsetElement(child, dx, dy));
                    return;
                }

                if (elem.type === 'line') {
                    elem.x += dx;
                    elem.y += dy;
                    elem.endX += dx;
                    elem.endY += dy;
                    return;
                }

                if ((elem.type === 'path' || elem.type === 'polygon') && Array.isArray(elem.points)) {
                    elem.points.forEach((p) => {
                        p.x += dx;
                        p.y += dy;
                    });
                    return;
                }

                if (typeof elem.x === 'number') elem.x += dx;
                if (typeof elem.y === 'number') elem.y += dy;
            }

            assignNewIdsRecursive(elem, idMap) {
                const map = idMap || new Map();
                if (!elem || typeof elem !== 'object') return map;

                const oldId = elem.id;
                const newId = Date.now() + Math.random();
                elem.id = newId;
                if (oldId != null) map.set(oldId, newId);

                if (elem.type === 'group' && Array.isArray(elem.elements)) {
                    elem.elements.forEach((child) => this.assignNewIdsRecursive(child, map));
                }

                return map;
            }

            async insertStickerById(id) {
                const status = document.getElementById('library-status');
                status.textContent = `Insertando: ${id}...`;

                let response;
                let project;
                try {
                    response = await fetch(`/api/project?id=${encodeURIComponent(id)}`);
                    project = await response.json();
                } catch (error) {
                    status.textContent = `‚ùå Error de red al cargar sticker: ${error}`;
                    return;
                }

                if (!response.ok) {
                    status.textContent = `‚ùå No se pudo cargar el sticker (${response.status})`;
                    return;
                }

                const rawElements = Array.isArray(project.elements) ? project.elements : [];
                const cloned = JSON.parse(JSON.stringify(rawElements));

                // Rechazar im√°genes para mantenerlo como "sticker" vectorial.
                if (this.hasImagesInElements(cloned)) {
                    status.textContent = '‚ùå Sticker contiene im√°genes (no soportado para inserci√≥n tipo sticker).';
                    return;
                }

                if (cloned.length === 0) {
                    status.textContent = '‚ö†Ô∏è Sticker vac√≠o';
                    return;
                }

                const groupName =
                    (project && typeof project.name === 'string' && project.name.trim())
                        ? project.name.trim()
                        : (String(id).split('/').filter(Boolean).pop() || String(id));

                const group = {
                    id: Date.now() + Math.random(),
                    type: 'group',
                    elements: cloned,
                    locked: false,
                    active: true,
                    connectionStatus: 'none',
                    fillColor: '#0f3460',
                    strokeColor: '#e94560',
                    name: groupName,
                    stickerSourceId: id
                };

                // Renombrar IDs para evitar colisiones (incluye hijos).
                this.assignNewIdsRecursive(group);

                // Colocar el sticker centrado en el viewport actual.
                const bounds = this.getElementsBounds(group.elements);
                if (bounds) {
                    group.x = bounds.minX;
                    group.y = bounds.minY;
                    group.width = bounds.maxX - bounds.minX;
                    group.height = bounds.maxY - bounds.minY;

                    const centerStickerX = (bounds.minX + bounds.maxX) / 2;
                    const centerStickerY = (bounds.minY + bounds.maxY) / 2;
                    const centerView = this.screenToWorld(this.canvas.width / 2, this.canvas.height / 2);
                    const dx = centerView.x - centerStickerX;
                    const dy = centerView.y - centerStickerY;
                    this.offsetElement(group, dx, dy);
                } else {
                    group.x = 0;
                    group.y = 0;
                    group.width = 0;
                    group.height = 0;
                }

                this.elements.push(group);
                this.selectedElements = [group];
                this.saveHistory();
                this.updatePropertiesPanel();
                this.updateStatusBar();

                const innerCount = this.countElementsRecursive(group.elements);
                status.textContent = `‚úÖ Insertado: ${id} (1 grupo, ${innerCount} elementos)`;
            }
            
            loadProject() {
                // Activar el input de archivo para cargar JSON
                document.getElementById('file-input').click();
            }
            
            loadFromLocalStorage() {
                // Cargar √∫ltimo proyecto autom√°ticamente
                const parsed = safeLocalStorageGetJSON('flow-diagrams', []);
                const projects = Array.isArray(parsed) ? parsed : [];
                if (projects.length > 0) {
                    const lastProject = projects[projects.length - 1];
                    this.normalizeProjectInPlace(lastProject);
                    this.elements = lastProject.elements || [];
                    this.camera = lastProject.camera || { x: 0, y: 0, zoom: 1 };
                }
                
                this.saveHistory();
                this.updateZoomIndicator();
                this.refreshDeckUI();
            }

            getWelcomeDeckProject() {
                // Proyecto por defecto (solo para `mode=deck` cuando no hay `id/data/project`).
                // Mantenerlo simple y sin dependencias externas.
                return {
                    name: 'Bienvenida al Futuro',
                    date: new Date().toISOString(),
                    camera: { x: 0, y: 0, zoom: 1 },
                    elements: [
                        {
                            id: 'welcome_core',
                            type: 'circle',
                            x: 400,
                            y: 300,
                            radius: 50,
                            color: '#00d4ff',
                            isAnim: true,
                            meta: {
                                controlPoint: true,
                                order: 1,
                                slide: {
                                    title: 'üöÄ Bienvenido a Flow Diagram Creator',
                                    text: 'Est√°s en el Visual Nexus. Aqu√≠ puedes crear diagramas animados, planos interactivos y experiencias 3D superpuestas.',
                                    // Archivo incluido en el repo (sirve en Vercel como /FHLL.gif).
                                    imageUrl: '/FHLL.gif'
                                }
                            }
                        },
                        {
                            id: 'tool_guide',
                            type: 'rectangle',
                            x: 600,
                            y: 200,
                            width: 60,
                            height: 60,
                            color: '#48ea79',
                            isAnim: true,
                            meta: {
                                controlPoint: true,
                                order: 2,
                                slide: {
                                    title: 'üõ†Ô∏è Herramientas de Precision',
                                    text: 'Usa el l√°piz para dibujar a mano alzada o los pol√≠gonos inteligentes para crear regiones clickeables con metadatos.',
                                    videoUrl: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'
                                }
                            }
                        }
                    ]
                };
            }

            loadWelcomeDeckProject() {
                const data = this.getWelcomeDeckProject();
                this.normalizeProjectInPlace(data);
                this.elements = data.elements || [];
                this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                this.selectedElements = [];
                this.saveHistory();
                this.updateZoomIndicator();
                this.maybeAutoFitViewerCamera();
                this.refreshDeckUI();
            }

            resolveProjectPayload(raw, depth = 0, seen = null) {
                if (raw == null) return null;
                if (depth > 6) return null;

                if (!seen) seen = new Set();

                let value = raw;
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (!trimmed) return null;
                    try {
                        value = JSON.parse(trimmed);
                    } catch {
                        return null;
                    }
                }

                if (!value || typeof value !== 'object') return null;

                if (Array.isArray(value)) {
                    return {
                        elements: value,
                        camera: { x: 0, y: 0, zoom: 1 }
                    };
                }

                if (seen.has(value)) return null;
                seen.add(value);

                if (Array.isArray(value.elements)) return value;

                const candidateKeys = [
                    'project', 'data', 'payload', 'result', 'value',
                    'content', 'json', 'diagram', 'flow', 'state', 'body'
                ];

                for (const key of candidateKeys) {
                    if (!(key in value)) continue;
                    const found = this.resolveProjectPayload(value[key], depth + 1, seen);
                    if (found) return found;
                }

                return null;
            }

            applyLoadedProject(raw, options = {}) {
                const source = String(options.source || 'fuente');
                const isDeck = Boolean(options.isDeck);
                const requireElements = options.requireElements !== false;

                const project = this.resolveProjectPayload(raw);
                if (!project) {
                    throw new Error(`Formato de proyecto inv√°lido (${source})`);
                }

                this.normalizeProjectInPlace(project);

                const hasElements = Array.isArray(project.elements) && project.elements.length > 0;
                if (isDeck && requireElements && !hasElements) {
                    throw new Error(`Proyecto vac√≠o (${source})`);
                }

                this.elements = project.elements || [];
                this.camera = project.camera || { x: 0, y: 0, zoom: 1 };
                this.selectedElements = [];
                this.saveHistory();
                this.updateZoomIndicator();
                this.maybeAutoFitViewerCamera();
                this.refreshDeckUI();
                return project;
            }
            
            loadFromURLParameter() {
                const urlParams = new URLSearchParams(window.location.search);
                const mode = String(urlParams.get('mode') || '').trim().toLowerCase();
                const isDeck = mode === 'deck';

                const deckFallback = (reason) => {
                    if (!isDeck) return;
                    console.log(`‚ÑπÔ∏è Fallback (deck): ${reason}`);
                    try {
                        const url = new URL(window.location.href);
                        url.searchParams.delete('id');
                        history.replaceState(null, '', url.toString());
                    } catch {
                        // Ignorar
                    }
                    this.loadWelcomeDeckProject();
                };

                // 0) Modo escucha (canal vivo): ?listen=SESSION
                const listenSession = urlParams.get('listen') || urlParams.get('session');
                if (listenSession) {
                    this.startListenSession(listenSession, urlParams.get('poll'));
                }

                // 1) JSON embebido en par√°metro (?data=...)
                const jsonData = urlParams.get('data');
                if (jsonData) {
                    let data;
                    try {
                        // URLSearchParams ya decodifica, pero dejamos fallback por compatibilidad.
                        data = JSON.parse(jsonData);
                    } catch (error) {
                        try {
                            data = JSON.parse(decodeURIComponent(jsonData));
                        } catch (error2) {
                            console.error('‚ùå Error al parsear JSON desde URL:', error2);
                            deckFallback('error al parsear par√°metro data');
                            return;
                        }
                    }
                    
                    try {
                        this.applyLoadedProject(data, {
                            source: 'par√°metro data',
                            isDeck
                        });
                        console.log('‚úÖ Proyecto cargado desde par√°metro data');
                    } catch (error) {
                        console.error('‚ùå Error al cargar proyecto desde par√°metro data:', error);
                        deckFallback('proyecto inv√°lido/vac√≠o en par√°metro data');
                    }
                    return;
                }

                // 2) Cargar por ID publicado (?id=...)
                const projectId = urlParams.get('id');
                if (projectId) {
                    fetch(`/api/project?id=${encodeURIComponent(projectId)}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.applyLoadedProject(data, {
                                source: 'id',
                                isDeck
                            });
                            console.log('‚úÖ Proyecto cargado desde ID');
                        })
                        .catch(error => {
                            console.error('‚ùå Error al cargar proyecto desde ID:', error);
                            deckFallback('id no encontrado o proyecto inv√°lido/vac√≠o');
                        });
                    return;
                }

                // 3) Cargar desde URL externa (?project=...)
                const projectUrl = urlParams.get('project');
                if (projectUrl) {
                    fetch(projectUrl)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.applyLoadedProject(data, {
                                source: 'url',
                                isDeck
                            });
                            console.log('‚úÖ Proyecto cargado desde URL');
                        })
                        .catch(error => {
                            console.error('‚ùå Error al cargar proyecto desde URL:', error);
                            deckFallback('error al cargar proyecto desde URL');
                        });
                    return;
                }

                // 3.5) Fallback: en `mode=deck` sin `id/data/project`, mostrar una l√°mina de bienvenida.
                if (isDeck) {
                    this.loadWelcomeDeckProject();
                }

                // 4) Auto-carga opcional: buscar ./project.json (misma carpeta)
                fetch('./project.json', { cache: 'no-store' })
                    .then(async response => {
                        if (response.status === 404) return null;
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }

                        // En despliegues tipo SPA, un rewrite puede devolver HTML con status 200.
                        // Si no parece JSON, lo ignoramos silenciosamente.
                        const contentType = (response.headers.get('content-type') || '').toLowerCase();
                        if (contentType.includes('text/html')) return null;

                        if (contentType.includes('json')) {
                            return response.json();
                        }

                        const text = await response.text();
                        try {
                            return JSON.parse(text);
                        } catch {
                            return null;
                        }
                    })
                    .then(data => {
                        if (!data) return;
                        this.applyLoadedProject(data, {
                            source: 'project.json',
                            isDeck,
                            requireElements: false
                        });
                        console.log('‚úÖ Proyecto cargado desde project.json');
                    })
                    .catch(error => {
                        console.error('‚ùå Error al cargar project.json:', error);
                    });
            }
            
            newProject() {
                if (confirm('¬øCrear nuevo proyecto? Los cambios no guardados se perder√°n.')) {
                    this.elements = [];
                    this.selectedElements = [];
                    this.camera = { x: 0, y: 0, zoom: 1 };
                    this.history = [];
                    this.historyIndex = -1;
                    this.saveHistory();
                    this.updateZoomIndicator();
                }
            }
            
	            exportProject() {
	                const projectData = {
	                    name: 'proyecto-exportado',
	                    date: new Date().toISOString(),
	                    elements: this.elements,
	                    camera: this.camera
	                };
	                
	                const blob = new Blob([JSON.stringify(projectData, (key, value) => {
	                    if (key === 'imageData') return undefined;
	                    if (key === 'videoData') return undefined;
	                    return value;
	                }, 2)], 
	                                     { type: 'application/json' });
	                const url = URL.createObjectURL(blob);
	                const a = document.createElement('a');
	                a.href = url;
                a.download = `flow-diagram-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            importProject(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        this.normalizeProjectInPlace(data);
                        this.elements = data.elements || [];
                        this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                        this.selectedElements = [];
                        this.saveHistory();
                        this.updateZoomIndicator();
                        this.refreshDeckUI();
                        alert('Proyecto importado exitosamente');
                    } catch (error) {
                        alert('Error al importar proyecto');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }

            sanitizeListenSession(input) {
                const s = String(input || '').trim().replace(/^\/+/, '').replace(/\\+/g, '/').replace(/\/+$/, '');
                if (!s) return '';
                if (!/^[a-zA-Z0-9/_-]+$/.test(s)) return '';
                if (s.includes('..')) return '';
                if (s.length > 120) return '';
                return s;
            }

            startListenSession(sessionRaw, pollMsRaw) {
                const session = this.sanitizeListenSession(sessionRaw);
                if (!session) {
                    console.warn('‚ö†Ô∏è listen inv√°lido (ignorado).');
                    return;
                }

                const parsed = Number.parseInt(String(pollMsRaw || ''), 10);
                const intervalMs = Number.isFinite(parsed) ? Math.min(Math.max(parsed, 500), 10000) : 1500;

                // Reset previo
                if (this.listenTimer) {
                    clearTimeout(this.listenTimer);
                    this.listenTimer = null;
                }
                this.listenSession = session;
                this.listenLastDate = null;

                const loop = async () => {
                    if (!this.listenSession) return;

                    try {
                        const res = await fetch(`/api/inject?session=${encodeURIComponent(session)}&t=${Date.now()}`, { cache: 'no-store' });

                        if (res.status === 404) {
                            // A√∫n no hay nada publicado en el canal.
                        } else if (!res.ok) {
                            console.warn('‚ö†Ô∏è listen error', res.status);
                        } else {
                            const data = await res.json();
                            const stamp = (data && typeof data.date === 'string') ? data.date : '';

                            if (stamp && stamp === this.listenLastDate) {
                                // sin cambios
                            } else if (data && typeof data === 'object' && Array.isArray(data.elements)) {
                                this.normalizeProjectInPlace(data);
                                this.elements = data.elements || [];
                                this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                                this.selectedElements = [];
                                this.saveHistory();
                                this.updateZoomIndicator();
                                this.maybeAutoFitViewerCamera();
                                this.refreshDeckUI();
                                this.listenLastDate = stamp || new Date().toISOString();
                                console.log('üì° Canal IA actualizado:', session);
                            }
                        }
                    } catch (err) {
                        console.warn('‚ö†Ô∏è listen network error', err);
                    } finally {
                        this.listenTimer = setTimeout(loop, intervalMs);
                    }
                };

                console.log('üì° LISTEN ACTIVADO:', session, `(${intervalMs}ms)`);
                loop();
            }
            
            // ==================== UI ====================
            
            updatePropertiesPanel() {
                if (this.selectedElements.length === 1) {
                    const elem = this.selectedElements[0];
                    
                    document.getElementById('prop-name').value = elem.name || '';
                    const fillTransparent = this.isTransparentColor(elem.fillColor);
                    const strokeTransparent = this.isTransparentColor(elem.strokeColor);

                    const fillPicker = document.getElementById('prop-fill-color');
                    const strokePicker = document.getElementById('prop-stroke-color');
                    const fillCb = document.getElementById('prop-fill-transparent');
                    const strokeCb = document.getElementById('prop-stroke-transparent');

                    if (fillCb) fillCb.checked = fillTransparent;
                    if (strokeCb) strokeCb.checked = strokeTransparent;

                    if (fillPicker) {
                        if (!fillTransparent && this.isHexColor(elem.fillColor)) {
                            fillPicker.value = elem.fillColor;
                        } else if (!this.isHexColor(fillPicker.value)) {
                            fillPicker.value = '#0f3460';
                        }
                    }
	                    if (strokePicker) {
	                        if (!strokeTransparent && this.isHexColor(elem.strokeColor)) {
	                            strokePicker.value = elem.strokeColor;
	                        } else if (!this.isHexColor(strokePicker.value)) {
	                            strokePicker.value = '#e94560';
	                        }
	                    }

	                    // Degradado (lineal) para relleno
	                    const fgEnabled = document.getElementById('prop-fill-gradient-enabled');
	                    const fgControls = document.getElementById('prop-fill-gradient-controls');
	                    const fgA = document.getElementById('prop-fill-gradient-a');
	                    const fgB = document.getElementById('prop-fill-gradient-b');
	                    const fgAngle = document.getElementById('prop-fill-gradient-angle');
	                    const fgAngleValue = document.getElementById('prop-fill-gradient-angle-value');

	                    const supportsGradient = this.elementSupportsFillGradient(elem);
	                    const fg = supportsGradient ? this.normalizeFillGradientSpec(elem.fillGradient) : null;
	                    const gradientOn = Boolean(fg && !fillTransparent);

	                    if (fgEnabled) {
	                        fgEnabled.disabled = !supportsGradient || fillTransparent;
	                        fgEnabled.checked = gradientOn;
	                    }
	                    if (fgControls) {
	                        fgControls.style.display = (fgEnabled && fgEnabled.checked) ? 'block' : 'none';
	                    }
	                    if (fg && fgA && this.isHexColor(fg.a)) fgA.value = fg.a;
	                    if (fg && fgB && this.isHexColor(fg.b)) fgB.value = fg.b;
	                    if (fg && fgAngle) fgAngle.value = String(fg.angle);
	                    if (fgAngle && fgAngleValue) fgAngleValue.textContent = `${String(fgAngle.value || '0')}¬∞`;

	                    const lwGroup = document.getElementById('prop-line-width-group');
	                    const lw = document.getElementById('prop-line-width');
	                    const lwVal = document.getElementById('prop-line-width-value');
                    const supportsLW = this.elementSupportsLineWidth(elem);
                    if (lwGroup) lwGroup.style.display = supportsLW ? 'block' : 'none';
                    if (supportsLW && lw) {
                        const v = this.getElementLineWidth(elem);
                        const clamped = Math.max(1, Math.min(20, Math.round(v)));
                        lw.value = String(clamped);
                        if (lwVal) lwVal.textContent = `${clamped}px`;
                    }
                    
                    if (elem.type === 'line') {
                        document.getElementById('prop-anim-color').value = elem.animColor || '#4caf50';
                        document.getElementById('prop-flow-direction').value = elem.flowDirection || 'right';
                    } else if (elem.type === 'mover') {
                        document.getElementById('prop-flow-direction').value = elem.flowDirection || 'right';
                    } else if (elem.followRoute) {
                        document.getElementById('prop-flow-direction').value = elem.routeDirection || elem.flowDirection || 'right';
                    }

                    const routeTools = document.getElementById('prop-route-tools');
                    const routeToggle = document.getElementById('prop-is-route');
                    const routeCurveInput = document.getElementById('prop-route-curve');
                    const routeArcSideInput = document.getElementById('prop-route-arc-side');
                    const routeArcDegWrap = document.getElementById('prop-route-arc-deg-wrap');
                    const routeArcDegInput = document.getElementById('prop-route-arc-deg');
                    const routeArcDegValue = document.getElementById('prop-route-arc-deg-value');
                    const isRouteCandidate = elem.type === 'line' || elem.type === 'path' || elem.type === 'polygon';
                    if (routeTools) routeTools.style.display = isRouteCandidate ? 'block' : 'none';
                    if (routeToggle) routeToggle.checked = this.isRouteElement(elem);
                    if (routeCurveInput) {
                        routeCurveInput.value = (elem.type === 'line') ? this.getRouteCurve(elem) : 'line';
                        routeCurveInput.disabled = !(elem.type === 'line' && this.isRouteElement(elem));
                    }
                    if (routeArcSideInput) {
                        routeArcSideInput.value = String(elem.routeArcSide || 'left');
                        const curve = (elem.type === 'line') ? this.getRouteCurve(elem) : 'line';
                        const canSide = curve === 'semi' || curve === 'quarter';
                        routeArcSideInput.disabled = !(elem.type === 'line' && this.isRouteElement(elem) && canSide);
                    }
                    const curve = (elem.type === 'line') ? this.getRouteCurve(elem) : 'line';
                    if (routeArcDegWrap) routeArcDegWrap.style.display = (curve === 'custom') ? 'block' : 'none';
                    if (routeArcDegInput) routeArcDegInput.value = String(Math.round(this.getRouteArcDegrees(elem)));
                    if (routeArcDegValue) routeArcDegValue.textContent = `${String(routeArcDegInput ? routeArcDegInput.value : Math.round(this.getRouteArcDegrees(elem)))}¬∞`;

                    const moverTools = document.getElementById('prop-mover-tools');
                    const followRouteInput = document.getElementById('prop-follow-route');
                    const routeIdInput = document.getElementById('prop-route-id');
                    const routeModeInput = document.getElementById('prop-route-mode');
                    const autoConnectRouteInput = document.getElementById('prop-auto-connect-route');
                    const moverSpeed = document.getElementById('prop-mover-speed');
                    const moverSpeedValue = document.getElementById('prop-mover-speed-value');
                    const moverSizeTools = document.getElementById('prop-mover-size-tools');
                    const moverWidth = document.getElementById('prop-mover-width');
                    const moverWidthValue = document.getElementById('prop-mover-width-value');
                    const moverHeight = document.getElementById('prop-mover-height');
                    const moverHeightValue = document.getElementById('prop-mover-height-value');
                    const isMover = elem.type === 'mover';
                    const isFollowerCandidate = elem.type !== 'line' && elem.type !== 'portal';
                    if (moverTools) moverTools.style.display = (isMover || isFollowerCandidate) ? 'block' : 'none';
                    if (followRouteInput) {
                        followRouteInput.checked = isMover ? true : Boolean(elem.followRoute);
                        followRouteInput.disabled = isMover;
                    }
                    if (isMover || isFollowerCandidate) {
                        if (routeIdInput) routeIdInput.value = String(elem.routeId || '');
                        if (routeModeInput) routeModeInput.value = String(elem.routeMode || 'loop');
                        if (autoConnectRouteInput) autoConnectRouteInput.checked = Boolean(elem.autoConnectRoute);
                        if (moverSpeed) {
                            const speedRaw = isMover ? Number(elem.speed) : Number(elem.routeSpeed);
                            const speed = Math.max(1, Math.min(300, speedRaw || 40));
                            moverSpeed.value = String(Math.round(speed));
                            if (moverSpeedValue) moverSpeedValue.textContent = String(Math.round(speed));
                        }
                    } else if (routeIdInput) {
                        routeIdInput.value = '';
                        if (autoConnectRouteInput) autoConnectRouteInput.checked = false;
                    }
                    if (moverSizeTools) moverSizeTools.style.display = isMover ? 'block' : 'none';
                    if (isMover) {
                        const w = Math.max(12, Math.min(320, Math.round(Math.abs(Number(elem.width) || 44))));
                        const h = Math.max(12, Math.min(320, Math.round(Math.abs(Number(elem.height) || 28))));
                        if (moverWidth) moverWidth.value = String(w);
                        if (moverWidthValue) moverWidthValue.textContent = String(w);
                        if (moverHeight) moverHeight.value = String(h);
                        if (moverHeightValue) moverHeightValue.textContent = String(h);
                    }

                    const portalTools = document.getElementById('prop-portal-tools');
                    const portalKindInput = document.getElementById('prop-portal-kind');
                    const portalKeyInput = document.getElementById('prop-portal-key');
                    const isPortal = elem.type === 'portal';
                    if (portalTools) portalTools.style.display = isPortal ? 'block' : 'none';
                    if (isPortal) {
                        if (portalKindInput) portalKindInput.value = String(elem.portalKind || 'import');
                        if (portalKeyInput) portalKeyInput.value = String(elem.portalKey || 'A1');
                    }
                    
                    document.getElementById('prop-connection-status').value = elem.connectionStatus || 'none';
                    document.getElementById('prop-active').value = elem.active ? 'true' : 'false';

	                    const geoTools = document.getElementById('prop-geometry-tools');
                        const geoBtn = document.getElementById('btn-convert-to-polygon');
	                    if (geoTools) {
	                        geoTools.style.display =
	                            (elem.type === 'rectangle' || elem.type === 'circle' || elem.type === 'image') ? 'block' : 'none';
	                    }
                        if (geoBtn) {
                            geoBtn.textContent = elem.type === 'image'
                                ? 'Convertir PNG a Pol√≠gono'
                                : 'Convertir a Pol√≠gono';
                        }

	                    // Punto de Informaci√≥n (L√°mina)
	                    const cpGroup = document.getElementById('prop-control-point-group');
	                    const cpEnabled = document.getElementById('prop-cp-enabled');
	                    const cpDetails = document.getElementById('prop-cp-details');
	                    const cpOrder = document.getElementById('prop-cp-order');
	                    const slideTitle = document.getElementById('prop-slide-title');
	                    const slideText = document.getElementById('prop-slide-text');
	                    const slideImageUrl = document.getElementById('prop-slide-image-url');
	                    const slideVideoUrl = document.getElementById('prop-slide-video-url');

	                    if (cpGroup) cpGroup.style.display = 'block';

	                    const isCp = this.isControlPoint(elem);
	                    if (cpEnabled) cpEnabled.checked = Boolean(isCp);
	                    if (cpDetails) cpDetails.style.display = isCp ? 'block' : 'none';

	                    if (isCp) {
	                        this.ensureControlPointOrders(this.elements);
	                        const order = this.getControlPointOrder(elem);
	                        if (cpOrder) cpOrder.value = order != null ? String(order) : '';

	                        const info = this.extractSlideInfo(elem);
	                        if (slideTitle) slideTitle.value = info.title || '';
	                        if (slideText) slideText.value = info.text || '';
	                        if (slideImageUrl) slideImageUrl.value = info.imageUrl || '';
	                        if (slideVideoUrl) slideVideoUrl.value = info.videoUrl || '';
	                    } else {
	                        if (cpOrder) cpOrder.value = '';
	                        if (slideTitle) slideTitle.value = '';
	                        if (slideText) slideText.value = '';
	                        if (slideImageUrl) slideImageUrl.value = '';
	                        if (slideVideoUrl) slideVideoUrl.value = '';
	                    }
	                    
	                    document.getElementById('properties-panel').classList.add('show');
	                } else {
	                    this.hidePropertiesPanel();
	                }
                this.updateLayersSelectionHighlight();
            }
            
            hidePropertiesPanel() {
                document.getElementById('properties-panel').classList.remove('show');
                this.updateLayersSelectionHighlight();
            }
            
		            updateSelectedProperties() {
		                const name = document.getElementById('prop-name').value;
		                const cpEnabledEl = document.getElementById('prop-cp-enabled');
		                const cpOrderEl = document.getElementById('prop-cp-order');
		                const slideTitleEl = document.getElementById('prop-slide-title');
		                const slideTextEl = document.getElementById('prop-slide-text');
		                const slideImageUrlEl = document.getElementById('prop-slide-image-url');
		                const slideVideoUrlEl = document.getElementById('prop-slide-video-url');
		                const cpEnabled = Boolean(cpEnabledEl && cpEnabledEl.checked);
		                const fillPicker = document.getElementById('prop-fill-color');
		                const strokePicker = document.getElementById('prop-stroke-color');
		                const fillCb = document.getElementById('prop-fill-transparent');
		                const strokeCb = document.getElementById('prop-stroke-transparent');
		                const fgEnabledEl = document.getElementById('prop-fill-gradient-enabled');
		                const fgAEl = document.getElementById('prop-fill-gradient-a');
		                const fgBEl = document.getElementById('prop-fill-gradient-b');
		                const fgAngleEl = document.getElementById('prop-fill-gradient-angle');
		                const conn = document.getElementById('prop-connection-status').value;
	                const active = document.getElementById('prop-active').value === 'true';

	                const fillTransparent = Boolean(fillCb && fillCb.checked);
	                const strokeTransparent = Boolean(strokeCb && strokeCb.checked);
	                const fillGradientEnabled = Boolean(fgEnabledEl && fgEnabledEl.checked);
	                const fillGradientSpec = fillGradientEnabled
	                    ? this.normalizeFillGradientSpec({
	                        a: fgAEl ? fgAEl.value : '',
	                        b: fgBEl ? fgBEl.value : '',
	                        angle: fgAngleEl ? fgAngleEl.value : 0
	                    })
	                    : null;

	                const lw = document.getElementById('prop-line-width');
	                const lwValue = lw ? Number.parseInt(String(lw.value || ''), 10) : NaN;
                    const lineWidth = Number.isFinite(lwValue) ? Math.max(1, Math.min(20, lwValue)) : null;
                    const routeFlag = Boolean(document.getElementById('prop-is-route') && document.getElementById('prop-is-route').checked);
                    const routeCurve = String((document.getElementById('prop-route-curve') && document.getElementById('prop-route-curve').value) || 'line');
                    const routeArcSide = String((document.getElementById('prop-route-arc-side') && document.getElementById('prop-route-arc-side').value) || 'left');
                    const routeArcDegRaw = Number((document.getElementById('prop-route-arc-deg') && document.getElementById('prop-route-arc-deg').value) || 120);
                    const routeArcDegrees = Number.isFinite(routeArcDegRaw) ? Math.max(5, Math.min(355, routeArcDegRaw)) : 120;
                    const followRouteFlag = Boolean(document.getElementById('prop-follow-route') && document.getElementById('prop-follow-route').checked);
                    const autoConnectRouteFlag = Boolean(document.getElementById('prop-auto-connect-route') && document.getElementById('prop-auto-connect-route').checked);
                    const routeId = String((document.getElementById('prop-route-id') && document.getElementById('prop-route-id').value) || '').trim();
                    const routeMode = String((document.getElementById('prop-route-mode') && document.getElementById('prop-route-mode').value) || 'loop');
                    const portalKind = String((document.getElementById('prop-portal-kind') && document.getElementById('prop-portal-kind').value) || 'import');
                    const portalKey = String((document.getElementById('prop-portal-key') && document.getElementById('prop-portal-key').value) || 'A1').trim();
                    const moverSpeedEl = document.getElementById('prop-mover-speed');
                    const moverSpeedRaw = moverSpeedEl ? Number.parseFloat(String(moverSpeedEl.value || '')) : NaN;
                    const moverSpeed = Number.isFinite(moverSpeedRaw) ? Math.max(1, Math.min(300, moverSpeedRaw)) : 40;
                    const moverWidthEl = document.getElementById('prop-mover-width');
                    const moverWidthRaw = moverWidthEl ? Number.parseFloat(String(moverWidthEl.value || '')) : NaN;
                    const moverWidth = Number.isFinite(moverWidthRaw) ? Math.max(12, Math.min(320, moverWidthRaw)) : 44;
                    const moverHeightEl = document.getElementById('prop-mover-height');
                    const moverHeightRaw = moverHeightEl ? Number.parseFloat(String(moverHeightEl.value || '')) : NaN;
                    const moverHeight = Number.isFinite(moverHeightRaw) ? Math.max(12, Math.min(320, moverHeightRaw)) : 28;

	                this.selectedElements.forEach((elem) => {
		                    if (!elem || typeof elem !== 'object') return;
		                    elem.name = name;

		                    if (fillTransparent) {
	                        elem.fillColor = 'transparent';
	                        try { delete elem.fillGradient; } catch {}
	                    } else if (fillPicker && typeof fillPicker.value === 'string') {
	                        elem.fillColor = fillPicker.value;
	                        if (fillGradientSpec && this.elementSupportsFillGradient(elem)) {
	                            elem.fillGradient = fillGradientSpec;
	                        } else {
	                            try { delete elem.fillGradient; } catch {}
	                        }
	                    }

	                    if (strokeTransparent) {
	                        elem.strokeColor = 'transparent';
	                    } else if (strokePicker && typeof strokePicker.value === 'string') {
	                        elem.strokeColor = strokePicker.value;
	                    }

                    if (lineWidth !== null && this.elementSupportsLineWidth(elem)) {
                        elem.lineWidth = lineWidth;
                    }

                    elem.connectionStatus = conn;
                    elem.active = active;
                    
	                    if (elem.type === 'line') {
	                        elem.animColor = document.getElementById('prop-anim-color').value;
	                        elem.flowDirection = document.getElementById('prop-flow-direction').value;
	                    }
                        if (elem.type === 'line' || elem.type === 'path' || elem.type === 'polygon') {
                            elem.routeRole = routeFlag;
                            if (elem.type === 'line') {
                                elem.routeCurve = routeCurve;
                                elem.routeArcSide = (routeArcSide === 'right') ? 'right' : 'left';
                                elem.routeArcDegrees = routeArcDegrees;
                                elem.routeCircular = routeCurve === 'circle';
                            }
                        }
                        if (elem.type === 'mover') {
                            elem.routeId = routeId;
                            elem.speed = moverSpeed;
                            elem.flowDirection = document.getElementById('prop-flow-direction').value;
                            elem.routeMode = routeMode;
                            elem.autoConnectRoute = autoConnectRouteFlag;
                            elem.width = moverWidth;
                            elem.height = moverHeight;
                        } else if (elem.type !== 'line' && elem.type !== 'portal') {
                            elem.followRoute = followRouteFlag;
                            elem.routeId = routeId;
                            elem.routeSpeed = moverSpeed;
                            elem.routeDirection = document.getElementById('prop-flow-direction').value;
                            elem.routeMode = routeMode;
                            elem.autoConnectRoute = autoConnectRouteFlag;
                        }
                        if (elem.type === 'portal') {
                            elem.portalKind = (portalKind === 'export') ? 'export' : 'import';
                            elem.portalKey = portalKey || 'A1';
                        }

	                    // Punto de Informaci√≥n (L√°mina)
	                    if (cpEnabledEl) {
	                        if (cpEnabled) {
	                            const meta = this.ensureElementMeta(elem);
	                            meta.controlPoint = true;
	                            if (!meta.slide || typeof meta.slide !== 'object' || Array.isArray(meta.slide)) {
	                                meta.slide = {};
	                            }

	                            // Orden
	                            const parsedOrder = Number.parseInt(String(cpOrderEl && cpOrderEl.value || ''), 10);
	                            if (Number.isFinite(parsedOrder) && parsedOrder > 0) {
	                                meta.order = parsedOrder;
	                            } else if (!Number.isFinite(Number(meta.order)) || Number(meta.order) <= 0) {
	                                meta.order = this.getNextControlPointOrder(this.elements);
	                            }

	                            // Slide content
	                            if (slideTitleEl) meta.slide.title = String(slideTitleEl.value || '');
	                            if (slideTextEl) meta.slide.text = String(slideTextEl.value || '');
	                            if (slideImageUrlEl) meta.slide.imageUrl = String(slideImageUrlEl.value || '');
	                            if (slideVideoUrlEl) meta.slide.videoUrl = String(slideVideoUrlEl.value || '');

	                            // Mantener defaults razonables
	                            if (!String(meta.slide.title || '').trim() && meta.order) {
	                                meta.slide.title = `Punto ${String(meta.order)}`;
	                            }

	                            this.ensureControlPointOrders(this.elements);
	                        } else {
	                            // Desactivar como punto (no borra otras metas ajenas)
	                            if (elem.meta && typeof elem.meta === 'object' && !Array.isArray(elem.meta)) {
	                                delete elem.meta.controlPoint;
	                                delete elem.meta.isControlPoint;
	                                delete elem.meta.order;
	                                delete elem.meta.slide;
	                                delete elem.meta.slideTitle;
	                                delete elem.meta.slideText;
	                                delete elem.meta.slideImageUrl;
	                                delete elem.meta.slideVideoUrl;
	                            }
	                            delete elem.slide;
	                            delete elem.slideTitle;
	                            delete elem.slideText;
	                            delete elem.slideImageUrl;
	                            delete elem.slideVideoUrl;
	                        }
	                    }
	                });
	            }

            isTransparentColor(value) {
                if (value === null || value === undefined) return true;
                const v = String(value).trim().toLowerCase();
                if (!v) return true;
                if (v === 'transparent') return true;
                if (v === '#00000000') return true;
                if (/^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0(?:\.0+)?\s*\)$/.test(v)) return true;
                return false;
            }

            normalizeCanvasColor(value) {
                return this.isTransparentColor(value) ? 'rgba(0,0,0,0)' : String(value);
            }

            elementSupportsFillGradient(elem) {
                if (!elem || typeof elem !== 'object') return false;
                const t = String(elem.type || '');
                return t === 'rectangle' || t === 'circle' || t === 'polygon' || t === 'path';
            }

            normalizeFillGradientSpec(spec) {
                if (!spec || typeof spec !== 'object' || Array.isArray(spec)) return null;

                const hasAny =
                    spec.a != null || spec.b != null ||
                    spec.from != null || spec.to != null ||
                    spec.colorA != null || spec.colorB != null ||
                    spec.start != null || spec.end != null ||
                    spec.color1 != null || spec.color2 != null ||
                    spec.angle != null || spec.deg != null ||
                    spec.rotation != null || spec.rot != null || spec.theta != null;

                if (!hasAny) return null;

                const aRaw = spec.a ?? spec.from ?? spec.colorA ?? spec.start ?? spec.color1;
                const bRaw = spec.b ?? spec.to ?? spec.colorB ?? spec.end ?? spec.color2;

                const a = this.normalizeCanvasColor(aRaw != null ? aRaw : '#00d4ff');
                const b = this.normalizeCanvasColor(bRaw != null ? bRaw : '#e94560');

                const angleRaw = spec.angle ?? spec.deg ?? spec.rotation ?? spec.rot ?? spec.theta;
                let angle = Number.parseFloat(String(angleRaw != null ? angleRaw : '90'));
                if (!Number.isFinite(angle)) angle = 90;
                angle = ((angle % 360) + 360) % 360;

                // Snap a pasos de 15 grados (consistente con el UI) para evitar drift.
                angle = Math.round(angle / 15) * 15;
                angle = ((angle % 360) + 360) % 360;

                return { a, b, angle };
            }

            createLinearGradientForBounds(bounds, angleDeg, colorA, colorB) {
                if (!this.ctx) return null;
                if (!bounds || typeof bounds !== 'object') return null;

                const minX = Number(bounds.minX);
                const minY = Number(bounds.minY);
                const maxX = Number(bounds.maxX);
                const maxY = Number(bounds.maxY);
                if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;

                const w = Math.max(1, maxX - minX);
                const h = Math.max(1, maxY - minY);
                const cx = (minX + maxX) / 2;
                const cy = (minY + maxY) / 2;

                let angle = Number(angleDeg);
                if (!Number.isFinite(angle)) angle = 90;
                angle = ((angle % 360) + 360) % 360;

                const theta = (angle * Math.PI) / 180;
                const ux = Math.cos(theta);
                const uy = Math.sin(theta);
                const half = Math.abs(ux) * (w / 2) + Math.abs(uy) * (h / 2);

                const x0 = cx - ux * half;
                const y0 = cy - uy * half;
                const x1 = cx + ux * half;
                const y1 = cy + uy * half;

                const grad = this.ctx.createLinearGradient(x0, y0, x1, y1);
                grad.addColorStop(0, this.normalizeCanvasColor(colorA));
                grad.addColorStop(1, this.normalizeCanvasColor(colorB));
                return grad;
            }

            applyBucketFillToElement(elem) {
                if (!elem || typeof elem !== 'object') return;

                const fillCb = document.getElementById('prop-fill-transparent');
                const fillPicker = document.getElementById('prop-fill-color');

                const fgEnabledEl = document.getElementById('prop-fill-gradient-enabled');
                const fgAEl = document.getElementById('prop-fill-gradient-a');
                const fgBEl = document.getElementById('prop-fill-gradient-b');
                const fgAngleEl = document.getElementById('prop-fill-gradient-angle');

                const fillTransparent = Boolean(fillCb && fillCb.checked);

                const fillColorValue =
                    (fillPicker && typeof fillPicker.value === 'string') ? fillPicker.value : '#0f3460';

                const fillGradientEnabled = Boolean(fgEnabledEl && fgEnabledEl.checked);
                const fillGradientSpec = fillGradientEnabled
                    ? this.normalizeFillGradientSpec({
                        a: fgAEl ? fgAEl.value : '',
                        b: fgBEl ? fgBEl.value : '',
                        angle: fgAngleEl ? fgAngleEl.value : 90
                    })
                    : null;

                const applyTo = (target) => {
                    if (!target || typeof target !== 'object') return;
                    if (target.locked) return;

                    if (target.type === 'group' && Array.isArray(target.elements)) {
                        target.elements.forEach((child) => applyTo(child));
                        return;
                    }

                    const t = String(target.type || '');
                    const supportsFill = t === 'rectangle' || t === 'circle' || t === 'polygon' || t === 'path';
                    if (!supportsFill) return;

                    if (fillTransparent) {
                        target.fillColor = 'transparent';
                        try { delete target.fillGradient; } catch {}
                        return;
                    }

                    target.fillColor = fillColorValue;
                    if (fillGradientSpec && this.elementSupportsFillGradient(target)) {
                        target.fillGradient = fillGradientSpec;
                    } else {
                        try { delete target.fillGradient; } catch {}
                    }
                };

                applyTo(elem);
            }

            isHexColor(value) {
                if (value === null || value === undefined) return false;
                return /^#[0-9a-fA-F]{6}$/.test(String(value).trim());
            }

            elementSupportsLineWidth(elem) {
                if (!elem || typeof elem !== 'object') return false;
                const t = String(elem.type || '');
                return t === 'rectangle' || t === 'circle' || t === 'line' || t === 'path' || t === 'polygon';
            }

            getElementLineWidth(elem) {
                const t = elem && elem.type ? String(elem.type) : '';
                const raw = elem ? elem.lineWidth : null;
                const v = (typeof raw === 'number') ? raw : Number.parseFloat(String(raw));
                if (Number.isFinite(v) && v > 0) return v;
                // Defaults hist√≥ricos del editor: rect/circle = 2, l√≠neas = 3
                if (t === 'rectangle' || t === 'circle' || t === 'image' || t === 'video') return 2;
                return 3;
            }
            
            updateZoomIndicator() {
                document.getElementById('zoom-indicator').textContent = 
                    `Zoom: ${Math.round(this.camera.zoom * 100)}%`;
            }
            
            updateStatusBar() {
                document.getElementById('status-text').textContent = 
                    `Listo | Elementos: ${this.elements.length} | Seleccionados: ${this.selectedElements.length}`;
            }
        }
        
        // ==================== INICIALIZAR SISTEMA ====================
        
        let system = null;
        try {
            system = new FlowDiagramSystem();
            // Exponer para debug/manual (DevTools) y para integraciones IA.
            window.system = system;
        } catch (err) {
            try {
                if (window.showFatalError) window.showFatalError(err, 'boot');
            } catch {
                // Ignorar
            }
            console.error(err);
        }
        
        if (system) {
            console.log('üöÄ Sistema de Diagramas de Flujo v1.2.0 - FASE A Iniciado');
            console.log('üìö Arquitectura modular lista para expansi√≥n');
            console.log('');
            console.log('‚ú® NUEVAS CARACTER√çSTICAS v1.2.0 - FASE A:');
            console.log('   ‚úì Insertar im√°genes como capas base (PNG con transparencia)');
            console.log('   ‚úì Dibujar encima de im√°genes con todas las herramientas');
            console.log('   ‚úì Convertir trazos en pol√≠gonos cerrados (cierra autom√°tico)');
            console.log('   ‚úì Sistema de capas Z-index (Men√∫ contextual con bot√≥n derecho)');
            console.log('   ‚úì Traer al frente / Enviar atr√°s');
            console.log('   ‚úì Duplicar elementos con men√∫ contextual');
            console.log('');
            console.log('üé® DIBUJO CON L√ÅPIZ MEJORADO:');
            console.log('   - Dibuja con l√°piz (P)');
            console.log('   - Ac√©rcate al punto inicial para CERRAR la figura autom√°ticamente');
            console.log('   - Los pol√≠gonos cerrados se rellenan con color');
            console.log('   - Crea formas personalizadas trazando el contorno');
            console.log('');
            console.log('üñºÔ∏è TRABAJO CON IM√ÅGENES:');
            console.log('   - Click en "Imagen" o presiona I');
            console.log('   - Redimensiona manteniendo proporci√≥n');
            console.log('   - Dibuja ENCIMA de la imagen para crear diagramas');
            console.log('   - Soporta PNG, JPG, GIF, WEBP');
            console.log('');
            console.log('üóÇÔ∏è CONTROL DE CAPAS:');
            console.log('   - Bot√≥n derecho sobre elemento ‚Üí Men√∫ contextual');
            console.log('   - Traer al frente de todo / Enviar al fondo');
            console.log('   - Traer adelante / Enviar atr√°s (un nivel)');
            console.log('   - Duplicar / Eliminar');
            console.log('');
            console.log('‚å®Ô∏è ATAJOS DE TECLADO:');
            console.log('   V = Seleccionar | R = Rect√°ngulo | C = C√≠rculo | T = Formas | L = L√≠nea | P = L√°piz | I = Imagen');
            console.log('   Espacio = Pan (mover canvas) | Ctrl+C/V = Copiar/Pegar');
            console.log('   Doble clic en elemento = Activar/Desactivar animaci√≥n');
            console.log('   Bot√≥n derecho = Men√∫ contextual de capas');
        }
        
        // ==================== MODOS IA (PREVIEW / STICKER / DECK) ====================

        function applyIAmodes() {
            if (!system) return;
            system.applyViewerModeFromUrl();
        }

        // Ejecutar al cargar la p√°gina
        window.addEventListener('load', applyIAmodes);
    </script>
</body>
</html>
